(() => {
  var e = [
      ,
      (e) => {
        "use strict";
        let t;
        function n() {
          return (
            t ||
            (console.error(
              "The `provider` object has not been set, please do so by calling the `init` method.",
            ),
            null)
          );
        }
        const s = {
          init: function (e, n) {
            return (t = e), this.add(n);
          },
          _getValue: function (e, n) {
            let s;
            return (
              "function" == typeof n
                ? ((s = n(t)),
                  s ||
                    console.warn(
                      "The function for key " + e + " returned a falsy value: ",
                      s,
                    ))
                : "string" == typeof n
                  ? ((s = t.get(n)),
                    s ||
                      console.warn(
                        "The provider `get` invocation for the key " +
                          e +
                          " returned a falsy value: ",
                        s,
                      ))
                  : "object" == typeof n && (s = n),
              s
            );
          },
          add: function (e) {
            e = e || {};
            const t = [],
              n = this;
            return (
              Object.keys(e).forEach(function (s) {
                const i = e[s],
                  o = n._getValue(s, i);
                o && o.then
                  ? (o.then(function (e) {
                      e ||
                        console.warn(
                          "The promise for the key " +
                            s +
                            " resolved with a falsy value: ",
                          e,
                        ),
                        n._addValue(s, e);
                    }),
                    t.push(o))
                  : n._addValue(s, o);
              }),
              Promise.all(t)
            );
          },
          _addValue: function (e, t) {
            this[e] = t;
          },
          provider: function () {
            return (
              console.error(
                "The function `provider` has been deprecated, please use `getProvider`",
                new Error().stack,
              ),
              n()
            );
          },
          getProvider: function () {
            return n();
          },
        };
        e.exports = s;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = m(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(3)),
          i = u(n(150)),
          o = n(151),
          a = n(155),
          r = u(n(156)),
          l = n(152),
          c = u(n(157));
        function u(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function m(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (m = function (e) {
            return e ? n : t;
          })(e);
        }
        const d = n(1),
          { ViewportPlugin: p } = d,
          { DataBinding: h } = d,
          { UXSettings: g } = d,
          f = d.Lodash,
          { EmberHelpers: S } = d,
          { Telemetry: b } = d,
          y = o.PositionAssignmentPreloadVideos;
        var _ = new (class {
          constructor() {
            const e = d.getProvider();
            this.champSelectVideoCache =
              d.UiKitPlugin.getVideoCache().createCache(
                "rcp-fe-lol-champ-select",
              );
            const t = d.l10n.tra().overlay("/fe/lol-champ-select/trans.json");
            Promise.all([
              t.getAsync("dodge_header"),
              t.getAsync("dodge_body"),
              t.getAsync("clash_dodge_body"),
            ]).then(
              function (e) {
                (this._dodgeMessage = { header: e[0], body: e[1] }),
                  (this._clashDodgeMessage = { header: e[0], body: e[2] });
              }.bind(this),
            ),
              (this._isShown = !1),
              (this.uxSettingsObserver = function (e) {
                e &&
                  (this.largeAreaAnimationsEnabled =
                    e.largeAreaAnimationsEnabled);
              }.bind(this)),
              (this.showPromise = Promise.resolve()),
              (this.appControls = e.get("rcp-fe-lol-navigation")),
              (this.screenRoot = p
                .fullScreen()
                .getScreenRoot("rcp-fe-lol-champ-select")),
              (this.champSelectHandlers = [
                {
                  show: this.champSelectShowHandler.bind(this),
                  hide: this.champSelectHideHandler.bind(this),
                  shouldShow: () => !0,
                },
              ]),
              g.addObserver(this.uxSettingsObserver),
              (this.gameflowBinding = h("/lol-gameflow", e.getSocket())),
              this.gameflowBinding.observe(
                "/v1/session",
                this,
                function (e) {
                  this._changePhase(e && e.phase);
                  const t = e && e.gameData;
                  (this._isCustomGame = t && e.gameData.isCustomGame),
                    (this._isClashGame =
                      t &&
                      e.gameData.queue &&
                      "CLASH" === e.gameData.queue.type);
                }.bind(this),
              ),
              (this.champSelectBinding = h("/lol-champ-select", e.getSocket())),
              this.champSelectBinding.observe(
                "/v1/session",
                this,
                function (e) {
                  this._champSelectSession = e;
                }.bind(this),
              );
            const n = p.getApiKey(
                "rcp-fe-lol-champ-select-skip - bump/release champ-select-skip",
              ),
              s = p
                .fullScreen()
                .getScreenRoot(n, "rcp-fe-lol-champ-select-skip");
            this._champSelectSkipApi = new r.default(s, this);
          }
          _handleVideoCache(e, t) {
            "Lobby" === e &&
              "Lobby" !== t &&
              this.largeAreaAnimationsEnabled &&
              (this.champSelectVideoCache.release(),
              y.forEach(
                function (e) {
                  this.champSelectVideoCache.cache(e);
                }.bind(this),
              ));
          }
          _changePhase(e) {
            (this.previousPhase = this.phase),
              (this.phase = e),
              e &&
                "None" !== e &&
                (this._perksPreloaded ||
                  ((this._perksPreloaded = !0),
                  (0, a.usePerksApi)((e) => e.preload()))),
              "Lobby" === e && this.preload(),
              "ChampSelect" === e && "ChampSelect" !== this.previousPhase
                ? this.show()
                : "ChampSelect" !== e &&
                  "ChampSelect" === this.previousPhase &&
                  this.hide(),
              this._handleVideoCache(e, this.previousPhase),
              !this.previousPhase ||
                (e && "None" !== e) ||
                this.champSelectVideoCache.release();
          }
          champSelectShowHandler() {
            return (
              (this.showPromise = this.showPromise
                .then(
                  function () {
                    return (
                      b.startTracingEvent("champ-select-init"),
                      this.preload(),
                      this.applicationDataPromise
                    );
                  }.bind(this),
                )
                .then(function (e) {
                  return e.emberAppInstancePromise;
                })
                .then(function (e) {
                  return S.afterRender(e.app);
                })
                .then(
                  function () {
                    this._isClashGame
                      ? this.appControls.addMessage(this._clashDodgeMessage)
                      : this._isCustomGame ||
                        this.appControls.addMessage(this._dodgeMessage),
                      this.screenRoot.bump(),
                      (this._isShown = !0),
                      b.endTracingEvent("champ-select-init"),
                      Promise.all([
                        this.gameflowBinding.get("/v1/session"),
                        this.champSelectBinding.get("/v1/session"),
                        h("/lol-summoner/v1/current-summoner").get(),
                        h("/lol-inventory/v2/inventory/WARD_SKIN").get(),
                        h("/lol-inventory/v2/inventory/CHAMPION").get(),
                      ]).then(([e, t, n, i, o]) => {
                        b.recordTracingStepEvent("UI_entered-champ-select");
                        if (!this.previousPhase) return;
                        const {
                            totalTimeInPhase: a,
                            phase: r,
                            adjustedTimeLeftInPhase: c,
                            internalNowInEpochMs: u,
                          } = t.timer,
                          {
                            isRanked: m,
                            id: d,
                            category: p,
                          } = e.gameData.queue,
                          h = m && r !== l.TIMER_PHASES.planning,
                          g = c - (Date.now() - u),
                          f = c - g >= 0.2 * c,
                          { accountId: S, puuid: y, summonerId: _ } = n,
                          v = Array.isArray(i) ? i.length : 0,
                          x = Array.isArray(o)
                            ? o.filter((e) => e.owned).length
                            : 0,
                          k = JSON.stringify({
                            internalNowInEpochMs: u,
                            timeRemainingForPlayerInMS: g,
                            accountId: S,
                            puuid: y,
                            summonerId: _,
                            totalTimeInPhase: a,
                            phase: r,
                            queueId: d,
                            queueCategory: p,
                            adjustedTimeLeftInPhase: c,
                            isRanked: m,
                            previousPhase: this.previousPhase,
                            numOfOwnedWardSkins: v,
                            numOfOwnedChamps: x,
                          });
                        "GAME_STARTING" === r
                          ? (b.recordTracingStepEvent(
                              "UI_entered-champ-select-in-phase-game-starting",
                            ),
                            b.invokeWithLowProbability(function () {
                              s.captureEvent({
                                message:
                                  "entered-champ-select-in-phase-game-starting",
                              }),
                                b.sendEvent(
                                  "entered-champ-select-in-phase-game-starting",
                                  k,
                                ),
                                b.recordNonTimingTracingEvent(
                                  "entered-champ-select-in-phase-game-starting",
                                  1,
                                  "event",
                                );
                            }))
                          : "" === r
                            ? (b.recordTracingStepEvent(
                                "UI_entered-champ-select-in-phase-empty-string",
                              ),
                              b.invokeWithLowProbability(function () {
                                s.captureEvent({
                                  message:
                                    "entered-champ-select-in-phase-empty-string",
                                }),
                                  b.sendEvent(
                                    "entered-champ-select-in-phase-empty-string",
                                    k,
                                  ),
                                  b.recordNonTimingTracingEvent(
                                    "entered-champ-select-in-phase-empty-string",
                                    1,
                                    "event",
                                  );
                              }))
                            : h
                              ? (b.recordTracingStepEvent(
                                  "UI_entered-ranked-champ-select-after-initial-phase",
                                ),
                                b.invokeWithLowProbability(function () {
                                  s.captureEvent({
                                    message:
                                      "entered-ranked-champ-select-after-initial-phase",
                                  }),
                                    b.sendEvent(
                                      "entered-ranked-champ-select-after-initial-phase",
                                      k,
                                    ),
                                    b.recordNonTimingTracingEvent(
                                      "entered-ranked-champ-select-after-initial-phase",
                                      1,
                                      "event",
                                    );
                                }))
                              : f &&
                                (b.recordTracingStepEvent(
                                  "UI_entered-champ-select-late",
                                ),
                                b.invokeWithLowProbability(function () {
                                  s.captureEvent({
                                    message: "entered-champ-select-late",
                                  }),
                                    b.sendEvent("entered-champ-select-late", k),
                                    b.recordNonTimingTracingEvent(
                                      "entered-champ-select-late",
                                      1,
                                      "event",
                                    );
                                }));
                      });
                  }.bind(this),
                )),
              !0
            );
          }
          champSelectHideHandler() {
            return (this.showPromise = this.showPromise.then(() => {
              if (this._isShown)
                return (
                  this._isClashGame
                    ? this.appControls.removeMessage(this._clashDodgeMessage)
                    : this._isCustomGame ||
                      this.appControls.removeMessage(this._dodgeMessage),
                  this.screenRoot.release({ animate: !1 }).then(() => {
                    this._isShown = !1;
                  })
                );
            }));
          }
          show() {
            for (let e = this.champSelectHandlers.length - 1; e >= 0; e--) {
              if (
                this.champSelectHandlers[e].shouldShow(this._champSelectSession)
              ) {
                this.champSelectHandlers[e].show();
                break;
              }
            }
          }
          preload() {
            if (this.applicationDataPromise) return;
            const e = this.screenRoot.getElement(),
              t = (0, c.default)(e);
            (this.applicationDataPromise = Promise.resolve().then(function () {
              return t;
            })),
              h("/lol-summoner/v1/current-summoner").get(),
              h("/lol-inventory/v2/inventory/WARD_SKIN").get(),
              h("/lol-inventory/v2/inventory/CHAMPION").get();
            const n = t.renderPromise;
            d.getProvider()
              .get("rcp-fe-lol-lock-and-load")
              .lockAndLoad({
                promise: n,
                lockName: "rcp-fe-lol-champ-select:preload",
              });
          }
          hide() {
            for (let e = this.champSelectHandlers.length - 1; e >= 0; e--)
              this.champSelectHandlers[e].hide();
          }
          addEventListener(e, t) {
            this.screenRoot.on(e, t);
          }
          removeEventListener(e, t) {
            this.screenRoot.off(e, t);
          }
          unload() {
            this.applicationDataPromise &&
              (this.applicationDataPromise.then(
                function (e) {
                  this.screenRoot.getElement().removeChild(e.domNode),
                    Promise.all([
                      e.emberAppInstancePromise,
                      e.renderPromise,
                    ]).then(
                      function (e) {
                        e[0].app.destroy(),
                          (this.applicationDataPromise = void 0),
                          i.default.dispose();
                      }.bind(this),
                    );
                }.bind(this),
              ),
              g.removeObserver(this.uxSettingsObserver));
          }
          getElementSelector(e) {
            const t = ".champion-select ";
            switch (f.isString(e) ? e : e.name) {
              case "champion":
                return t + '.grid-champion[data-id="' + e.championId + '"]';
              case "champion-grid":
                return t + "lol-uikit-scrollable.champions";
              case "chat":
                return t + ".pregame-chat-box";
              case "configuration":
                return t + ".champion-config-container";
              case "lock-in":
                return t + ".lock-in";
              case "pick-phase":
                return t + ".pick-phase";
              case "main-container":
                return t + ".champion-select-main-container";
              case "skin-carousel":
                return t + ".skin-selection-carousel-container";
              case "summoner-party-array":
                return t + ".summoner-array.your-party .party";
              case "summoner-spell-container":
                return t + ".summoner-spell-container";
              case "timer-number":
                return t + ".timer";
            }
          }
          registerReplacementChampSelectHandler(e, t, n) {
            this.champSelectHandlers.push({ shouldShow: e, show: t, hide: n });
          }
          getElement(e) {
            return this.screenRoot
              .getElement()
              .querySelector(this.getElementSelector(e));
          }
          _isVisible() {
            return this._isShown;
          }
        })();
        t.default = _;
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            Breadcrumbs: () => M.Breadcrumbs,
            BrowserClient: () => C.BrowserClient,
            BrowserProfilingIntegration: () => Y.BrowserProfilingIntegration,
            BrowserTracing: () => W.BrowserTracing,
            Dedupe: () => O.Dedupe,
            Feedback: () => G.Feedback,
            FunctionToString: () => i.FunctionToString,
            GlobalHandlers: () => N.GlobalHandlers,
            HttpContext: () => L.HttpContext,
            Hub: () => o.Hub,
            InboundFilters: () => a.InboundFilters,
            Integrations: () => J,
            LinkedErrors: () => B.LinkedErrors,
            ModuleMetadata: () => r.ModuleMetadata,
            Replay: () => H.Replay,
            ReplayCanvas: () => j.ReplayCanvas,
            SDK_VERSION: () => l.SDK_VERSION,
            SEMANTIC_ATTRIBUTE_SENTRY_OP: () => c.SEMANTIC_ATTRIBUTE_SENTRY_OP,
            SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN: () =>
              c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
            SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE: () =>
              c.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
            SEMANTIC_ATTRIBUTE_SENTRY_SOURCE: () =>
              c.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
            Scope: () => u.Scope,
            TryCatch: () => U.TryCatch,
            WINDOW: () => T.WINDOW,
            addBreadcrumb: () => m.addBreadcrumb,
            addEventProcessor: () => d.addEventProcessor,
            addGlobalEventProcessor: () => p.addGlobalEventProcessor,
            addIntegration: () => h.addIntegration,
            addTracingExtensions: () => g.addTracingExtensions,
            breadcrumbsIntegration: () => M.breadcrumbsIntegration,
            browserApiErrorsIntegration: () => U.browserApiErrorsIntegration,
            browserProfilingIntegration: () => Y.browserProfilingIntegration,
            browserTracingIntegration: () => q.browserTracingIntegration,
            captureEvent: () => m.captureEvent,
            captureException: () => m.captureException,
            captureMessage: () => m.captureMessage,
            captureSession: () => m.captureSession,
            captureUserFeedback: () => D.captureUserFeedback,
            chromeStackLineParser: () => A.chromeStackLineParser,
            close: () => m.close,
            configureScope: () => m.configureScope,
            continueTrace: () => f.continueTrace,
            createTransport: () => S.createTransport,
            createUserFeedbackEnvelope: () => R.createUserFeedbackEnvelope,
            dedupeIntegration: () => O.dedupeIntegration,
            defaultIntegrations: () => D.defaultIntegrations,
            defaultRequestInstrumentationOptions: () =>
              $.defaultRequestInstrumentationOptions,
            defaultStackLineParsers: () => A.defaultStackLineParsers,
            defaultStackParser: () => A.defaultStackParser,
            endSession: () => m.endSession,
            eventFromException: () => P.eventFromException,
            eventFromMessage: () => P.eventFromMessage,
            exceptionFromError: () => P.exceptionFromError,
            extractTraceparentData: () => b.extractTraceparentData,
            feedbackIntegration: () => G.feedbackIntegration,
            flush: () => m.flush,
            forceLoad: () => D.forceLoad,
            functionToStringIntegration: () => i.functionToStringIntegration,
            geckoStackLineParser: () => A.geckoStackLineParser,
            getActiveSpan: () => f.getActiveSpan,
            getActiveTransaction: () => b.getActiveTransaction,
            getClient: () => m.getClient,
            getCurrentHub: () => o.getCurrentHub,
            getCurrentScope: () => m.getCurrentScope,
            getDefaultIntegrations: () => D.getDefaultIntegrations,
            getHubFromCarrier: () => o.getHubFromCarrier,
            getReplay: () => H.getReplay,
            getSpanStatusFromHttpCode: () => y.getSpanStatusFromHttpCode,
            globalHandlersIntegration: () => N.globalHandlersIntegration,
            httpContextIntegration: () => L.httpContextIntegration,
            inboundFiltersIntegration: () => a.inboundFiltersIntegration,
            init: () => D.init,
            instrumentOutgoingRequests: () => $.instrumentOutgoingRequests,
            isInitialized: () => m.isInitialized,
            lastEventId: () => m.lastEventId,
            linkedErrorsIntegration: () => B.linkedErrorsIntegration,
            makeBrowserOfflineTransport: () => V.makeBrowserOfflineTransport,
            makeFetchTransport: () => w.makeFetchTransport,
            makeMain: () => o.makeMain,
            makeMultiplexedTransport: () => _.makeMultiplexedTransport,
            makeXHRTransport: () => I.makeXHRTransport,
            metrics: () => v.metrics,
            moduleMetadataIntegration: () => r.moduleMetadataIntegration,
            onLoad: () => D.onLoad,
            onProfilingStartRouteTransaction: () =>
              z.onProfilingStartRouteTransaction,
            opera10StackLineParser: () => A.opera10StackLineParser,
            opera11StackLineParser: () => A.opera11StackLineParser,
            parameterize: () => x.parameterize,
            replayCanvasIntegration: () => j.replayCanvasIntegration,
            replayIntegration: () => H.replayIntegration,
            sendFeedback: () => G.sendFeedback,
            setContext: () => m.setContext,
            setCurrentClient: () => k.setCurrentClient,
            setExtra: () => m.setExtra,
            setExtras: () => m.setExtras,
            setHttpStatus: () => y.setHttpStatus,
            setMeasurement: () => E.setMeasurement,
            setTag: () => m.setTag,
            setTags: () => m.setTags,
            setUser: () => m.setUser,
            showReportDialog: () => D.showReportDialog,
            spanStatusfromHttpCode: () => y.spanStatusfromHttpCode,
            startBrowserTracingNavigationSpan: () =>
              q.startBrowserTracingNavigationSpan,
            startBrowserTracingPageLoadSpan: () =>
              q.startBrowserTracingPageLoadSpan,
            startInactiveSpan: () => f.startInactiveSpan,
            startSession: () => m.startSession,
            startSpan: () => f.startSpan,
            startSpanManual: () => f.startSpanManual,
            startTransaction: () => m.startTransaction,
            trace: () => f.trace,
            winjsStackLineParser: () => A.winjsStackLineParser,
            withIsolationScope: () => m.withIsolationScope,
            withScope: () => m.withScope,
            wrap: () => D.wrap,
          });
        var s = n(138),
          i = n(4),
          o = n(13),
          a = n(35),
          r = n(36),
          l = n(14),
          c = n(40),
          u = n(15),
          m = n(12),
          d = n(41),
          p = n(26),
          h = n(34),
          g = n(48),
          f = n(53),
          S = n(64),
          b = n(62),
          y = n(51),
          _ = n(67),
          v = n(68),
          x = n(72),
          k = n(73),
          E = n(74),
          T = n(75),
          C = n(76),
          w = n(83),
          I = n(86),
          A = n(87),
          P = n(79),
          R = n(81),
          D = n(88),
          M = n(90),
          O = n(101),
          N = n(98),
          L = n(102),
          B = n(99),
          U = n(89),
          F = n(149),
          H = n(103),
          j = n(123),
          G = n(124),
          W = n(125),
          q = n(132),
          $ = n(127),
          V = n(133),
          z = n(135),
          Y = n(137);
        let K = {};
        T.WINDOW.Sentry &&
          T.WINDOW.Sentry.Integrations &&
          (K = T.WINDOW.Sentry.Integrations);
        const J = { ...K, ...s.Integrations, ...F };
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            FunctionToString: () => u,
            functionToStringIntegration: () => c,
          });
        var s = n(5),
          i = n(12),
          o = n(34);
        let a;
        const r = "FunctionToString",
          l = new WeakMap(),
          c = (0, o.defineIntegration)(() => ({
            name: r,
            setupOnce() {
              a = Function.prototype.toString;
              try {
                Function.prototype.toString = function (...e) {
                  const t = (0, s.getOriginalFunction)(this),
                    n = l.has((0, i.getClient)()) && void 0 !== t ? t : this;
                  return a.apply(n, e);
                };
              } catch (e) {}
            },
            setup(e) {
              l.set(e, !0);
            },
          })),
          u = (0, o.convertIntegrationFnToClass)(r, c);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addNonEnumerableProperty: () => c,
            convertToPlainObject: () => p,
            dropUndefinedKeys: () => S,
            extractExceptionKeysForMessage: () => f,
            fill: () => l,
            getOriginalFunction: () => m,
            markFunctionWrapped: () => u,
            objectify: () => y,
            urlEncode: () => d,
          });
        var s = n(10),
          i = n(6),
          o = n(9),
          a = n(7),
          r = n(11);
        function l(e, t, n) {
          if (!(t in e)) return;
          const s = e[t],
            i = n(s);
          "function" == typeof i && u(i, s), (e[t] = i);
        }
        function c(e, t, n) {
          try {
            Object.defineProperty(e, t, {
              value: n,
              writable: !0,
              configurable: !0,
            });
          } catch (n) {
            i.DEBUG_BUILD &&
              a.logger.log(
                `Failed to add non-enumerable property "${t}" to object`,
                e,
              );
          }
        }
        function u(e, t) {
          try {
            const n = t.prototype || {};
            (e.prototype = t.prototype = n), c(e, "__sentry_original__", t);
          } catch (e) {}
        }
        function m(e) {
          return e.__sentry_original__;
        }
        function d(e) {
          return Object.keys(e)
            .map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`)
            .join("&");
        }
        function p(e) {
          if ((0, o.isError)(e))
            return {
              message: e.message,
              name: e.name,
              stack: e.stack,
              ...g(e),
            };
          if ((0, o.isEvent)(e)) {
            const t = {
              type: e.type,
              target: h(e.target),
              currentTarget: h(e.currentTarget),
              ...g(e),
            };
            return (
              "undefined" != typeof CustomEvent &&
                (0, o.isInstanceOf)(e, CustomEvent) &&
                (t.detail = e.detail),
              t
            );
          }
          return e;
        }
        function h(e) {
          try {
            return (0, o.isElement)(e)
              ? (0, s.htmlTreeAsString)(e)
              : Object.prototype.toString.call(e);
          } catch (e) {
            return "<unknown>";
          }
        }
        function g(e) {
          if ("object" == typeof e && null !== e) {
            const t = {};
            for (const n in e)
              Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t;
          }
          return {};
        }
        function f(e, t = 40) {
          const n = Object.keys(p(e));
          if ((n.sort(), !n.length)) return "[object has no keys]";
          if (n[0].length >= t) return (0, r.truncate)(n[0], t);
          for (let e = n.length; e > 0; e--) {
            const s = n.slice(0, e).join(", ");
            if (!(s.length > t))
              return e === n.length ? s : (0, r.truncate)(s, t);
          }
          return "";
        }
        function S(e) {
          return b(e, new Map());
        }
        function b(e, t) {
          if (
            (function (e) {
              if (!(0, o.isPlainObject)(e)) return !1;
              try {
                const t = Object.getPrototypeOf(e).constructor.name;
                return !t || "Object" === t;
              } catch (e) {
                return !0;
              }
            })(e)
          ) {
            const n = t.get(e);
            if (void 0 !== n) return n;
            const s = {};
            t.set(e, s);
            for (const n of Object.keys(e))
              void 0 !== e[n] && (s[n] = b(e[n], t));
            return s;
          }
          if (Array.isArray(e)) {
            const n = t.get(e);
            if (void 0 !== n) return n;
            const s = [];
            return (
              t.set(e, s),
              e.forEach((e) => {
                s.push(b(e, t));
              }),
              s
            );
          }
          return e;
        }
        function y(e) {
          let t;
          switch (!0) {
            case null == e:
              t = new String(e);
              break;
            case "symbol" == typeof e || "bigint" == typeof e:
              t = Object(e);
              break;
            case (0, o.isPrimitive)(e):
              t = new e.constructor(e);
              break;
            default:
              t = e;
          }
          return t;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { DEBUG_BUILD: () => s });
        const s = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            CONSOLE_LEVELS: () => o,
            consoleSandbox: () => r,
            logger: () => l,
            originalConsoleMethods: () => a,
          });
        var s = n(6),
          i = n(8);
        const o = ["debug", "info", "warn", "error", "log", "assert", "trace"],
          a = {};
        function r(e) {
          if (!("console" in i.GLOBAL_OBJ)) return e();
          const t = i.GLOBAL_OBJ.console,
            n = {},
            s = Object.keys(a);
          s.forEach((e) => {
            const s = a[e];
            (n[e] = t[e]), (t[e] = s);
          });
          try {
            return e();
          } finally {
            s.forEach((e) => {
              t[e] = n[e];
            });
          }
        }
        const l = (function () {
          let e = !1;
          const t = {
            enable: () => {
              e = !0;
            },
            disable: () => {
              e = !1;
            },
            isEnabled: () => e,
          };
          return (
            s.DEBUG_BUILD
              ? o.forEach((n) => {
                  t[n] = (...t) => {
                    e &&
                      r(() => {
                        i.GLOBAL_OBJ.console[n](`Sentry Logger [${n}]:`, ...t);
                      });
                  };
                })
              : o.forEach((e) => {
                  t[e] = () => {};
                }),
            t
          );
        })();
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          return e && e.Math == Math ? e : void 0;
        }
        n.r(t),
          n.d(t, {
            GLOBAL_OBJ: () => i,
            getGlobalObject: () => o,
            getGlobalSingleton: () => a,
          });
        const i =
          ("object" == typeof globalThis && s(globalThis)) ||
          ("object" == typeof window && s(window)) ||
          ("object" == typeof self && s(self)) ||
          ("object" == typeof n.g && s(n.g)) ||
          (function () {
            return this;
          })() ||
          {};
        function o() {
          return i;
        }
        function a(e, t, n) {
          const s = n || i,
            o = (s.__SENTRY__ = s.__SENTRY__ || {});
          return o[e] || (o[e] = t());
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            isDOMError: () => r,
            isDOMException: () => l,
            isElement: () => h,
            isError: () => i,
            isErrorEvent: () => a,
            isEvent: () => p,
            isInstanceOf: () => y,
            isNaN: () => b,
            isParameterizedString: () => u,
            isPlainObject: () => d,
            isPrimitive: () => m,
            isRegExp: () => g,
            isString: () => c,
            isSyntheticEvent: () => S,
            isThenable: () => f,
            isVueViewModel: () => _,
          });
        const s = Object.prototype.toString;
        function i(e) {
          switch (s.call(e)) {
            case "[object Error]":
            case "[object Exception]":
            case "[object DOMException]":
              return !0;
            default:
              return y(e, Error);
          }
        }
        function o(e, t) {
          return s.call(e) === `[object ${t}]`;
        }
        function a(e) {
          return o(e, "ErrorEvent");
        }
        function r(e) {
          return o(e, "DOMError");
        }
        function l(e) {
          return o(e, "DOMException");
        }
        function c(e) {
          return o(e, "String");
        }
        function u(e) {
          return (
            "object" == typeof e &&
            null !== e &&
            "__sentry_template_string__" in e &&
            "__sentry_template_values__" in e
          );
        }
        function m(e) {
          return (
            null === e ||
            u(e) ||
            ("object" != typeof e && "function" != typeof e)
          );
        }
        function d(e) {
          return o(e, "Object");
        }
        function p(e) {
          return "undefined" != typeof Event && y(e, Event);
        }
        function h(e) {
          return "undefined" != typeof Element && y(e, Element);
        }
        function g(e) {
          return o(e, "RegExp");
        }
        function f(e) {
          return Boolean(e && e.then && "function" == typeof e.then);
        }
        function S(e) {
          return (
            d(e) &&
            "nativeEvent" in e &&
            "preventDefault" in e &&
            "stopPropagation" in e
          );
        }
        function b(e) {
          return "number" == typeof e && e != e;
        }
        function y(e, t) {
          try {
            return e instanceof t;
          } catch (e) {
            return !1;
          }
        }
        function _(e) {
          return !(
            "object" != typeof e ||
            null === e ||
            (!e.__isVue && !e._isVue)
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            getComponentName: () => u,
            getDomElement: () => c,
            getLocationHref: () => l,
            htmlTreeAsString: () => a,
          });
        var s = n(9);
        const i = (0, n(8).getGlobalObject)(),
          o = 80;
        function a(e, t = {}) {
          if (!e) return "<unknown>";
          try {
            let n = e;
            const s = 5,
              i = [];
            let a = 0,
              l = 0;
            const c = " > ",
              u = c.length;
            let m;
            const d = Array.isArray(t) ? t : t.keyAttrs,
              p = (!Array.isArray(t) && t.maxStringLength) || o;
            for (
              ;
              n &&
              a++ < s &&
              ((m = r(n, d)),
              !("html" === m || (a > 1 && l + i.length * u + m.length >= p)));

            )
              i.push(m), (l += m.length), (n = n.parentNode);
            return i.reverse().join(c);
          } catch (e) {
            return "<unknown>";
          }
        }
        function r(e, t) {
          const n = e,
            o = [];
          let a, r, l, c, u;
          if (!n || !n.tagName) return "";
          if (
            i.HTMLElement &&
            n instanceof HTMLElement &&
            n.dataset &&
            n.dataset.sentryComponent
          )
            return n.dataset.sentryComponent;
          o.push(n.tagName.toLowerCase());
          const m =
            t && t.length
              ? t
                  .filter((e) => n.getAttribute(e))
                  .map((e) => [e, n.getAttribute(e)])
              : null;
          if (m && m.length)
            m.forEach((e) => {
              o.push(`[${e[0]}="${e[1]}"]`);
            });
          else if (
            (n.id && o.push(`#${n.id}`),
            (a = n.className),
            a && (0, s.isString)(a))
          )
            for (r = a.split(/\s+/), u = 0; u < r.length; u++)
              o.push(`.${r[u]}`);
          const d = ["aria-label", "type", "name", "title", "alt"];
          for (u = 0; u < d.length; u++)
            (l = d[u]), (c = n.getAttribute(l)), c && o.push(`[${l}="${c}"]`);
          return o.join("");
        }
        function l() {
          try {
            return i.document.location.href;
          } catch (e) {
            return "";
          }
        }
        function c(e) {
          return i.document && i.document.querySelector
            ? i.document.querySelector(e)
            : null;
        }
        function u(e) {
          if (!i.HTMLElement) return null;
          let t = e;
          for (let e = 0; e < 5; e++) {
            if (!t) return null;
            if (t instanceof HTMLElement && t.dataset.sentryComponent)
              return t.dataset.sentryComponent;
            t = t.parentNode;
          }
          return null;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            isMatchingPattern: () => r,
            safeJoin: () => a,
            snipLine: () => o,
            stringMatchesSomePattern: () => l,
            truncate: () => i,
          });
        var s = n(9);
        function i(e, t = 0) {
          return "string" != typeof e || 0 === t || e.length <= t
            ? e
            : `${e.slice(0, t)}...`;
        }
        function o(e, t) {
          let n = e;
          const s = n.length;
          if (s <= 150) return n;
          t > s && (t = s);
          let i = Math.max(t - 60, 0);
          i < 5 && (i = 0);
          let o = Math.min(i + 140, s);
          return (
            o > s - 5 && (o = s),
            o === s && (i = Math.max(o - 140, 0)),
            (n = n.slice(i, o)),
            i > 0 && (n = `'{snip} ${n}`),
            o < s && (n += " {snip}"),
            n
          );
        }
        function a(e, t) {
          if (!Array.isArray(e)) return "";
          const n = [];
          for (let t = 0; t < e.length; t++) {
            const i = e[t];
            try {
              (0, s.isVueViewModel)(i)
                ? n.push("[VueViewModel]")
                : n.push(String(i));
            } catch (e) {
              n.push("[value cannot be serialized]");
            }
          }
          return n.join(t);
        }
        function r(e, t, n = !1) {
          return (
            !!(0, s.isString)(e) &&
            ((0, s.isRegExp)(t)
              ? t.test(e)
              : !!(0, s.isString)(t) && (n ? e === t : e.includes(t)))
          );
        }
        function l(e, t = [], n = !1) {
          return t.some((t) => r(e, t, n));
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addBreadcrumb: () => S,
            captureCheckIn: () => I,
            captureEvent: () => g,
            captureException: () => p,
            captureMessage: () => h,
            captureSession: () => F,
            close: () => R,
            configureScope: () => f,
            endSession: () => B,
            flush: () => P,
            getClient: () => M,
            getCurrentScope: () => N,
            isInitialized: () => O,
            lastEventId: () => D,
            setContext: () => b,
            setExtra: () => _,
            setExtras: () => y,
            setTag: () => x,
            setTags: () => v,
            setUser: () => k,
            startSession: () => L,
            startTransaction: () => w,
            withActiveSpan: () => C,
            withIsolationScope: () => T,
            withMonitor: () => A,
            withScope: () => E,
          });
        var s = n(7),
          i = n(18),
          o = n(17),
          a = n(9),
          r = n(8),
          l = n(25),
          c = n(28),
          u = n(13),
          m = n(16),
          d = n(29);
        function p(e, t) {
          return (0, u.getCurrentHub)().captureException(
            e,
            (0, d.parseEventHintOrCaptureContext)(t),
          );
        }
        function h(e, t) {
          const n = "string" == typeof t ? t : void 0,
            s = "string" != typeof t ? { captureContext: t } : void 0;
          return (0, u.getCurrentHub)().captureMessage(e, n, s);
        }
        function g(e, t) {
          return (0, u.getCurrentHub)().captureEvent(e, t);
        }
        function f(e) {
          (0, u.getCurrentHub)().configureScope(e);
        }
        function S(e, t) {
          (0, u.getCurrentHub)().addBreadcrumb(e, t);
        }
        function b(e, t) {
          (0, u.getCurrentHub)().setContext(e, t);
        }
        function y(e) {
          (0, u.getCurrentHub)().setExtras(e);
        }
        function _(e, t) {
          (0, u.getCurrentHub)().setExtra(e, t);
        }
        function v(e) {
          (0, u.getCurrentHub)().setTags(e);
        }
        function x(e, t) {
          (0, u.getCurrentHub)().setTag(e, t);
        }
        function k(e) {
          (0, u.getCurrentHub)().setUser(e);
        }
        function E(...e) {
          const t = (0, u.getCurrentHub)();
          if (2 === e.length) {
            const [n, s] = e;
            return n
              ? t.withScope(() => ((t.getStackTop().scope = n), s(n)))
              : t.withScope(s);
          }
          return t.withScope(e[0]);
        }
        function T(e) {
          return (0, u.runWithAsyncContext)(() =>
            e((0, u.getIsolationScope)()),
          );
        }
        function C(e, t) {
          return E((n) => (n.setSpan(e), t(n)));
        }
        function w(e, t) {
          return (0, u.getCurrentHub)().startTransaction({ ...e }, t);
        }
        function I(e, t) {
          const n = N(),
            o = M();
          if (o) {
            if (o.captureCheckIn) return o.captureCheckIn(e, t, n);
            c.DEBUG_BUILD &&
              s.logger.warn(
                "Cannot capture check-in. Client does not support sending check-ins.",
              );
          } else
            c.DEBUG_BUILD &&
              s.logger.warn("Cannot capture check-in. No client defined.");
          return (0, i.uuid4)();
        }
        function A(e, t, n) {
          const s = I({ monitorSlug: e, status: "in_progress" }, n),
            i = (0, o.timestampInSeconds)();
          function r(t) {
            I({
              monitorSlug: e,
              status: t,
              checkInId: s,
              duration: (0, o.timestampInSeconds)() - i,
            });
          }
          let l;
          try {
            l = t();
          } catch (e) {
            throw (r("error"), e);
          }
          return (
            (0, a.isThenable)(l)
              ? Promise.resolve(l).then(
                  () => {
                    r("ok");
                  },
                  () => {
                    r("error");
                  },
                )
              : r("ok"),
            l
          );
        }
        async function P(e) {
          const t = M();
          return t
            ? t.flush(e)
            : (c.DEBUG_BUILD &&
                s.logger.warn("Cannot flush events. No client defined."),
              Promise.resolve(!1));
        }
        async function R(e) {
          const t = M();
          return t
            ? t.close(e)
            : (c.DEBUG_BUILD &&
                s.logger.warn(
                  "Cannot flush events and disable SDK. No client defined.",
                ),
              Promise.resolve(!1));
        }
        function D() {
          return (0, u.getCurrentHub)().lastEventId();
        }
        function M() {
          return (0, u.getCurrentHub)().getClient();
        }
        function O() {
          return !!M();
        }
        function N() {
          return (0, u.getCurrentHub)().getScope();
        }
        function L(e) {
          const t = M(),
            n = (0, u.getIsolationScope)(),
            s = N(),
            { release: i, environment: o = l.DEFAULT_ENVIRONMENT } =
              (t && t.getOptions()) || {},
            { userAgent: a } = r.GLOBAL_OBJ.navigator || {},
            c = (0, m.makeSession)({
              release: i,
              environment: o,
              user: s.getUser() || n.getUser(),
              ...(a && { userAgent: a }),
              ...e,
            }),
            d = n.getSession();
          return (
            d &&
              "ok" === d.status &&
              (0, m.updateSession)(d, { status: "exited" }),
            B(),
            n.setSession(c),
            s.setSession(c),
            c
          );
        }
        function B() {
          const e = (0, u.getIsolationScope)(),
            t = N(),
            n = t.getSession() || e.getSession();
          n && (0, m.closeSession)(n), U(), e.setSession(), t.setSession();
        }
        function U() {
          const e = (0, u.getIsolationScope)(),
            t = N(),
            n = M(),
            s = t.getSession() || e.getSession();
          s && n && n.captureSession && n.captureSession(s);
        }
        function F(e = !1) {
          e ? B() : U();
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            API_VERSION: () => p,
            Hub: () => g,
            ensureHubOnCarrier: () => v,
            getCurrentHub: () => b,
            getHubFromCarrier: () => T,
            getIsolationScope: () => y,
            getMainCarrier: () => f,
            makeMain: () => S,
            runWithAsyncContext: () => k,
            setAsyncContextStrategy: () => x,
            setHubOnCarrier: () => C,
          });
        var s = n(9),
          i = n(18),
          o = n(17),
          a = n(7),
          r = n(8),
          l = n(25),
          c = n(28),
          u = n(15),
          m = n(16),
          d = n(14);
        const p = parseFloat(d.SDK_VERSION),
          h = 100;
        class g {
          constructor(e, t, n, s = p) {
            let i, o;
            (this._version = s),
              t ? (i = t) : ((i = new u.Scope()), i.setClient(e)),
              n ? (o = n) : ((o = new u.Scope()), o.setClient(e)),
              (this._stack = [{ scope: i }]),
              e && this.bindClient(e),
              (this._isolationScope = o);
          }
          isOlderThan(e) {
            return this._version < e;
          }
          bindClient(e) {
            const t = this.getStackTop();
            (t.client = e),
              t.scope.setClient(e),
              e && e.setupIntegrations && e.setupIntegrations();
          }
          pushScope() {
            const e = this.getScope().clone();
            return (
              this.getStack().push({ client: this.getClient(), scope: e }), e
            );
          }
          popScope() {
            return !(this.getStack().length <= 1) && !!this.getStack().pop();
          }
          withScope(e) {
            const t = this.pushScope();
            let n;
            try {
              n = e(t);
            } catch (e) {
              throw (this.popScope(), e);
            }
            return (0, s.isThenable)(n)
              ? n.then(
                  (e) => (this.popScope(), e),
                  (e) => {
                    throw (this.popScope(), e);
                  },
                )
              : (this.popScope(), n);
          }
          getClient() {
            return this.getStackTop().client;
          }
          getScope() {
            return this.getStackTop().scope;
          }
          getIsolationScope() {
            return this._isolationScope;
          }
          getStack() {
            return this._stack;
          }
          getStackTop() {
            return this._stack[this._stack.length - 1];
          }
          captureException(e, t) {
            const n = (this._lastEventId =
                t && t.event_id ? t.event_id : (0, i.uuid4)()),
              s = new Error("Sentry syntheticException");
            return (
              this.getScope().captureException(e, {
                originalException: e,
                syntheticException: s,
                ...t,
                event_id: n,
              }),
              n
            );
          }
          captureMessage(e, t, n) {
            const s = (this._lastEventId =
                n && n.event_id ? n.event_id : (0, i.uuid4)()),
              o = new Error(e);
            return (
              this.getScope().captureMessage(e, t, {
                originalException: e,
                syntheticException: o,
                ...n,
                event_id: s,
              }),
              s
            );
          }
          captureEvent(e, t) {
            const n = t && t.event_id ? t.event_id : (0, i.uuid4)();
            return (
              e.type || (this._lastEventId = n),
              this.getScope().captureEvent(e, { ...t, event_id: n }),
              n
            );
          }
          lastEventId() {
            return this._lastEventId;
          }
          addBreadcrumb(e, t) {
            const { scope: n, client: s } = this.getStackTop();
            if (!s) return;
            const { beforeBreadcrumb: i = null, maxBreadcrumbs: r = h } =
              (s.getOptions && s.getOptions()) || {};
            if (r <= 0) return;
            const l = { timestamp: (0, o.dateTimestampInSeconds)(), ...e },
              c = i ? (0, a.consoleSandbox)(() => i(l, t)) : l;
            null !== c &&
              (s.emit && s.emit("beforeAddBreadcrumb", c, t),
              n.addBreadcrumb(c, r));
          }
          setUser(e) {
            this.getScope().setUser(e), this.getIsolationScope().setUser(e);
          }
          setTags(e) {
            this.getScope().setTags(e), this.getIsolationScope().setTags(e);
          }
          setExtras(e) {
            this.getScope().setExtras(e), this.getIsolationScope().setExtras(e);
          }
          setTag(e, t) {
            this.getScope().setTag(e, t), this.getIsolationScope().setTag(e, t);
          }
          setExtra(e, t) {
            this.getScope().setExtra(e, t),
              this.getIsolationScope().setExtra(e, t);
          }
          setContext(e, t) {
            this.getScope().setContext(e, t),
              this.getIsolationScope().setContext(e, t);
          }
          configureScope(e) {
            const { scope: t, client: n } = this.getStackTop();
            n && e(t);
          }
          run(e) {
            const t = S(this);
            try {
              e(this);
            } finally {
              S(t);
            }
          }
          getIntegration(e) {
            const t = this.getClient();
            if (!t) return null;
            try {
              return t.getIntegration(e);
            } catch (t) {
              return (
                c.DEBUG_BUILD &&
                  a.logger.warn(
                    `Cannot retrieve integration ${e.id} from the current Hub`,
                  ),
                null
              );
            }
          }
          startTransaction(e, t) {
            const n = this._callExtensionMethod("startTransaction", e, t);
            if (c.DEBUG_BUILD && !n) {
              this.getClient()
                ? a.logger.warn(
                    "Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n",
                  )
                : a.logger.warn(
                    "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'",
                  );
            }
            return n;
          }
          traceHeaders() {
            return this._callExtensionMethod("traceHeaders");
          }
          captureSession(e = !1) {
            if (e) return this.endSession();
            this._sendSessionUpdate();
          }
          endSession() {
            const e = this.getStackTop().scope,
              t = e.getSession();
            t && (0, m.closeSession)(t),
              this._sendSessionUpdate(),
              e.setSession();
          }
          startSession(e) {
            const { scope: t, client: n } = this.getStackTop(),
              { release: s, environment: i = l.DEFAULT_ENVIRONMENT } =
                (n && n.getOptions()) || {},
              { userAgent: o } = r.GLOBAL_OBJ.navigator || {},
              a = (0, m.makeSession)({
                release: s,
                environment: i,
                user: t.getUser(),
                ...(o && { userAgent: o }),
                ...e,
              }),
              c = t.getSession && t.getSession();
            return (
              c &&
                "ok" === c.status &&
                (0, m.updateSession)(c, { status: "exited" }),
              this.endSession(),
              t.setSession(a),
              a
            );
          }
          shouldSendDefaultPii() {
            const e = this.getClient(),
              t = e && e.getOptions();
            return Boolean(t && t.sendDefaultPii);
          }
          _sendSessionUpdate() {
            const { scope: e, client: t } = this.getStackTop(),
              n = e.getSession();
            n && t && t.captureSession && t.captureSession(n);
          }
          _callExtensionMethod(e, ...t) {
            const n = f().__SENTRY__;
            if (n && n.extensions && "function" == typeof n.extensions[e])
              return n.extensions[e].apply(this, t);
            c.DEBUG_BUILD &&
              a.logger.warn(
                `Extension method ${e} couldn't be found, doing nothing.`,
              );
          }
        }
        function f() {
          return (
            (r.GLOBAL_OBJ.__SENTRY__ = r.GLOBAL_OBJ.__SENTRY__ || {
              extensions: {},
              hub: void 0,
            }),
            r.GLOBAL_OBJ
          );
        }
        function S(e) {
          const t = f(),
            n = T(t);
          return C(t, e), n;
        }
        function b() {
          const e = f();
          if (e.__SENTRY__ && e.__SENTRY__.acs) {
            const t = e.__SENTRY__.acs.getCurrentHub();
            if (t) return t;
          }
          return _(e);
        }
        function y() {
          return b().getIsolationScope();
        }
        function _(e = f()) {
          return (E(e) && !T(e).isOlderThan(p)) || C(e, new g()), T(e);
        }
        function v(e, t = _()) {
          if (!E(e) || T(e).isOlderThan(p)) {
            const n = t.getClient(),
              s = t.getScope(),
              i = t.getIsolationScope();
            C(e, new g(n, s.clone(), i.clone()));
          }
        }
        function x(e) {
          const t = f();
          (t.__SENTRY__ = t.__SENTRY__ || {}), (t.__SENTRY__.acs = e);
        }
        function k(e, t = {}) {
          const n = f();
          return n.__SENTRY__ && n.__SENTRY__.acs
            ? n.__SENTRY__.acs.runWithAsyncContext(e, t)
            : e();
        }
        function E(e) {
          return !!(e && e.__SENTRY__ && e.__SENTRY__.hub);
        }
        function T(e) {
          return (0, r.getGlobalSingleton)("hub", () => new g(), e);
        }
        function C(e, t) {
          if (!e) return !1;
          return ((e.__SENTRY__ = e.__SENTRY__ || {}).hub = t), !0;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { SDK_VERSION: () => s });
        const s = "7.102.0";
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            Scope: () => m,
            getGlobalScope: () => d,
            setGlobalScope: () => p,
          });
        var s = n(9),
          i = n(17),
          o = n(18),
          a = n(7),
          r = n(26),
          l = n(16),
          c = n(19);
        let u;
        class m {
          constructor() {
            (this._notifyingListeners = !1),
              (this._scopeListeners = []),
              (this._eventProcessors = []),
              (this._breadcrumbs = []),
              (this._attachments = []),
              (this._user = {}),
              (this._tags = {}),
              (this._extra = {}),
              (this._contexts = {}),
              (this._sdkProcessingMetadata = {}),
              (this._propagationContext = h());
          }
          static clone(e) {
            return e ? e.clone() : new m();
          }
          clone() {
            const e = new m();
            return (
              (e._breadcrumbs = [...this._breadcrumbs]),
              (e._tags = { ...this._tags }),
              (e._extra = { ...this._extra }),
              (e._contexts = { ...this._contexts }),
              (e._user = this._user),
              (e._level = this._level),
              (e._span = this._span),
              (e._session = this._session),
              (e._transactionName = this._transactionName),
              (e._fingerprint = this._fingerprint),
              (e._eventProcessors = [...this._eventProcessors]),
              (e._requestSession = this._requestSession),
              (e._attachments = [...this._attachments]),
              (e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }),
              (e._propagationContext = { ...this._propagationContext }),
              (e._client = this._client),
              e
            );
          }
          setClient(e) {
            this._client = e;
          }
          getClient() {
            return this._client;
          }
          addScopeListener(e) {
            this._scopeListeners.push(e);
          }
          addEventProcessor(e) {
            return this._eventProcessors.push(e), this;
          }
          setUser(e) {
            return (
              (this._user = e || {
                email: void 0,
                id: void 0,
                ip_address: void 0,
                segment: void 0,
                username: void 0,
              }),
              this._session && (0, l.updateSession)(this._session, { user: e }),
              this._notifyScopeListeners(),
              this
            );
          }
          getUser() {
            return this._user;
          }
          getRequestSession() {
            return this._requestSession;
          }
          setRequestSession(e) {
            return (this._requestSession = e), this;
          }
          setTags(e) {
            return (
              (this._tags = { ...this._tags, ...e }),
              this._notifyScopeListeners(),
              this
            );
          }
          setTag(e, t) {
            return (
              (this._tags = { ...this._tags, [e]: t }),
              this._notifyScopeListeners(),
              this
            );
          }
          setExtras(e) {
            return (
              (this._extra = { ...this._extra, ...e }),
              this._notifyScopeListeners(),
              this
            );
          }
          setExtra(e, t) {
            return (
              (this._extra = { ...this._extra, [e]: t }),
              this._notifyScopeListeners(),
              this
            );
          }
          setFingerprint(e) {
            return (this._fingerprint = e), this._notifyScopeListeners(), this;
          }
          setLevel(e) {
            return (this._level = e), this._notifyScopeListeners(), this;
          }
          setTransactionName(e) {
            return (
              (this._transactionName = e), this._notifyScopeListeners(), this
            );
          }
          setContext(e, t) {
            return (
              null === t ? delete this._contexts[e] : (this._contexts[e] = t),
              this._notifyScopeListeners(),
              this
            );
          }
          setSpan(e) {
            return (this._span = e), this._notifyScopeListeners(), this;
          }
          getSpan() {
            return this._span;
          }
          getTransaction() {
            const e = this._span;
            return e && e.transaction;
          }
          setSession(e) {
            return (
              e ? (this._session = e) : delete this._session,
              this._notifyScopeListeners(),
              this
            );
          }
          getSession() {
            return this._session;
          }
          update(e) {
            if (!e) return this;
            const t = "function" == typeof e ? e(this) : e;
            if (t instanceof m) {
              const e = t.getScopeData();
              (this._tags = { ...this._tags, ...e.tags }),
                (this._extra = { ...this._extra, ...e.extra }),
                (this._contexts = { ...this._contexts, ...e.contexts }),
                e.user && Object.keys(e.user).length && (this._user = e.user),
                e.level && (this._level = e.level),
                e.fingerprint.length && (this._fingerprint = e.fingerprint),
                t.getRequestSession() &&
                  (this._requestSession = t.getRequestSession()),
                e.propagationContext &&
                  (this._propagationContext = e.propagationContext);
            } else if ((0, s.isPlainObject)(t)) {
              const t = e;
              (this._tags = { ...this._tags, ...t.tags }),
                (this._extra = { ...this._extra, ...t.extra }),
                (this._contexts = { ...this._contexts, ...t.contexts }),
                t.user && (this._user = t.user),
                t.level && (this._level = t.level),
                t.fingerprint && (this._fingerprint = t.fingerprint),
                t.requestSession && (this._requestSession = t.requestSession),
                t.propagationContext &&
                  (this._propagationContext = t.propagationContext);
            }
            return this;
          }
          clear() {
            return (
              (this._breadcrumbs = []),
              (this._tags = {}),
              (this._extra = {}),
              (this._user = {}),
              (this._contexts = {}),
              (this._level = void 0),
              (this._transactionName = void 0),
              (this._fingerprint = void 0),
              (this._requestSession = void 0),
              (this._span = void 0),
              (this._session = void 0),
              this._notifyScopeListeners(),
              (this._attachments = []),
              (this._propagationContext = h()),
              this
            );
          }
          addBreadcrumb(e, t) {
            const n = "number" == typeof t ? t : 100;
            if (n <= 0) return this;
            const s = { timestamp: (0, i.dateTimestampInSeconds)(), ...e },
              o = this._breadcrumbs;
            return (
              o.push(s),
              (this._breadcrumbs = o.length > n ? o.slice(-n) : o),
              this._notifyScopeListeners(),
              this
            );
          }
          getLastBreadcrumb() {
            return this._breadcrumbs[this._breadcrumbs.length - 1];
          }
          clearBreadcrumbs() {
            return (this._breadcrumbs = []), this._notifyScopeListeners(), this;
          }
          addAttachment(e) {
            return this._attachments.push(e), this;
          }
          getAttachments() {
            return this.getScopeData().attachments;
          }
          clearAttachments() {
            return (this._attachments = []), this;
          }
          getScopeData() {
            const {
              _breadcrumbs: e,
              _attachments: t,
              _contexts: n,
              _tags: s,
              _extra: i,
              _user: o,
              _level: a,
              _fingerprint: r,
              _eventProcessors: l,
              _propagationContext: c,
              _sdkProcessingMetadata: u,
              _transactionName: m,
              _span: d,
            } = this;
            return {
              breadcrumbs: e,
              attachments: t,
              contexts: n,
              tags: s,
              extra: i,
              user: o,
              level: a,
              fingerprint: r || [],
              eventProcessors: l,
              propagationContext: c,
              sdkProcessingMetadata: u,
              transactionName: m,
              span: d,
            };
          }
          applyToEvent(e, t = {}, n = []) {
            (0, c.applyScopeDataToEvent)(e, this.getScopeData());
            const s = [
              ...n,
              ...(0, r.getGlobalEventProcessors)(),
              ...this._eventProcessors,
            ];
            return (0, r.notifyEventProcessors)(s, e, t);
          }
          setSDKProcessingMetadata(e) {
            return (
              (this._sdkProcessingMetadata = {
                ...this._sdkProcessingMetadata,
                ...e,
              }),
              this
            );
          }
          setPropagationContext(e) {
            return (this._propagationContext = e), this;
          }
          getPropagationContext() {
            return this._propagationContext;
          }
          captureException(e, t) {
            const n = t && t.event_id ? t.event_id : (0, o.uuid4)();
            if (!this._client)
              return (
                a.logger.warn(
                  "No client configured on scope - will not capture exception!",
                ),
                n
              );
            const s = new Error("Sentry syntheticException");
            return (
              this._client.captureException(
                e,
                {
                  originalException: e,
                  syntheticException: s,
                  ...t,
                  event_id: n,
                },
                this,
              ),
              n
            );
          }
          captureMessage(e, t, n) {
            const s = n && n.event_id ? n.event_id : (0, o.uuid4)();
            if (!this._client)
              return (
                a.logger.warn(
                  "No client configured on scope - will not capture message!",
                ),
                s
              );
            const i = new Error(e);
            return (
              this._client.captureMessage(
                e,
                t,
                {
                  originalException: e,
                  syntheticException: i,
                  ...n,
                  event_id: s,
                },
                this,
              ),
              s
            );
          }
          captureEvent(e, t) {
            const n = t && t.event_id ? t.event_id : (0, o.uuid4)();
            return this._client
              ? (this._client.captureEvent(e, { ...t, event_id: n }, this), n)
              : (a.logger.warn(
                  "No client configured on scope - will not capture event!",
                ),
                n);
          }
          _notifyScopeListeners() {
            this._notifyingListeners ||
              ((this._notifyingListeners = !0),
              this._scopeListeners.forEach((e) => {
                e(this);
              }),
              (this._notifyingListeners = !1));
          }
        }
        function d() {
          return u || (u = new m()), u;
        }
        function p(e) {
          u = e;
        }
        function h() {
          return {
            traceId: (0, o.uuid4)(),
            spanId: (0, o.uuid4)().substring(16),
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            closeSession: () => l,
            makeSession: () => a,
            updateSession: () => r,
          });
        var s = n(17),
          i = n(18),
          o = n(5);
        function a(e) {
          const t = (0, s.timestampInSeconds)(),
            n = {
              sid: (0, i.uuid4)(),
              init: !0,
              timestamp: t,
              started: t,
              duration: 0,
              status: "ok",
              errors: 0,
              ignoreDuration: !1,
              toJSON: () =>
                (function (e) {
                  return (0, o.dropUndefinedKeys)({
                    sid: `${e.sid}`,
                    init: e.init,
                    started: new Date(1e3 * e.started).toISOString(),
                    timestamp: new Date(1e3 * e.timestamp).toISOString(),
                    status: e.status,
                    errors: e.errors,
                    did:
                      "number" == typeof e.did || "string" == typeof e.did
                        ? `${e.did}`
                        : void 0,
                    duration: e.duration,
                    abnormal_mechanism: e.abnormal_mechanism,
                    attrs: {
                      release: e.release,
                      environment: e.environment,
                      ip_address: e.ipAddress,
                      user_agent: e.userAgent,
                    },
                  });
                })(n),
            };
          return e && r(n, e), n;
        }
        function r(e, t = {}) {
          if (
            (t.user &&
              (!e.ipAddress &&
                t.user.ip_address &&
                (e.ipAddress = t.user.ip_address),
              e.did ||
                t.did ||
                (e.did = t.user.id || t.user.email || t.user.username)),
            (e.timestamp = t.timestamp || (0, s.timestampInSeconds)()),
            t.abnormal_mechanism &&
              (e.abnormal_mechanism = t.abnormal_mechanism),
            t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration),
            t.sid && (e.sid = 32 === t.sid.length ? t.sid : (0, i.uuid4)()),
            void 0 !== t.init && (e.init = t.init),
            !e.did && t.did && (e.did = `${t.did}`),
            "number" == typeof t.started && (e.started = t.started),
            e.ignoreDuration)
          )
            e.duration = void 0;
          else if ("number" == typeof t.duration) e.duration = t.duration;
          else {
            const t = e.timestamp - e.started;
            e.duration = t >= 0 ? t : 0;
          }
          t.release && (e.release = t.release),
            t.environment && (e.environment = t.environment),
            !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress),
            !e.userAgent && t.userAgent && (e.userAgent = t.userAgent),
            "number" == typeof t.errors && (e.errors = t.errors),
            t.status && (e.status = t.status);
        }
        function l(e, t) {
          let n = {};
          t
            ? (n = { status: t })
            : "ok" === e.status && (n = { status: "exited" }),
            r(e, n);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            _browserPerformanceTimeOriginMode: () => l,
            browserPerformanceTimeOrigin: () => c,
            dateTimestampInSeconds: () => o,
            timestampInSeconds: () => a,
            timestampWithMs: () => r,
          });
        var s = n(8);
        const i = 1e3;
        function o() {
          return Date.now() / i;
        }
        const a = (function () {
            const { performance: e } = s.GLOBAL_OBJ;
            if (!e || !e.now) return o;
            const t = Date.now() - e.now(),
              n = null == e.timeOrigin ? t : e.timeOrigin;
            return () => (n + e.now()) / i;
          })(),
          r = a;
        let l;
        const c = (() => {
          const { performance: e } = s.GLOBAL_OBJ;
          if (!e || !e.now) return void (l = "none");
          const t = 36e5,
            n = e.now(),
            i = Date.now(),
            o = e.timeOrigin ? Math.abs(e.timeOrigin + n - i) : t,
            a = o < t,
            r = e.timing && e.timing.navigationStart,
            c = "number" == typeof r ? Math.abs(r + n - i) : t;
          return a || c < t
            ? o <= c
              ? ((l = "timeOrigin"), e.timeOrigin)
              : ((l = "navigationStart"), r)
            : ((l = "dateNow"), i);
        })();
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addContextToFrame: () => p,
            addExceptionMechanism: () => u,
            addExceptionTypeValue: () => c,
            arrayify: () => g,
            checkOrSetAlreadyCaught: () => h,
            getEventDescription: () => l,
            parseSemver: () => d,
            uuid4: () => a,
          });
        var s = n(5),
          i = n(11),
          o = n(8);
        function a() {
          const e = o.GLOBAL_OBJ,
            t = e.crypto || e.msCrypto;
          let n = () => 16 * Math.random();
          try {
            if (t && t.randomUUID) return t.randomUUID().replace(/-/g, "");
            t &&
              t.getRandomValues &&
              (n = () => {
                const e = new Uint8Array(1);
                return t.getRandomValues(e), e[0];
              });
          } catch (e) {}
          return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, (e) =>
            (e ^ ((15 & n()) >> (e / 4))).toString(16),
          );
        }
        function r(e) {
          return e.exception && e.exception.values
            ? e.exception.values[0]
            : void 0;
        }
        function l(e) {
          const { message: t, event_id: n } = e;
          if (t) return t;
          const s = r(e);
          return s
            ? s.type && s.value
              ? `${s.type}: ${s.value}`
              : s.type || s.value || n || "<unknown>"
            : n || "<unknown>";
        }
        function c(e, t, n) {
          const s = (e.exception = e.exception || {}),
            i = (s.values = s.values || []),
            o = (i[0] = i[0] || {});
          o.value || (o.value = t || ""), o.type || (o.type = n || "Error");
        }
        function u(e, t) {
          const n = r(e);
          if (!n) return;
          const s = n.mechanism;
          if (
            ((n.mechanism = { type: "generic", handled: !0, ...s, ...t }),
            t && "data" in t)
          ) {
            const e = { ...(s && s.data), ...t.data };
            n.mechanism.data = e;
          }
        }
        const m =
          /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
        function d(e) {
          const t = e.match(m) || [],
            n = parseInt(t[1], 10),
            s = parseInt(t[2], 10),
            i = parseInt(t[3], 10);
          return {
            buildmetadata: t[5],
            major: isNaN(n) ? void 0 : n,
            minor: isNaN(s) ? void 0 : s,
            patch: isNaN(i) ? void 0 : i,
            prerelease: t[4],
          };
        }
        function p(e, t, n = 5) {
          if (void 0 === t.lineno) return;
          const s = e.length,
            o = Math.max(Math.min(s - 1, t.lineno - 1), 0);
          (t.pre_context = e
            .slice(Math.max(0, o - n), o)
            .map((e) => (0, i.snipLine)(e, 0))),
            (t.context_line = (0, i.snipLine)(
              e[Math.min(s - 1, o)],
              t.colno || 0,
            )),
            (t.post_context = e
              .slice(Math.min(o + 1, s), o + 1 + n)
              .map((e) => (0, i.snipLine)(e, 0)));
        }
        function h(e) {
          if (e && e.__sentry_captured__) return !0;
          try {
            (0, s.addNonEnumerableProperty)(e, "__sentry_captured__", !0);
          } catch (e) {}
          return !1;
        }
        function g(e) {
          return Array.isArray(e) ? e : [e];
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            applyScopeDataToEvent: () => l,
            mergeAndOverwriteScopeData: () => u,
            mergeScopeData: () => c,
          });
        var s = n(5),
          i = n(18),
          o = n(24),
          a = n(23),
          r = n(20);
        function l(e, t) {
          const {
            fingerprint: n,
            span: l,
            breadcrumbs: c,
            sdkProcessingMetadata: u,
          } = t;
          !(function (e, t) {
            const {
                extra: n,
                tags: i,
                user: o,
                contexts: a,
                level: r,
                transactionName: l,
              } = t,
              c = (0, s.dropUndefinedKeys)(n);
            c && Object.keys(c).length && (e.extra = { ...c, ...e.extra });
            const u = (0, s.dropUndefinedKeys)(i);
            u && Object.keys(u).length && (e.tags = { ...u, ...e.tags });
            const m = (0, s.dropUndefinedKeys)(o);
            m && Object.keys(m).length && (e.user = { ...m, ...e.user });
            const d = (0, s.dropUndefinedKeys)(a);
            d &&
              Object.keys(d).length &&
              (e.contexts = { ...d, ...e.contexts });
            r && (e.level = r);
            l && (e.transaction = l);
          })(e, t),
            l &&
              (function (e, t) {
                e.contexts = {
                  trace: (0, r.spanToTraceContext)(t),
                  ...e.contexts,
                };
                const n = (0, a.getRootSpan)(t);
                if (n) {
                  e.sdkProcessingMetadata = {
                    dynamicSamplingContext: (0,
                    o.getDynamicSamplingContextFromSpan)(t),
                    ...e.sdkProcessingMetadata,
                  };
                  const s = (0, r.spanToJSON)(n).description;
                  s && (e.tags = { transaction: s, ...e.tags });
                }
              })(e, l),
            (function (e, t) {
              (e.fingerprint = e.fingerprint
                ? (0, i.arrayify)(e.fingerprint)
                : []),
                t && (e.fingerprint = e.fingerprint.concat(t));
              e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
            })(e, n),
            (function (e, t) {
              const n = [...(e.breadcrumbs || []), ...t];
              e.breadcrumbs = n.length ? n : void 0;
            })(e, c),
            (function (e, t) {
              e.sdkProcessingMetadata = { ...e.sdkProcessingMetadata, ...t };
            })(e, u);
        }
        function c(e, t) {
          const {
            extra: n,
            tags: s,
            user: i,
            contexts: o,
            level: a,
            sdkProcessingMetadata: r,
            breadcrumbs: l,
            fingerprint: c,
            eventProcessors: m,
            attachments: d,
            propagationContext: p,
            transactionName: h,
            span: g,
          } = t;
          u(e, "extra", n),
            u(e, "tags", s),
            u(e, "user", i),
            u(e, "contexts", o),
            u(e, "sdkProcessingMetadata", r),
            a && (e.level = a),
            h && (e.transactionName = h),
            g && (e.span = g),
            l.length && (e.breadcrumbs = [...e.breadcrumbs, ...l]),
            c.length && (e.fingerprint = [...e.fingerprint, ...c]),
            m.length && (e.eventProcessors = [...e.eventProcessors, ...m]),
            d.length && (e.attachments = [...e.attachments, ...d]),
            (e.propagationContext = { ...e.propagationContext, ...p });
        }
        function u(e, t, n) {
          if (n && Object.keys(n).length) {
            e[t] = { ...e[t] };
            for (const s in n)
              Object.prototype.hasOwnProperty.call(n, s) && (e[t][s] = n[s]);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            TRACE_FLAG_NONE: () => a,
            TRACE_FLAG_SAMPLED: () => r,
            spanIsSampled: () => p,
            spanTimeInputToSeconds: () => u,
            spanToJSON: () => d,
            spanToTraceContext: () => l,
            spanToTraceHeader: () => c,
          });
        var s = n(5),
          i = n(21),
          o = n(17);
        const a = 0,
          r = 1;
        function l(e) {
          const { spanId: t, traceId: n } = e.spanContext(),
            {
              data: i,
              op: o,
              parent_span_id: a,
              status: r,
              tags: l,
              origin: c,
            } = d(e);
          return (0, s.dropUndefinedKeys)({
            data: i,
            op: o,
            parent_span_id: a,
            span_id: t,
            status: r,
            tags: l,
            trace_id: n,
            origin: c,
          });
        }
        function c(e) {
          const { traceId: t, spanId: n } = e.spanContext(),
            s = p(e);
          return (0, i.generateSentryTraceHeader)(t, n, s);
        }
        function u(e) {
          return "number" == typeof e
            ? m(e)
            : Array.isArray(e)
              ? e[0] + e[1] / 1e9
              : e instanceof Date
                ? m(e.getTime())
                : (0, o.timestampInSeconds)();
        }
        function m(e) {
          return e > 9999999999 ? e / 1e3 : e;
        }
        function d(e) {
          return (function (e) {
            return "function" == typeof e.getSpanJSON;
          })(e)
            ? e.getSpanJSON()
            : "function" == typeof e.toJSON
              ? e.toJSON()
              : {};
        }
        function p(e) {
          const { traceFlags: t } = e.spanContext();
          return Boolean(t & r);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            TRACEPARENT_REGEXP: () => o,
            extractTraceparentData: () => a,
            generateSentryTraceHeader: () => c,
            propagationContextFromHeaders: () => l,
            tracingContextFromHeaders: () => r,
          });
        var s = n(22),
          i = n(18);
        const o = new RegExp(
          "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$",
        );
        function a(e) {
          if (!e) return;
          const t = e.match(o);
          if (!t) return;
          let n;
          return (
            "1" === t[3] ? (n = !0) : "0" === t[3] && (n = !1),
            { traceId: t[1], parentSampled: n, parentSpanId: t[2] }
          );
        }
        function r(e, t) {
          const n = a(e),
            o = (0, s.baggageHeaderToDynamicSamplingContext)(t),
            { traceId: r, parentSpanId: l, parentSampled: c } = n || {};
          return n
            ? {
                traceparentData: n,
                dynamicSamplingContext: o || {},
                propagationContext: {
                  traceId: r || (0, i.uuid4)(),
                  parentSpanId: l || (0, i.uuid4)().substring(16),
                  spanId: (0, i.uuid4)().substring(16),
                  sampled: c,
                  dsc: o || {},
                },
              }
            : {
                traceparentData: n,
                dynamicSamplingContext: void 0,
                propagationContext: {
                  traceId: r || (0, i.uuid4)(),
                  spanId: (0, i.uuid4)().substring(16),
                },
              };
        }
        function l(e, t) {
          const n = a(e),
            o = (0, s.baggageHeaderToDynamicSamplingContext)(t),
            { traceId: r, parentSpanId: l, parentSampled: c } = n || {};
          return n
            ? {
                traceId: r || (0, i.uuid4)(),
                parentSpanId: l || (0, i.uuid4)().substring(16),
                spanId: (0, i.uuid4)().substring(16),
                sampled: c,
                dsc: o || {},
              }
            : {
                traceId: r || (0, i.uuid4)(),
                spanId: (0, i.uuid4)().substring(16),
              };
        }
        function c(e = (0, i.uuid4)(), t = (0, i.uuid4)().substring(16), n) {
          let s = "";
          return void 0 !== n && (s = n ? "-1" : "-0"), `${e}-${t}${s}`;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            BAGGAGE_HEADER_NAME: () => a,
            MAX_BAGGAGE_STRING_LENGTH: () => c,
            SENTRY_BAGGAGE_KEY_PREFIX: () => r,
            SENTRY_BAGGAGE_KEY_PREFIX_REGEX: () => l,
            baggageHeaderToDynamicSamplingContext: () => u,
            dynamicSamplingContextToSentryBaggageHeader: () => m,
          });
        var s = n(6),
          i = n(9),
          o = n(7);
        const a = "baggage",
          r = "sentry-",
          l = /^sentry-/,
          c = 8192;
        function u(e) {
          if (!(0, i.isString)(e) && !Array.isArray(e)) return;
          let t = {};
          if (Array.isArray(e))
            t = e.reduce((e, t) => {
              const n = d(t);
              for (const t of Object.keys(n)) e[t] = n[t];
              return e;
            }, {});
          else {
            if (!e) return;
            t = d(e);
          }
          const n = Object.entries(t).reduce((e, [t, n]) => {
            if (t.match(l)) {
              e[t.slice(r.length)] = n;
            }
            return e;
          }, {});
          return Object.keys(n).length > 0 ? n : void 0;
        }
        function m(e) {
          if (!e) return;
          return (function (e) {
            if (0 === Object.keys(e).length) return;
            return Object.entries(e).reduce((e, [t, n], i) => {
              const a = `${encodeURIComponent(t)}=${encodeURIComponent(n)}`,
                r = 0 === i ? a : `${e},${a}`;
              return r.length > c
                ? (s.DEBUG_BUILD &&
                    o.logger.warn(
                      `Not adding key: ${t} with val: ${n} to baggage header due to exceeding baggage size limits.`,
                    ),
                  e)
                : r;
            }, "");
          })(
            Object.entries(e).reduce(
              (e, [t, n]) => (n && (e[`${r}${t}`] = n), e),
              {},
            ),
          );
        }
        function d(e) {
          return e
            .split(",")
            .map((e) => e.split("=").map((e) => decodeURIComponent(e.trim())))
            .reduce((e, [t, n]) => ((e[t] = n), e), {});
        }
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          return e.transaction;
        }
        n.r(t), n.d(t, { getRootSpan: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            getDynamicSamplingContextFromClient: () => l,
            getDynamicSamplingContextFromSpan: () => c,
          });
        var s = n(5),
          i = n(25),
          o = n(12),
          a = n(23),
          r = n(20);
        function l(e, t, n) {
          const o = t.getOptions(),
            { publicKey: a } = t.getDsn() || {},
            { segment: r } = (n && n.getUser()) || {},
            l = (0, s.dropUndefinedKeys)({
              environment: o.environment || i.DEFAULT_ENVIRONMENT,
              release: o.release,
              user_segment: r,
              public_key: a,
              trace_id: e,
            });
          return t.emit && t.emit("createDsc", l), l;
        }
        function c(e) {
          const t = (0, o.getClient)();
          if (!t) return {};
          const n = l(
              (0, r.spanToJSON)(e).trace_id || "",
              t,
              (0, o.getCurrentScope)(),
            ),
            s = (0, a.getRootSpan)(e);
          if (!s) return n;
          const i = s && s._frozenDynamicSamplingContext;
          if (i) return i;
          const { sampleRate: c, source: u } = s.metadata;
          null != c && (n.sample_rate = `${c}`);
          const m = (0, r.spanToJSON)(s);
          return (
            u && "url" !== u && (n.transaction = m.description),
            (n.sampled = String((0, r.spanIsSampled)(s))),
            t.emit && t.emit("createDsc", n),
            n
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { DEFAULT_ENVIRONMENT: () => s });
        const s = "production";
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addGlobalEventProcessor: () => c,
            getGlobalEventProcessors: () => l,
            notifyEventProcessors: () => u,
          });
        var s = n(8),
          i = n(27),
          o = n(7),
          a = n(9),
          r = n(28);
        function l() {
          return (0, s.getGlobalSingleton)("globalEventProcessors", () => []);
        }
        function c(e) {
          l().push(e);
        }
        function u(e, t, n, s = 0) {
          return new i.SyncPromise((i, l) => {
            const c = e[s];
            if (null === t || "function" != typeof c) i(t);
            else {
              const m = c({ ...t }, n);
              r.DEBUG_BUILD &&
                c.id &&
                null === m &&
                o.logger.log(`Event processor "${c.id}" dropped event`),
                (0, a.isThenable)(m)
                  ? m.then((t) => u(e, t, n, s + 1).then(i)).then(null, l)
                  : u(e, m, n, s + 1)
                      .then(i)
                      .then(null, l);
            }
          });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            SyncPromise: () => r,
            rejectedSyncPromise: () => a,
            resolvedSyncPromise: () => o,
          });
        var s,
          i = n(9);
        function o(e) {
          return new r((t) => {
            t(e);
          });
        }
        function a(e) {
          return new r((t, n) => {
            n(e);
          });
        }
        !(function (e) {
          e[(e.PENDING = 0)] = "PENDING";
          e[(e.RESOLVED = 1)] = "RESOLVED";
          e[(e.REJECTED = 2)] = "REJECTED";
        })(s || (s = {}));
        class r {
          constructor(e) {
            r.prototype.__init.call(this),
              r.prototype.__init2.call(this),
              r.prototype.__init3.call(this),
              r.prototype.__init4.call(this),
              (this._state = s.PENDING),
              (this._handlers = []);
            try {
              e(this._resolve, this._reject);
            } catch (e) {
              this._reject(e);
            }
          }
          then(e, t) {
            return new r((n, s) => {
              this._handlers.push([
                !1,
                (t) => {
                  if (e)
                    try {
                      n(e(t));
                    } catch (e) {
                      s(e);
                    }
                  else n(t);
                },
                (e) => {
                  if (t)
                    try {
                      n(t(e));
                    } catch (e) {
                      s(e);
                    }
                  else s(e);
                },
              ]),
                this._executeHandlers();
            });
          }
          catch(e) {
            return this.then((e) => e, e);
          }
          finally(e) {
            return new r((t, n) => {
              let s, i;
              return this.then(
                (t) => {
                  (i = !1), (s = t), e && e();
                },
                (t) => {
                  (i = !0), (s = t), e && e();
                },
              ).then(() => {
                i ? n(s) : t(s);
              });
            });
          }
          __init() {
            this._resolve = (e) => {
              this._setResult(s.RESOLVED, e);
            };
          }
          __init2() {
            this._reject = (e) => {
              this._setResult(s.REJECTED, e);
            };
          }
          __init3() {
            this._setResult = (e, t) => {
              this._state === s.PENDING &&
                ((0, i.isThenable)(t)
                  ? t.then(this._resolve, this._reject)
                  : ((this._state = e),
                    (this._value = t),
                    this._executeHandlers()));
            };
          }
          __init4() {
            this._executeHandlers = () => {
              if (this._state === s.PENDING) return;
              const e = this._handlers.slice();
              (this._handlers = []),
                e.forEach((e) => {
                  e[0] ||
                    (this._state === s.RESOLVED && e[1](this._value),
                    this._state === s.REJECTED && e[2](this._value),
                    (e[0] = !0));
                });
            };
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { DEBUG_BUILD: () => s });
        const s = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            applyDebugIds: () => g,
            applyDebugMeta: () => f,
            parseEventHintOrCaptureContext: () => S,
            prepareEvent: () => p,
          });
        var s = n(18),
          i = n(17),
          o = n(11),
          a = n(8),
          r = n(30),
          l = n(25),
          c = n(26),
          u = n(15),
          m = n(19),
          d = n(20);
        function p(e, t, n, a, p, h) {
          const { normalizeDepth: S = 3, normalizeMaxBreadth: b = 1e3 } = e,
            y = {
              ...t,
              event_id: t.event_id || n.event_id || (0, s.uuid4)(),
              timestamp: t.timestamp || (0, i.dateTimestampInSeconds)(),
            },
            _ = n.integrations || e.integrations.map((e) => e.name);
          !(function (e, t) {
            const {
              environment: n,
              release: s,
              dist: i,
              maxValueLength: a = 250,
            } = t;
            "environment" in e ||
              (e.environment = "environment" in t ? n : l.DEFAULT_ENVIRONMENT);
            void 0 === e.release && void 0 !== s && (e.release = s);
            void 0 === e.dist && void 0 !== i && (e.dist = i);
            e.message && (e.message = (0, o.truncate)(e.message, a));
            const r =
              e.exception && e.exception.values && e.exception.values[0];
            r && r.value && (r.value = (0, o.truncate)(r.value, a));
            const c = e.request;
            c && c.url && (c.url = (0, o.truncate)(c.url, a));
          })(y, e),
            (function (e, t) {
              t.length > 0 &&
                ((e.sdk = e.sdk || {}),
                (e.sdk.integrations = [...(e.sdk.integrations || []), ...t]));
            })(y, _),
            void 0 === t.type && g(y, e.stackParser);
          const v = (function (e, t) {
            if (!t) return e;
            const n = e ? e.clone() : new u.Scope();
            return n.update(t), n;
          })(a, n.captureContext);
          n.mechanism && (0, s.addExceptionMechanism)(y, n.mechanism);
          const x = p && p.getEventProcessors ? p.getEventProcessors() : [],
            k = (0, u.getGlobalScope)().getScopeData();
          if (h) {
            const e = h.getScopeData();
            (0, m.mergeScopeData)(k, e);
          }
          if (v) {
            const e = v.getScopeData();
            (0, m.mergeScopeData)(k, e);
          }
          const E = [...(n.attachments || []), ...k.attachments];
          E.length && (n.attachments = E), (0, m.applyScopeDataToEvent)(y, k);
          const T = [
            ...x,
            ...(0, c.getGlobalEventProcessors)(),
            ...k.eventProcessors,
          ];
          return (0, c.notifyEventProcessors)(T, y, n).then(
            (e) => (
              e && f(e),
              "number" == typeof S && S > 0
                ? (function (e, t, n) {
                    if (!e) return null;
                    const s = {
                      ...e,
                      ...(e.breadcrumbs && {
                        breadcrumbs: e.breadcrumbs.map((e) => ({
                          ...e,
                          ...(e.data && {
                            data: (0, r.normalize)(e.data, t, n),
                          }),
                        })),
                      }),
                      ...(e.user && { user: (0, r.normalize)(e.user, t, n) }),
                      ...(e.contexts && {
                        contexts: (0, r.normalize)(e.contexts, t, n),
                      }),
                      ...(e.extra && {
                        extra: (0, r.normalize)(e.extra, t, n),
                      }),
                    };
                    e.contexts &&
                      e.contexts.trace &&
                      s.contexts &&
                      ((s.contexts.trace = e.contexts.trace),
                      e.contexts.trace.data &&
                        (s.contexts.trace.data = (0, r.normalize)(
                          e.contexts.trace.data,
                          t,
                          n,
                        )));
                    e.spans &&
                      (s.spans = e.spans.map((e) => {
                        const s = (0, d.spanToJSON)(e).data;
                        return s && (e.data = (0, r.normalize)(s, t, n)), e;
                      }));
                    return s;
                  })(e, S, b)
                : e
            ),
          );
        }
        const h = new WeakMap();
        function g(e, t) {
          const n = a.GLOBAL_OBJ._sentryDebugIds;
          if (!n) return;
          let s;
          const i = h.get(t);
          i ? (s = i) : ((s = new Map()), h.set(t, s));
          const o = Object.keys(n).reduce((e, i) => {
            let o;
            const a = s.get(i);
            a ? (o = a) : ((o = t(i)), s.set(i, o));
            for (let t = o.length - 1; t >= 0; t--) {
              const s = o[t];
              if (s.filename) {
                e[s.filename] = n[i];
                break;
              }
            }
            return e;
          }, {});
          try {
            e.exception.values.forEach((e) => {
              e.stacktrace.frames.forEach((e) => {
                e.filename && (e.debug_id = o[e.filename]);
              });
            });
          } catch (e) {}
        }
        function f(e) {
          const t = {};
          try {
            e.exception.values.forEach((e) => {
              e.stacktrace.frames.forEach((e) => {
                e.debug_id &&
                  (e.abs_path
                    ? (t[e.abs_path] = e.debug_id)
                    : e.filename && (t[e.filename] = e.debug_id),
                  delete e.debug_id);
              });
            });
          } catch (e) {}
          if (0 === Object.keys(t).length) return;
          (e.debug_meta = e.debug_meta || {}),
            (e.debug_meta.images = e.debug_meta.images || []);
          const n = e.debug_meta.images;
          Object.keys(t).forEach((e) => {
            n.push({ type: "sourcemap", code_file: e, debug_id: t[e] });
          });
        }
        function S(e) {
          if (e)
            return (function (e) {
              return e instanceof u.Scope || "function" == typeof e;
            })(e) ||
              (function (e) {
                return Object.keys(e).some((e) => b.includes(e));
              })(e)
              ? { captureContext: e }
              : e;
        }
        const b = [
          "user",
          "level",
          "extra",
          "contexts",
          "tags",
          "fingerprint",
          "requestSession",
          "propagationContext",
        ];
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            normalize: () => r,
            normalizeToSize: () => l,
            normalizeUrlToBase: () => u,
            walk: () => c,
          });
        var s = n(9),
          i = n(31),
          o = n(5),
          a = n(32);
        function r(e, t = 100, n = 1 / 0) {
          try {
            return c("", e, t, n);
          } catch (e) {
            return { ERROR: `**non-serializable** (${e})` };
          }
        }
        function l(e, t = 3, n = 102400) {
          const s = r(e, t);
          return (
            (i = s),
            (function (e) {
              return ~-encodeURI(e).split(/%..|./).length;
            })(JSON.stringify(i)) > n
              ? l(e, t - 1, n)
              : s
          );
          var i;
        }
        function c(e, t, r = 1 / 0, l = 1 / 0, u = (0, i.memoBuilder)()) {
          const [m, d] = u;
          if (
            null == t ||
            (["number", "boolean", "string"].includes(typeof t) &&
              !(0, s.isNaN)(t))
          )
            return t;
          const p = (function (e, t) {
            try {
              if ("domain" === e && t && "object" == typeof t && t._events)
                return "[Domain]";
              if ("domainEmitter" === e) return "[DomainEmitter]";
              if (void 0 !== n.g && t === n.g) return "[Global]";
              if ("undefined" != typeof window && t === window)
                return "[Window]";
              if ("undefined" != typeof document && t === document)
                return "[Document]";
              if ((0, s.isVueViewModel)(t)) return "[VueViewModel]";
              if ((0, s.isSyntheticEvent)(t)) return "[SyntheticEvent]";
              if ("number" == typeof t && t != t) return "[NaN]";
              if ("function" == typeof t)
                return `[Function: ${(0, a.getFunctionName)(t)}]`;
              if ("symbol" == typeof t) return `[${String(t)}]`;
              if ("bigint" == typeof t) return `[BigInt: ${String(t)}]`;
              const i = (function (e) {
                const t = Object.getPrototypeOf(e);
                return t ? t.constructor.name : "null prototype";
              })(t);
              return /^HTML(\w*)Element$/.test(i)
                ? `[HTMLElement: ${i}]`
                : `[object ${i}]`;
            } catch (e) {
              return `**non-serializable** (${e})`;
            }
          })(e, t);
          if (!p.startsWith("[object ")) return p;
          if (t.__sentry_skip_normalization__) return t;
          const h =
            "number" == typeof t.__sentry_override_normalization_depth__
              ? t.__sentry_override_normalization_depth__
              : r;
          if (0 === h) return p.replace("object ", "");
          if (m(t)) return "[Circular ~]";
          const g = t;
          if (g && "function" == typeof g.toJSON)
            try {
              return c("", g.toJSON(), h - 1, l, u);
            } catch (e) {}
          const f = Array.isArray(t) ? [] : {};
          let S = 0;
          const b = (0, o.convertToPlainObject)(t);
          for (const e in b) {
            if (!Object.prototype.hasOwnProperty.call(b, e)) continue;
            if (S >= l) {
              f[e] = "[MaxProperties ~]";
              break;
            }
            const t = b[e];
            (f[e] = c(e, t, h - 1, l, u)), S++;
          }
          return d(t), f;
        }
        function u(e, t) {
          const n = t
            .replace(/\\/g, "/")
            .replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
          let s = e;
          try {
            s = decodeURI(e);
          } catch (e) {}
          return s
            .replace(/\\/g, "/")
            .replace(/webpack:\/?/g, "")
            .replace(new RegExp(`(file://)?/*${n}/*`, "ig"), "app:///");
        }
      },
      (e, t, n) => {
        "use strict";
        function s() {
          const e = "function" == typeof WeakSet,
            t = e ? new WeakSet() : [];
          return [
            function (n) {
              if (e) return !!t.has(n) || (t.add(n), !1);
              for (let e = 0; e < t.length; e++) {
                if (t[e] === n) return !0;
              }
              return t.push(n), !1;
            },
            function (n) {
              if (e) t.delete(n);
              else
                for (let e = 0; e < t.length; e++)
                  if (t[e] === n) {
                    t.splice(e, 1);
                    break;
                  }
            },
          ];
        }
        n.r(t), n.d(t, { memoBuilder: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            createStackParser: () => r,
            filenameIsInApp: () => s.filenameIsInApp,
            getFunctionName: () => m,
            nodeStackLineParser: () => d,
            stackParserFromStackParserOptions: () => l,
            stripSentryFramesAndReverse: () => c,
          });
        var s = n(33);
        const i = 50,
          o = /\(error: (.*)\)/,
          a = /captureMessage|captureException/;
        function r(...e) {
          const t = e.sort((e, t) => e[0] - t[0]).map((e) => e[1]);
          return (e, n = 0) => {
            const s = [],
              a = e.split("\n");
            for (let e = n; e < a.length; e++) {
              const n = a[e];
              if (n.length > 1024) continue;
              const r = o.test(n) ? n.replace(o, "$1") : n;
              if (!r.match(/\S*Error: /)) {
                for (const e of t) {
                  const t = e(r);
                  if (t) {
                    s.push(t);
                    break;
                  }
                }
                if (s.length >= i) break;
              }
            }
            return c(s);
          };
        }
        function l(e) {
          return Array.isArray(e) ? r(...e) : e;
        }
        function c(e) {
          if (!e.length) return [];
          const t = Array.from(e);
          return (
            /sentryWrapped/.test(t[t.length - 1].function || "") && t.pop(),
            t.reverse(),
            a.test(t[t.length - 1].function || "") &&
              (t.pop(), a.test(t[t.length - 1].function || "") && t.pop()),
            t
              .slice(0, i)
              .map((e) => ({
                ...e,
                filename: e.filename || t[t.length - 1].filename,
                function: e.function || "?",
              }))
          );
        }
        const u = "<anonymous>";
        function m(e) {
          try {
            return (e && "function" == typeof e && e.name) || u;
          } catch (e) {
            return u;
          }
        }
        function d(e) {
          return [90, (0, s.node)(e)];
        }
      },
      (e, t, n) => {
        "use strict";
        function s(e, t = !1) {
          return (
            !(
              t ||
              (e &&
                !e.startsWith("/") &&
                !e.match(/^[A-Z]:/) &&
                !e.startsWith(".") &&
                !e.match(/^[a-zA-Z]([a-zA-Z0-9.\-+])*:\/\//))
            ) &&
            void 0 !== e &&
            !e.includes("node_modules/")
          );
        }
        function i(e) {
          const t = /^\s*[-]{4,}$/,
            n = /at (?:async )?(?:(.+?)\s+\()?(?:(.+):(\d+):(\d+)?|([^)]+))\)?/;
          return (i) => {
            const o = i.match(n);
            if (o) {
              let t, n, i, a, r;
              if (o[1]) {
                i = o[1];
                let e = i.lastIndexOf(".");
                if (("." === i[e - 1] && e--, e > 0)) {
                  (t = i.slice(0, e)), (n = i.slice(e + 1));
                  const s = t.indexOf(".Module");
                  s > 0 && ((i = i.slice(s + 1)), (t = t.slice(0, s)));
                }
                a = void 0;
              }
              n && ((a = t), (r = n)),
                "<anonymous>" === n && ((r = void 0), (i = void 0)),
                void 0 === i &&
                  ((r = r || "<anonymous>"), (i = a ? `${a}.${r}` : r));
              let l = o[2] && o[2].startsWith("file://") ? o[2].slice(7) : o[2];
              const c = "native" === o[5];
              return (
                l && l.match(/\/[A-Z]:/) && (l = l.slice(1)),
                l || !o[5] || c || (l = o[5]),
                {
                  filename: l,
                  module: e ? e(l) : void 0,
                  function: i,
                  lineno: parseInt(o[3], 10) || void 0,
                  colno: parseInt(o[4], 10) || void 0,
                  in_app: s(l, c),
                }
              );
            }
            if (i.match(t)) return { filename: i };
          };
        }
        n.r(t), n.d(t, { filenameIsInApp: () => s, node: () => i });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addIntegration: () => h,
            afterSetupIntegrations: () => d,
            convertIntegrationFnToClass: () => g,
            defineIntegration: () => f,
            getIntegrationsToSetup: () => u,
            installedIntegrations: () => c,
            setupIntegration: () => p,
            setupIntegrations: () => m,
          });
        var s = n(18),
          i = n(7),
          o = n(28),
          a = n(26),
          r = n(12),
          l = n(13);
        const c = [];
        function u(e) {
          const t = e.defaultIntegrations || [],
            n = e.integrations;
          let i;
          t.forEach((e) => {
            e.isDefaultInstance = !0;
          }),
            (i = Array.isArray(n)
              ? [...t, ...n]
              : "function" == typeof n
                ? (0, s.arrayify)(n(t))
                : t);
          const o = (function (e) {
              const t = {};
              return (
                e.forEach((e) => {
                  const { name: n } = e,
                    s = t[n];
                  (s && !s.isDefaultInstance && e.isDefaultInstance) ||
                    (t[n] = e);
                }),
                Object.keys(t).map((e) => t[e])
              );
            })(i),
            a = (function (e, t) {
              for (let n = 0; n < e.length; n++) if (!0 === t(e[n])) return n;
              return -1;
            })(o, (e) => "Debug" === e.name);
          if (-1 !== a) {
            const [e] = o.splice(a, 1);
            o.push(e);
          }
          return o;
        }
        function m(e, t) {
          const n = {};
          return (
            t.forEach((t) => {
              t && p(e, t, n);
            }),
            n
          );
        }
        function d(e, t) {
          for (const n of t) n && n.afterAllSetup && n.afterAllSetup(e);
        }
        function p(e, t, n) {
          if (n[t.name])
            o.DEBUG_BUILD &&
              i.logger.log(
                `Integration skipped because it was already installed: ${t.name}`,
              );
          else {
            if (
              ((n[t.name] = t),
              -1 === c.indexOf(t.name) &&
                (t.setupOnce(a.addGlobalEventProcessor, l.getCurrentHub),
                c.push(t.name)),
              t.setup && "function" == typeof t.setup && t.setup(e),
              e.on && "function" == typeof t.preprocessEvent)
            ) {
              const n = t.preprocessEvent.bind(t);
              e.on("preprocessEvent", (t, s) => n(t, s, e));
            }
            if (e.addEventProcessor && "function" == typeof t.processEvent) {
              const n = t.processEvent.bind(t),
                s = Object.assign((t, s) => n(t, s, e), { id: t.name });
              e.addEventProcessor(s);
            }
            o.DEBUG_BUILD && i.logger.log(`Integration installed: ${t.name}`);
          }
        }
        function h(e) {
          const t = (0, r.getClient)();
          t && t.addIntegration
            ? t.addIntegration(e)
            : o.DEBUG_BUILD &&
              i.logger.warn(
                `Cannot add integration "${e.name}" because no SDK Client is available.`,
              );
        }
        function g(e, t) {
          return Object.assign(
            function (...e) {
              return t(...e);
            },
            { id: e },
          );
        }
        function f(e) {
          return e;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            InboundFilters: () => d,
            inboundFiltersIntegration: () => m,
          });
        var s = n(7),
          i = n(18),
          o = n(11),
          a = n(28),
          r = n(34);
        const l = [
            /^Script error\.?$/,
            /^Javascript error: Script error\.? on line 0$/,
          ],
          c = [
            /^.*\/healthcheck$/,
            /^.*\/healthy$/,
            /^.*\/live$/,
            /^.*\/ready$/,
            /^.*\/heartbeat$/,
            /^.*\/health$/,
            /^.*\/healthz$/,
          ],
          u = "InboundFilters",
          m = (0, r.defineIntegration)((e = {}) => ({
            name: u,
            setupOnce() {},
            processEvent(t, n, r) {
              const u = r.getOptions(),
                m = (function (e = {}, t = {}) {
                  return {
                    allowUrls: [...(e.allowUrls || []), ...(t.allowUrls || [])],
                    denyUrls: [...(e.denyUrls || []), ...(t.denyUrls || [])],
                    ignoreErrors: [
                      ...(e.ignoreErrors || []),
                      ...(t.ignoreErrors || []),
                      ...(e.disableErrorDefaults ? [] : l),
                    ],
                    ignoreTransactions: [
                      ...(e.ignoreTransactions || []),
                      ...(t.ignoreTransactions || []),
                      ...(e.disableTransactionDefaults ? [] : c),
                    ],
                    ignoreInternal:
                      void 0 === e.ignoreInternal || e.ignoreInternal,
                  };
                })(e, u);
              return (function (e, t) {
                if (
                  t.ignoreInternal &&
                  (function (e) {
                    try {
                      return "SentryError" === e.exception.values[0].type;
                    } catch (e) {}
                    return !1;
                  })(e)
                )
                  return (
                    a.DEBUG_BUILD &&
                      s.logger.warn(
                        `Event dropped due to being internal Sentry Error.\nEvent: ${(0, i.getEventDescription)(e)}`,
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if (e.type || !t || !t.length) return !1;
                    return (function (e) {
                      const t = [];
                      e.message && t.push(e.message);
                      let n;
                      try {
                        n = e.exception.values[e.exception.values.length - 1];
                      } catch (e) {}
                      n &&
                        n.value &&
                        (t.push(n.value),
                        n.type && t.push(`${n.type}: ${n.value}`));
                      a.DEBUG_BUILD &&
                        0 === t.length &&
                        s.logger.error(
                          `Could not extract message for event ${(0, i.getEventDescription)(e)}`,
                        );
                      return t;
                    })(e).some((e) => (0, o.stringMatchesSomePattern)(e, t));
                  })(e, t.ignoreErrors)
                )
                  return (
                    a.DEBUG_BUILD &&
                      s.logger.warn(
                        `Event dropped due to being matched by \`ignoreErrors\` option.\nEvent: ${(0, i.getEventDescription)(e)}`,
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if ("transaction" !== e.type || !t || !t.length) return !1;
                    const n = e.transaction;
                    return !!n && (0, o.stringMatchesSomePattern)(n, t);
                  })(e, t.ignoreTransactions)
                )
                  return (
                    a.DEBUG_BUILD &&
                      s.logger.warn(
                        `Event dropped due to being matched by \`ignoreTransactions\` option.\nEvent: ${(0, i.getEventDescription)(e)}`,
                      ),
                    !0
                  );
                if (
                  (function (e, t) {
                    if (!t || !t.length) return !1;
                    const n = p(e);
                    return !!n && (0, o.stringMatchesSomePattern)(n, t);
                  })(e, t.denyUrls)
                )
                  return (
                    a.DEBUG_BUILD &&
                      s.logger.warn(
                        `Event dropped due to being matched by \`denyUrls\` option.\nEvent: ${(0, i.getEventDescription)(e)}.\nUrl: ${p(e)}`,
                      ),
                    !0
                  );
                if (
                  !(function (e, t) {
                    if (!t || !t.length) return !0;
                    const n = p(e);
                    return !n || (0, o.stringMatchesSomePattern)(n, t);
                  })(e, t.allowUrls)
                )
                  return (
                    a.DEBUG_BUILD &&
                      s.logger.warn(
                        `Event dropped due to not being matched by \`allowUrls\` option.\nEvent: ${(0, i.getEventDescription)(e)}.\nUrl: ${p(e)}`,
                      ),
                    !0
                  );
                return !1;
              })(t, m)
                ? null
                : t;
            },
          })),
          d = (0, r.convertIntegrationFnToClass)(u, m);
        function p(e) {
          try {
            let t;
            try {
              t = e.exception.values[0].stacktrace.frames;
            } catch (e) {}
            return t
              ? (function (e = []) {
                  for (let t = e.length - 1; t >= 0; t--) {
                    const n = e[t];
                    if (
                      n &&
                      "<anonymous>" !== n.filename &&
                      "[native code]" !== n.filename
                    )
                      return n.filename || null;
                  }
                  return null;
                })(t)
              : null;
          } catch (t) {
            return (
              a.DEBUG_BUILD &&
                s.logger.error(
                  `Cannot extract url for event ${(0, i.getEventDescription)(e)}`,
                ),
              null
            );
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            ModuleMetadata: () => l,
            moduleMetadataIntegration: () => r,
          });
        var s = n(37),
          i = n(34),
          o = n(39);
        const a = "ModuleMetadata",
          r = (0, i.defineIntegration)(() => ({
            name: a,
            setupOnce() {},
            setup(e) {
              "function" == typeof e.on &&
                e.on("beforeEnvelope", (e) => {
                  (0, s.forEachEnvelopeItem)(e, (e, t) => {
                    if ("event" === t) {
                      const t = Array.isArray(e) ? e[1] : void 0;
                      t && ((0, o.stripMetadataFromStackFrames)(t), (e[1] = t));
                    }
                  });
                });
            },
            processEvent(e, t, n) {
              const s = n.getOptions().stackParser;
              return (0, o.addMetadataToStackFrames)(s, e), e;
            },
          })),
          l = (0, i.convertIntegrationFnToClass)(a, r);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addItemToEnvelope: () => r,
            createAttachmentEnvelopeItem: () => p,
            createEnvelope: () => a,
            createEventEnvelopeHeaders: () => S,
            envelopeContainsItemType: () => c,
            envelopeItemTypeToDataCategory: () => g,
            forEachEnvelopeItem: () => l,
            getSdkMetadataForEnvelopeHeader: () => f,
            parseEnvelope: () => d,
            serializeEnvelope: () => m,
          });
        var s = n(38),
          i = n(30),
          o = n(5);
        function a(e, t = []) {
          return [e, t];
        }
        function r(e, t) {
          const [n, s] = e;
          return [n, [...s, t]];
        }
        function l(e, t) {
          const n = e[1];
          for (const e of n) {
            if (t(e, e[0].type)) return !0;
          }
          return !1;
        }
        function c(e, t) {
          return l(e, (e, n) => t.includes(n));
        }
        function u(e, t) {
          return (t || new TextEncoder()).encode(e);
        }
        function m(e, t) {
          const [n, s] = e;
          let o = JSON.stringify(n);
          function a(e) {
            "string" == typeof o
              ? (o = "string" == typeof e ? o + e : [u(o, t), e])
              : o.push("string" == typeof e ? u(e, t) : e);
          }
          for (const e of s) {
            const [t, n] = e;
            if (
              (a(`\n${JSON.stringify(t)}\n`),
              "string" == typeof n || n instanceof Uint8Array)
            )
              a(n);
            else {
              let e;
              try {
                e = JSON.stringify(n);
              } catch (t) {
                e = JSON.stringify((0, i.normalize)(n));
              }
              a(e);
            }
          }
          return "string" == typeof o
            ? o
            : (function (e) {
                const t = e.reduce((e, t) => e + t.length, 0),
                  n = new Uint8Array(t);
                let s = 0;
                for (const t of e) n.set(t, s), (s += t.length);
                return n;
              })(o);
        }
        function d(e, t, n) {
          let s = "string" == typeof e ? t.encode(e) : e;
          function i(e) {
            const t = s.subarray(0, e);
            return (s = s.subarray(e + 1)), t;
          }
          function o() {
            let e = s.indexOf(10);
            return e < 0 && (e = s.length), JSON.parse(n.decode(i(e)));
          }
          const a = o(),
            r = [];
          for (; s.length; ) {
            const e = o(),
              t = "number" == typeof e.length ? e.length : void 0;
            r.push([e, t ? i(t) : o()]);
          }
          return [a, r];
        }
        function p(e, t) {
          const n = "string" == typeof e.data ? u(e.data, t) : e.data;
          return [
            (0, o.dropUndefinedKeys)({
              type: "attachment",
              length: n.length,
              filename: e.filename,
              content_type: e.contentType,
              attachment_type: e.attachmentType,
            }),
            n,
          ];
        }
        const h = {
          session: "session",
          sessions: "session",
          attachment: "attachment",
          transaction: "transaction",
          event: "error",
          client_report: "internal",
          user_report: "default",
          profile: "profile",
          replay_event: "replay",
          replay_recording: "replay",
          check_in: "monitor",
          feedback: "feedback",
          statsd: "unknown",
        };
        function g(e) {
          return h[e];
        }
        function f(e) {
          if (!e || !e.sdk) return;
          const { name: t, version: n } = e.sdk;
          return { name: t, version: n };
        }
        function S(e, t, n, i) {
          const a =
            e.sdkProcessingMetadata &&
            e.sdkProcessingMetadata.dynamicSamplingContext;
          return {
            event_id: e.event_id,
            sent_at: new Date().toISOString(),
            ...(t && { sdk: t }),
            ...(!!n && i && { dsn: (0, s.dsnToString)(i) }),
            ...(a && { trace: (0, o.dropUndefinedKeys)({ ...a }) }),
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            dsnFromString: () => r,
            dsnToString: () => a,
            makeDsn: () => c,
          });
        var s = n(6),
          i = n(7);
        const o =
          /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
        function a(e, t = !1) {
          const {
            host: n,
            path: s,
            pass: i,
            port: o,
            projectId: a,
            protocol: r,
            publicKey: l,
          } = e;
          return `${r}://${l}${t && i ? `:${i}` : ""}@${n}${o ? `:${o}` : ""}/${s ? `${s}/` : s}${a}`;
        }
        function r(e) {
          const t = o.exec(e);
          if (!t)
            return void (0, i.consoleSandbox)(() => {
              console.error(`Invalid Sentry Dsn: ${e}`);
            });
          const [n, s, a = "", r, c = "", u] = t.slice(1);
          let m = "",
            d = u;
          const p = d.split("/");
          if (
            (p.length > 1 && ((m = p.slice(0, -1).join("/")), (d = p.pop())), d)
          ) {
            const e = d.match(/^\d+/);
            e && (d = e[0]);
          }
          return l({
            host: r,
            pass: a,
            path: m,
            projectId: d,
            port: c,
            protocol: n,
            publicKey: s,
          });
        }
        function l(e) {
          return {
            protocol: e.protocol,
            publicKey: e.publicKey || "",
            pass: e.pass || "",
            host: e.host,
            port: e.port || "",
            path: e.path || "",
            projectId: e.projectId,
          };
        }
        function c(e) {
          const t = "string" == typeof e ? r(e) : l(e);
          if (
            t &&
            (function (e) {
              if (!s.DEBUG_BUILD) return !0;
              const { port: t, projectId: n, protocol: o } = e;
              return !(
                ["protocol", "publicKey", "host", "projectId"].find(
                  (t) =>
                    !e[t] &&
                    (i.logger.error(`Invalid Sentry Dsn: ${t} missing`), !0),
                ) ||
                (n.match(/^\d+$/)
                  ? (function (e) {
                      return "http" === e || "https" === e;
                    })(o)
                    ? t &&
                      isNaN(parseInt(t, 10)) &&
                      (i.logger.error(`Invalid Sentry Dsn: Invalid port ${t}`),
                      1)
                    : (i.logger.error(
                        `Invalid Sentry Dsn: Invalid protocol ${o}`,
                      ),
                      1)
                  : (i.logger.error(
                      `Invalid Sentry Dsn: Invalid projectId ${n}`,
                    ),
                    1))
              );
            })(t)
          )
            return t;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addMetadataToStackFrames: () => r,
            getMetadataForUrl: () => a,
            stripMetadataFromStackFrames: () => l,
          });
        var s = n(8);
        const i = new Map(),
          o = new Set();
        function a(e, t) {
          return (
            (function (e) {
              if (s.GLOBAL_OBJ._sentryModuleMetadata)
                for (const t of Object.keys(
                  s.GLOBAL_OBJ._sentryModuleMetadata,
                )) {
                  const n = s.GLOBAL_OBJ._sentryModuleMetadata[t];
                  if (o.has(t)) continue;
                  o.add(t);
                  const a = e(t);
                  for (const e of a.reverse())
                    if (e.filename) {
                      i.set(e.filename, n);
                      break;
                    }
                }
            })(e),
            i.get(t)
          );
        }
        function r(e, t) {
          try {
            t.exception.values.forEach((t) => {
              if (t.stacktrace)
                for (const n of t.stacktrace.frames || []) {
                  if (!n.filename) continue;
                  const t = a(e, n.filename);
                  t && (n.module_metadata = t);
                }
            });
          } catch (e) {}
        }
        function l(e) {
          try {
            e.exception.values.forEach((e) => {
              if (e.stacktrace)
                for (const t of e.stacktrace.frames || [])
                  delete t.module_metadata;
            });
          } catch (e) {}
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            SEMANTIC_ATTRIBUTE_SENTRY_OP: () => o,
            SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN: () => a,
            SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE: () => i,
            SEMANTIC_ATTRIBUTE_SENTRY_SOURCE: () => s,
          });
        const s = "sentry.source",
          i = "sentry.sample_rate",
          o = "sentry.op",
          a = "sentry.origin";
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { BaseClient: () => v, addEventProcessor: () => E });
        var s = n(38),
          i = n(7),
          o = n(18),
          a = n(9),
          r = n(27),
          l = n(37),
          c = n(47),
          u = n(42),
          m = n(28),
          d = n(43),
          p = n(12),
          h = n(13),
          g = n(34),
          f = n(44),
          S = n(16),
          b = n(24),
          y = n(29);
        const _ = "Not capturing exception because it's already been captured.";
        class v {
          constructor(e) {
            if (
              ((this._options = e),
              (this._integrations = {}),
              (this._integrationsInitialized = !1),
              (this._numProcessing = 0),
              (this._outcomes = {}),
              (this._hooks = {}),
              (this._eventProcessors = []),
              e.dsn
                ? (this._dsn = (0, s.makeDsn)(e.dsn))
                : m.DEBUG_BUILD &&
                  i.logger.warn(
                    "No DSN provided, client will not send events.",
                  ),
              this._dsn)
            ) {
              const t = (0, u.getEnvelopeEndpointWithUrlEncodedAuth)(
                this._dsn,
                e,
              );
              this._transport = e.transport({
                recordDroppedEvent: this.recordDroppedEvent.bind(this),
                ...e.transportOptions,
                url: t,
              });
            }
          }
          captureException(e, t, n) {
            if ((0, o.checkOrSetAlreadyCaught)(e))
              return void (m.DEBUG_BUILD && i.logger.log(_));
            let s = t && t.event_id;
            return (
              this._process(
                this.eventFromException(e, t)
                  .then((e) => this._captureEvent(e, t, n))
                  .then((e) => {
                    s = e;
                  }),
              ),
              s
            );
          }
          captureMessage(e, t, n, s) {
            let i = n && n.event_id;
            const o = (0, a.isParameterizedString)(e) ? e : String(e),
              r = (0, a.isPrimitive)(e)
                ? this.eventFromMessage(o, t, n)
                : this.eventFromException(e, n);
            return (
              this._process(
                r
                  .then((e) => this._captureEvent(e, n, s))
                  .then((e) => {
                    i = e;
                  }),
              ),
              i
            );
          }
          captureEvent(e, t, n) {
            if (
              t &&
              t.originalException &&
              (0, o.checkOrSetAlreadyCaught)(t.originalException)
            )
              return void (m.DEBUG_BUILD && i.logger.log(_));
            let s = t && t.event_id;
            const a = (e.sdkProcessingMetadata || {}).capturedSpanScope;
            return (
              this._process(
                this._captureEvent(e, t, a || n).then((e) => {
                  s = e;
                }),
              ),
              s
            );
          }
          captureSession(e) {
            "string" != typeof e.release
              ? m.DEBUG_BUILD &&
                i.logger.warn(
                  "Discarded session because of missing or non-string release",
                )
              : (this.sendSession(e), (0, S.updateSession)(e, { init: !1 }));
          }
          getDsn() {
            return this._dsn;
          }
          getOptions() {
            return this._options;
          }
          getSdkMetadata() {
            return this._options._metadata;
          }
          getTransport() {
            return this._transport;
          }
          flush(e) {
            const t = this._transport;
            return t
              ? (this.metricsAggregator && this.metricsAggregator.flush(),
                this._isClientDoneProcessing(e).then((n) =>
                  t.flush(e).then((e) => n && e),
                ))
              : (0, r.resolvedSyncPromise)(!0);
          }
          close(e) {
            return this.flush(e).then(
              (e) => (
                (this.getOptions().enabled = !1),
                this.metricsAggregator && this.metricsAggregator.close(),
                e
              ),
            );
          }
          getEventProcessors() {
            return this._eventProcessors;
          }
          addEventProcessor(e) {
            this._eventProcessors.push(e);
          }
          setupIntegrations(e) {
            ((e && !this._integrationsInitialized) ||
              (this._isEnabled() && !this._integrationsInitialized)) &&
              this._setupIntegrations();
          }
          init() {
            this._isEnabled() && this._setupIntegrations();
          }
          getIntegrationById(e) {
            return this.getIntegrationByName(e);
          }
          getIntegrationByName(e) {
            return this._integrations[e];
          }
          getIntegration(e) {
            try {
              return this._integrations[e.id] || null;
            } catch (t) {
              return (
                m.DEBUG_BUILD &&
                  i.logger.warn(
                    `Cannot retrieve integration ${e.id} from the current Client`,
                  ),
                null
              );
            }
          }
          addIntegration(e) {
            const t = this._integrations[e.name];
            (0, g.setupIntegration)(this, e, this._integrations),
              t || (0, g.afterSetupIntegrations)(this, [e]);
          }
          sendEvent(e, t = {}) {
            this.emit("beforeSendEvent", e, t);
            let n = (0, d.createEventEnvelope)(
              e,
              this._dsn,
              this._options._metadata,
              this._options.tunnel,
            );
            for (const e of t.attachments || [])
              n = (0, l.addItemToEnvelope)(
                n,
                (0, l.createAttachmentEnvelopeItem)(
                  e,
                  this._options.transportOptions &&
                    this._options.transportOptions.textEncoder,
                ),
              );
            const s = this._sendEnvelope(n);
            s && s.then((t) => this.emit("afterSendEvent", e, t), null);
          }
          sendSession(e) {
            const t = (0, d.createSessionEnvelope)(
              e,
              this._dsn,
              this._options._metadata,
              this._options.tunnel,
            );
            this._sendEnvelope(t);
          }
          recordDroppedEvent(e, t, n) {
            if (this._options.sendClientReports) {
              const n = `${e}:${t}`;
              m.DEBUG_BUILD && i.logger.log(`Adding outcome: "${n}"`),
                (this._outcomes[n] = this._outcomes[n] + 1 || 1);
            }
          }
          captureAggregateMetrics(e) {
            m.DEBUG_BUILD &&
              i.logger.log(
                `Flushing aggregated metrics, number of metrics: ${e.length}`,
              );
            const t = (0, f.createMetricEnvelope)(
              e,
              this._dsn,
              this._options._metadata,
              this._options.tunnel,
            );
            this._sendEnvelope(t);
          }
          on(e, t) {
            this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(t);
          }
          emit(e, ...t) {
            this._hooks[e] && this._hooks[e].forEach((e) => e(...t));
          }
          _setupIntegrations() {
            const { integrations: e } = this._options;
            (this._integrations = (0, g.setupIntegrations)(this, e)),
              (0, g.afterSetupIntegrations)(this, e),
              (this._integrationsInitialized = !0);
          }
          _updateSessionFromEvent(e, t) {
            let n = !1,
              s = !1;
            const i = t.exception && t.exception.values;
            if (i) {
              s = !0;
              for (const e of i) {
                const t = e.mechanism;
                if (t && !1 === t.handled) {
                  n = !0;
                  break;
                }
              }
            }
            const o = "ok" === e.status;
            ((o && 0 === e.errors) || (o && n)) &&
              ((0, S.updateSession)(e, {
                ...(n && { status: "crashed" }),
                errors: e.errors || Number(s || n),
              }),
              this.captureSession(e));
          }
          _isClientDoneProcessing(e) {
            return new r.SyncPromise((t) => {
              let n = 0;
              const s = setInterval(() => {
                0 == this._numProcessing
                  ? (clearInterval(s), t(!0))
                  : ((n += 1), e && n >= e && (clearInterval(s), t(!1)));
              }, 1);
            });
          }
          _isEnabled() {
            return (
              !1 !== this.getOptions().enabled && void 0 !== this._transport
            );
          }
          _prepareEvent(e, t, n, s = (0, h.getIsolationScope)()) {
            const i = this.getOptions(),
              o = Object.keys(this._integrations);
            return (
              !t.integrations && o.length > 0 && (t.integrations = o),
              this.emit("preprocessEvent", e, t),
              (0, y.prepareEvent)(i, e, t, n, this, s).then((e) => {
                if (null === e) return e;
                const t = {
                  ...s.getPropagationContext(),
                  ...(n ? n.getPropagationContext() : void 0),
                };
                if (!(e.contexts && e.contexts.trace) && t) {
                  const { traceId: s, spanId: i, parentSpanId: o, dsc: a } = t;
                  e.contexts = {
                    trace: { trace_id: s, span_id: i, parent_span_id: o },
                    ...e.contexts,
                  };
                  const r =
                    a || (0, b.getDynamicSamplingContextFromClient)(s, this, n);
                  e.sdkProcessingMetadata = {
                    dynamicSamplingContext: r,
                    ...e.sdkProcessingMetadata,
                  };
                }
                return e;
              })
            );
          }
          _captureEvent(e, t = {}, n) {
            return this._processEvent(e, t, n).then(
              (e) => e.event_id,
              (e) => {
                if (m.DEBUG_BUILD) {
                  const t = e;
                  "log" === t.logLevel
                    ? i.logger.log(t.message)
                    : i.logger.warn(t);
                }
              },
            );
          }
          _processEvent(e, t, n) {
            const s = this.getOptions(),
              { sampleRate: i } = s,
              o = k(e),
              l = x(e),
              u = e.type || "error",
              m = `before send for type \`${u}\``;
            if (l && "number" == typeof i && Math.random() > i)
              return (
                this.recordDroppedEvent("sample_rate", "error", e),
                (0, r.rejectedSyncPromise)(
                  new c.SentryError(
                    `Discarding event because it's not included in the random sample (sampling rate = ${i})`,
                    "log",
                  ),
                )
              );
            const d = "replay_event" === u ? "replay" : u,
              p = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
            return this._prepareEvent(e, t, n, p)
              .then((n) => {
                if (null === n)
                  throw (
                    (this.recordDroppedEvent("event_processor", d, e),
                    new c.SentryError(
                      "An event processor returned `null`, will not send event.",
                      "log",
                    ))
                  );
                if (t.data && !0 === t.data.__sentry__) return n;
                const i = (function (e, t, n) {
                  const { beforeSend: s, beforeSendTransaction: i } = e;
                  if (x(t) && s) return s(t, n);
                  if (k(t) && i) return i(t, n);
                  return t;
                })(s, n, t);
                return (function (e, t) {
                  const n = `${t} must return \`null\` or a valid event.`;
                  if ((0, a.isThenable)(e))
                    return e.then(
                      (e) => {
                        if (!(0, a.isPlainObject)(e) && null !== e)
                          throw new c.SentryError(n);
                        return e;
                      },
                      (e) => {
                        throw new c.SentryError(`${t} rejected with ${e}`);
                      },
                    );
                  if (!(0, a.isPlainObject)(e) && null !== e)
                    throw new c.SentryError(n);
                  return e;
                })(i, m);
              })
              .then((s) => {
                if (null === s)
                  throw (
                    (this.recordDroppedEvent("before_send", d, e),
                    new c.SentryError(
                      `${m} returned \`null\`, will not send event.`,
                      "log",
                    ))
                  );
                const i = n && n.getSession();
                !o && i && this._updateSessionFromEvent(i, s);
                const a = s.transaction_info;
                if (o && a && s.transaction !== e.transaction) {
                  const e = "custom";
                  s.transaction_info = { ...a, source: e };
                }
                return this.sendEvent(s, t), s;
              })
              .then(null, (e) => {
                if (e instanceof c.SentryError) throw e;
                throw (
                  (this.captureException(e, {
                    data: { __sentry__: !0 },
                    originalException: e,
                  }),
                  new c.SentryError(
                    `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: ${e}`,
                  ))
                );
              });
          }
          _process(e) {
            this._numProcessing++,
              e.then(
                (e) => (this._numProcessing--, e),
                (e) => (this._numProcessing--, e),
              );
          }
          _sendEnvelope(e) {
            if (
              (this.emit("beforeEnvelope", e),
              this._isEnabled() && this._transport)
            )
              return this._transport.send(e).then(null, (e) => {
                m.DEBUG_BUILD &&
                  i.logger.error("Error while sending event:", e);
              });
            m.DEBUG_BUILD && i.logger.error("Transport disabled");
          }
          _clearOutcomes() {
            const e = this._outcomes;
            return (
              (this._outcomes = {}),
              Object.keys(e).map((t) => {
                const [n, s] = t.split(":");
                return { reason: n, category: s, quantity: e[t] };
              })
            );
          }
        }
        function x(e) {
          return void 0 === e.type;
        }
        function k(e) {
          return "transaction" === e.type;
        }
        function E(e) {
          const t = (0, p.getClient)();
          t && t.addEventProcessor && t.addEventProcessor(e);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            getEnvelopeEndpointWithUrlEncodedAuth: () => r,
            getReportDialogEndpoint: () => l,
          });
        var s = n(5),
          i = n(38);
        const o = "7";
        function a(e) {
          const t = e.protocol ? `${e.protocol}:` : "",
            n = e.port ? `:${e.port}` : "";
          return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/`;
        }
        function r(e, t = {}) {
          const n = "string" == typeof t ? t : t.tunnel,
            i = "string" != typeof t && t._metadata ? t._metadata.sdk : void 0;
          return (
            n ||
            `${(function (e) {
              return `${a(e)}${e.projectId}/envelope/`;
            })(e)}?${(function (e, t) {
              return (0, s.urlEncode)({
                sentry_key: e.publicKey,
                sentry_version: o,
                ...(t && { sentry_client: `${t.name}/${t.version}` }),
              });
            })(e, i)}`
          );
        }
        function l(e, t) {
          const n = (0, i.makeDsn)(e);
          if (!n) return "";
          const s = `${a(n)}embed/error-page/`;
          let o = `dsn=${(0, i.dsnToString)(n)}`;
          for (const e in t)
            if ("dsn" !== e && "onClose" !== e)
              if ("user" === e) {
                const e = t.user;
                if (!e) continue;
                e.name && (o += `&name=${encodeURIComponent(e.name)}`),
                  e.email && (o += `&email=${encodeURIComponent(e.email)}`);
              } else
                o += `&${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`;
          return `${s}?${o}`;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            createEventEnvelope: () => a,
            createSessionEnvelope: () => o,
          });
        var s = n(37),
          i = n(38);
        function o(e, t, n, o) {
          const a = (0, s.getSdkMetadataForEnvelopeHeader)(n),
            r = {
              sent_at: new Date().toISOString(),
              ...(a && { sdk: a }),
              ...(!!o && t && { dsn: (0, i.dsnToString)(t) }),
            },
            l =
              "aggregates" in e
                ? [{ type: "sessions" }, e]
                : [{ type: "session" }, e.toJSON()];
          return (0, s.createEnvelope)(r, [l]);
        }
        function a(e, t, n, i) {
          const o = (0, s.getSdkMetadataForEnvelopeHeader)(n),
            a = e.type && "replay_event" !== e.type ? e.type : "event";
          !(function (e, t) {
            t &&
              ((e.sdk = e.sdk || {}),
              (e.sdk.name = e.sdk.name || t.name),
              (e.sdk.version = e.sdk.version || t.version),
              (e.sdk.integrations = [
                ...(e.sdk.integrations || []),
                ...(t.integrations || []),
              ]),
              (e.sdk.packages = [
                ...(e.sdk.packages || []),
                ...(t.packages || []),
              ]));
          })(e, n && n.sdk);
          const r = (0, s.createEventEnvelopeHeaders)(e, o, i, t);
          delete e.sdkProcessingMetadata;
          const l = [{ type: a }, e];
          return (0, s.createEnvelope)(r, [l]);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { createMetricEnvelope: () => a });
        var s = n(38),
          i = n(37),
          o = n(45);
        function a(e, t, n, a) {
          const r = { sent_at: new Date().toISOString() };
          n && n.sdk && (r.sdk = { name: n.sdk.name, version: n.sdk.version }),
            a && t && (r.dsn = (0, s.dsnToString)(t));
          const l = (function (e) {
            const t = (0, o.serializeMetricBuckets)(e);
            return [{ type: "statsd", length: t.length }, t];
          })(e);
          return (0, i.createEnvelope)(r, [l]);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            getBucketKey: () => o,
            sanitizeTags: () => l,
            serializeMetricBuckets: () => r,
            simpleHash: () => a,
          });
        var s = n(5),
          i = n(46);
        function o(e, t, n, i) {
          return `${e}${t}${n}${Object.entries((0, s.dropUndefinedKeys)(i)).sort((e, t) => e[0].localeCompare(t[0]))}`;
        }
        function a(e) {
          let t = 0;
          for (let n = 0; n < e.length; n++) {
            (t = (t << 5) - t + e.charCodeAt(n)), (t &= t);
          }
          return t >>> 0;
        }
        function r(e) {
          let t = "";
          for (const n of e) {
            const e = Object.entries(n.tags),
              s =
                e.length > 0
                  ? `|#${e.map(([e, t]) => `${e}:${t}`).join(",")}`
                  : "";
            t += `${n.name}@${n.unit}:${n.metric}|${n.metricType}${s}|T${n.timestamp}\n`;
          }
          return t;
        }
        function l(e) {
          const t = {};
          for (const n in e)
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              t[n.replace(i.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_")] =
                String(e[n]).replace(i.TAG_VALUE_NORMALIZATION_REGEX, "");
            }
          return t;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            COUNTER_METRIC_TYPE: () => s,
            DEFAULT_BROWSER_FLUSH_INTERVAL: () => c,
            DEFAULT_FLUSH_INTERVAL: () => u,
            DISTRIBUTION_METRIC_TYPE: () => a,
            GAUGE_METRIC_TYPE: () => i,
            MAX_WEIGHT: () => m,
            NAME_AND_TAG_KEY_NORMALIZATION_REGEX: () => r,
            SET_METRIC_TYPE: () => o,
            TAG_VALUE_NORMALIZATION_REGEX: () => l,
          });
        const s = "c",
          i = "g",
          o = "s",
          a = "d",
          r = /[^a-zA-Z0-9_/.-]+/g,
          l = /[^\w\d\s_:/@.{}[\]$-]+/g,
          c = 5e3,
          u = 1e4,
          m = 1e4;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { SentryError: () => s });
        class s extends Error {
          constructor(e, t = "warn") {
            super(e),
              (this.message = e),
              (this.name = new.target.prototype.constructor.name),
              Object.setPrototypeOf(this, new.target.prototype),
              (this.logLevel = t);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addTracingExtensions: () => h,
            startIdleTransaction: () => p,
          });
        var s = n(7),
          i = n(28),
          o = n(13),
          a = n(20),
          r = n(58),
          l = n(57),
          c = n(56),
          u = n(49);
        function m() {
          const e = this.getScope().getSpan();
          return e ? { "sentry-trace": (0, a.spanToTraceHeader)(e) } : {};
        }
        function d(e, t) {
          const n = this.getClient(),
            o = (n && n.getOptions()) || {},
            a = o.instrumenter || "sentry",
            r = e.instrumenter || "sentry";
          a !== r &&
            (i.DEBUG_BUILD &&
              s.logger.error(
                `A transaction was started with instrumenter=\`${r}\`, but the SDK is configured with the \`${a}\` instrumenter.\nThe transaction will not be sampled. Please use the ${a} instrumentation to start transactions.`,
              ),
            (e.sampled = !1));
          let l = new u.Transaction(e, this);
          return (
            (l = (0, c.sampleTransaction)(l, o, {
              name: e.name,
              parentSampled: e.parentSampled,
              transactionContext: e,
              attributes: { ...e.data, ...e.attributes },
              ...t,
            })),
            l.isRecording() &&
              l.initSpanRecorder(o._experiments && o._experiments.maxSpans),
            n && n.emit && n.emit("startTransaction", l),
            l
          );
        }
        function p(e, t, n, s, i, o, a, r = !1) {
          const u = e.getClient(),
            m = (u && u.getOptions()) || {};
          let d = new l.IdleTransaction(t, e, n, s, a, i, r);
          return (
            (d = (0, c.sampleTransaction)(d, m, {
              name: t.name,
              parentSampled: t.parentSampled,
              transactionContext: t,
              attributes: { ...t.data, ...t.attributes },
              ...o,
            })),
            d.isRecording() &&
              d.initSpanRecorder(m._experiments && m._experiments.maxSpans),
            u && u.emit && u.emit("startTransaction", d),
            d
          );
        }
        function h() {
          const e = (0, o.getMainCarrier)();
          e.__SENTRY__ &&
            ((e.__SENTRY__.extensions = e.__SENTRY__.extensions || {}),
            e.__SENTRY__.extensions.startTransaction ||
              (e.__SENTRY__.extensions.startTransaction = d),
            e.__SENTRY__.extensions.traceHeaders ||
              (e.__SENTRY__.extensions.traceHeaders = m),
            (0, r.registerErrorInstrumentation)());
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { Transaction: () => p });
        var s = n(5),
          i = n(7),
          o = n(28),
          a = n(13),
          r = n(52),
          l = n(40),
          c = n(20),
          u = n(24),
          m = n(50),
          d = n(53);
        class p extends m.Span {
          constructor(e, t) {
            super(e),
              (this._measurements = {}),
              (this._contexts = {}),
              (this._hub = t || (0, a.getCurrentHub)()),
              (this._name = e.name || ""),
              (this._metadata = { ...e.metadata }),
              (this._trimEnd = e.trimEnd),
              (this.transaction = this);
            const n = this._metadata.dynamicSamplingContext;
            n && (this._frozenDynamicSamplingContext = { ...n });
          }
          get name() {
            return this._name;
          }
          set name(e) {
            this.setName(e);
          }
          get metadata() {
            return {
              source: "custom",
              spanMetadata: {},
              ...this._metadata,
              ...(this._attributes[l.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] && {
                source: this._attributes[l.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
              }),
              ...(this._attributes[l.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] && {
                sampleRate:
                  this._attributes[l.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE],
              }),
            };
          }
          set metadata(e) {
            this._metadata = e;
          }
          setName(e, t = "custom") {
            (this._name = e),
              this.setAttribute(l.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, t);
          }
          updateName(e) {
            return (this._name = e), this;
          }
          initSpanRecorder(e = 1e3) {
            this.spanRecorder || (this.spanRecorder = new m.SpanRecorder(e)),
              this.spanRecorder.add(this);
          }
          setContext(e, t) {
            null === t ? delete this._contexts[e] : (this._contexts[e] = t);
          }
          setMeasurement(e, t, n = "") {
            this._measurements[e] = { value: t, unit: n };
          }
          setMetadata(e) {
            this._metadata = { ...this._metadata, ...e };
          }
          end(e) {
            const t = (0, c.spanTimeInputToSeconds)(e),
              n = this._finishTransaction(t);
            if (n) return this._hub.captureEvent(n);
          }
          toContext() {
            const e = super.toContext();
            return (0, s.dropUndefinedKeys)({
              ...e,
              name: this._name,
              trimEnd: this._trimEnd,
            });
          }
          updateWithContext(e) {
            return (
              super.updateWithContext(e),
              (this._name = e.name || ""),
              (this._trimEnd = e.trimEnd),
              this
            );
          }
          getDynamicSamplingContext() {
            return (0, u.getDynamicSamplingContextFromSpan)(this);
          }
          setHub(e) {
            this._hub = e;
          }
          _finishTransaction(e) {
            if (void 0 !== this._endTime) return;
            this._name ||
              (o.DEBUG_BUILD &&
                i.logger.warn(
                  "Transaction has no name, falling back to `<unlabeled transaction>`.",
                ),
              (this._name = "<unlabeled transaction>")),
              super.end(e);
            const t = this._hub.getClient();
            if (
              (t && t.emit && t.emit("finishTransaction", this),
              !0 !== this._sampled)
            )
              return (
                o.DEBUG_BUILD &&
                  i.logger.log(
                    "[Tracing] Discarding transaction because its trace was not chosen to be sampled.",
                  ),
                void (t && t.recordDroppedEvent("sample_rate", "transaction"))
              );
            const n = this.spanRecorder
              ? this.spanRecorder.spans.filter(
                  (e) => e !== this && (0, c.spanToJSON)(e).timestamp,
                )
              : [];
            if (this._trimEnd && n.length > 0) {
              const e = n
                .map((e) => (0, c.spanToJSON)(e).timestamp)
                .filter(Boolean);
              this._endTime = e.reduce((e, t) => (e > t ? e : t));
            }
            const { scope: s, isolationScope: a } = (0,
              d.getCapturedScopesOnSpan)(this),
              { metadata: l } = this,
              { source: m } = l,
              p = {
                contexts: {
                  ...this._contexts,
                  trace: (0, c.spanToTraceContext)(this),
                },
                spans: n,
                start_timestamp: this._startTime,
                tags: this.tags,
                timestamp: this._endTime,
                transaction: this._name,
                type: "transaction",
                sdkProcessingMetadata: {
                  ...l,
                  capturedSpanScope: s,
                  capturedSpanIsolationScope: a,
                  dynamicSamplingContext: (0,
                  u.getDynamicSamplingContextFromSpan)(this),
                },
                _metrics_summary: (0, r.getMetricSummaryJsonForSpan)(this),
                ...(m && { transaction_info: { source: m } }),
              };
            return (
              Object.keys(this._measurements).length > 0 &&
                (o.DEBUG_BUILD &&
                  i.logger.log(
                    "[Measurements] Adding measurements to transaction",
                    JSON.stringify(this._measurements, void 0, 2),
                  ),
                (p.measurements = this._measurements)),
              o.DEBUG_BUILD &&
                i.logger.log(
                  `[Tracing] Finishing ${this.op} transaction: ${this._name}.`,
                ),
              p
            );
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { Span: () => h, SpanRecorder: () => p });
        var s = n(18),
          i = n(17),
          o = n(7),
          a = n(5),
          r = n(28),
          l = n(52),
          c = n(40),
          u = n(23),
          m = n(20),
          d = n(51);
        class p {
          constructor(e = 1e3) {
            (this._maxlen = e), (this.spans = []);
          }
          add(e) {
            this.spans.length > this._maxlen
              ? (e.spanRecorder = void 0)
              : this.spans.push(e);
          }
        }
        class h {
          constructor(e = {}) {
            (this._traceId = e.traceId || (0, s.uuid4)()),
              (this._spanId = e.spanId || (0, s.uuid4)().substring(16)),
              (this._startTime =
                e.startTimestamp || (0, i.timestampInSeconds)()),
              (this.tags = e.tags ? { ...e.tags } : {}),
              (this.data = e.data ? { ...e.data } : {}),
              (this.instrumenter = e.instrumenter || "sentry"),
              (this._attributes = {}),
              this.setAttributes({
                [c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: e.origin || "manual",
                [c.SEMANTIC_ATTRIBUTE_SENTRY_OP]: e.op,
                ...e.attributes,
              }),
              (this._name = e.name || e.description),
              e.parentSpanId && (this._parentSpanId = e.parentSpanId),
              "sampled" in e && (this._sampled = e.sampled),
              e.status && (this._status = e.status),
              e.endTimestamp && (this._endTime = e.endTimestamp);
          }
          get name() {
            return this._name || "";
          }
          set name(e) {
            this.updateName(e);
          }
          get description() {
            return this._name;
          }
          set description(e) {
            this._name = e;
          }
          get traceId() {
            return this._traceId;
          }
          set traceId(e) {
            this._traceId = e;
          }
          get spanId() {
            return this._spanId;
          }
          set spanId(e) {
            this._spanId = e;
          }
          set parentSpanId(e) {
            this._parentSpanId = e;
          }
          get parentSpanId() {
            return this._parentSpanId;
          }
          get sampled() {
            return this._sampled;
          }
          set sampled(e) {
            this._sampled = e;
          }
          get attributes() {
            return this._attributes;
          }
          set attributes(e) {
            this._attributes = e;
          }
          get startTimestamp() {
            return this._startTime;
          }
          set startTimestamp(e) {
            this._startTime = e;
          }
          get endTimestamp() {
            return this._endTime;
          }
          set endTimestamp(e) {
            this._endTime = e;
          }
          get status() {
            return this._status;
          }
          set status(e) {
            this._status = e;
          }
          get op() {
            return this._attributes[c.SEMANTIC_ATTRIBUTE_SENTRY_OP];
          }
          set op(e) {
            this.setAttribute(c.SEMANTIC_ATTRIBUTE_SENTRY_OP, e);
          }
          get origin() {
            return this._attributes[c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN];
          }
          set origin(e) {
            this.setAttribute(c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, e);
          }
          spanContext() {
            const { _spanId: e, _traceId: t, _sampled: n } = this;
            return {
              spanId: e,
              traceId: t,
              traceFlags: n ? m.TRACE_FLAG_SAMPLED : m.TRACE_FLAG_NONE,
            };
          }
          startChild(e) {
            const t = new h({
              ...e,
              parentSpanId: this._spanId,
              sampled: this._sampled,
              traceId: this._traceId,
            });
            (t.spanRecorder = this.spanRecorder),
              t.spanRecorder && t.spanRecorder.add(t);
            const n = (0, u.getRootSpan)(this);
            if (((t.transaction = n), r.DEBUG_BUILD && n)) {
              const s = `[Tracing] Starting '${(e && e.op) || "< unknown op >"}' span on transaction '${(0, m.spanToJSON)(t).description || "< unknown name >"}' (${n.spanContext().spanId}).`;
              o.logger.log(s), (this._logMessage = s);
            }
            return t;
          }
          setTag(e, t) {
            return (this.tags = { ...this.tags, [e]: t }), this;
          }
          setData(e, t) {
            return (this.data = { ...this.data, [e]: t }), this;
          }
          setAttribute(e, t) {
            void 0 === t
              ? delete this._attributes[e]
              : (this._attributes[e] = t);
          }
          setAttributes(e) {
            Object.keys(e).forEach((t) => this.setAttribute(t, e[t]));
          }
          setStatus(e) {
            return (this._status = e), this;
          }
          setHttpStatus(e) {
            return (0, d.setHttpStatus)(this, e), this;
          }
          setName(e) {
            this.updateName(e);
          }
          updateName(e) {
            return (this._name = e), this;
          }
          isSuccess() {
            return "ok" === this._status;
          }
          finish(e) {
            return this.end(e);
          }
          end(e) {
            if (this._endTime) return;
            const t = (0, u.getRootSpan)(this);
            if (r.DEBUG_BUILD && t && t.spanContext().spanId !== this._spanId) {
              const e = this._logMessage;
              e && o.logger.log(e.replace("Starting", "Finishing"));
            }
            this._endTime = (0, m.spanTimeInputToSeconds)(e);
          }
          toTraceparent() {
            return (0, m.spanToTraceHeader)(this);
          }
          toContext() {
            return (0, a.dropUndefinedKeys)({
              data: this._getData(),
              description: this._name,
              endTimestamp: this._endTime,
              op: this.op,
              parentSpanId: this._parentSpanId,
              sampled: this._sampled,
              spanId: this._spanId,
              startTimestamp: this._startTime,
              status: this._status,
              tags: this.tags,
              traceId: this._traceId,
            });
          }
          updateWithContext(e) {
            return (
              (this.data = e.data || {}),
              (this._name = e.name || e.description),
              (this._endTime = e.endTimestamp),
              (this.op = e.op),
              (this._parentSpanId = e.parentSpanId),
              (this._sampled = e.sampled),
              (this._spanId = e.spanId || this._spanId),
              (this._startTime = e.startTimestamp || this._startTime),
              (this._status = e.status),
              (this.tags = e.tags || {}),
              (this._traceId = e.traceId || this._traceId),
              this
            );
          }
          getTraceContext() {
            return (0, m.spanToTraceContext)(this);
          }
          getSpanJSON() {
            return (0, a.dropUndefinedKeys)({
              data: this._getData(),
              description: this._name,
              op: this._attributes[c.SEMANTIC_ATTRIBUTE_SENTRY_OP],
              parent_span_id: this._parentSpanId,
              span_id: this._spanId,
              start_timestamp: this._startTime,
              status: this._status,
              tags: Object.keys(this.tags).length > 0 ? this.tags : void 0,
              timestamp: this._endTime,
              trace_id: this._traceId,
              origin: this._attributes[c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
              _metrics_summary: (0, l.getMetricSummaryJsonForSpan)(this),
            });
          }
          isRecording() {
            return !this._endTime && !!this._sampled;
          }
          toJSON() {
            return this.getSpanJSON();
          }
          _getData() {
            const { data: e, _attributes: t } = this,
              n = Object.keys(e).length > 0,
              s = Object.keys(t).length > 0;
            if (n || s) return n && s ? { ...e, ...t } : n ? e : t;
          }
        }
      },
      (e, t, n) => {
        "use strict";
        var s;
        function i(e) {
          if (e < 400 && e >= 100) return "ok";
          if (e >= 400 && e < 500)
            switch (e) {
              case 401:
                return "unauthenticated";
              case 403:
                return "permission_denied";
              case 404:
                return "not_found";
              case 409:
                return "already_exists";
              case 413:
                return "failed_precondition";
              case 429:
                return "resource_exhausted";
              default:
                return "invalid_argument";
            }
          if (e >= 500 && e < 600)
            switch (e) {
              case 501:
                return "unimplemented";
              case 503:
                return "unavailable";
              case 504:
                return "deadline_exceeded";
              default:
                return "internal_error";
            }
          return "unknown_error";
        }
        n.r(t),
          n.d(t, {
            SpanStatus: () => s,
            getSpanStatusFromHttpCode: () => i,
            setHttpStatus: () => a,
            spanStatusfromHttpCode: () => o,
          }),
          (function (e) {
            e.Ok = "ok";
            e.DeadlineExceeded = "deadline_exceeded";
            e.Unauthenticated = "unauthenticated";
            e.PermissionDenied = "permission_denied";
            e.NotFound = "not_found";
            e.ResourceExhausted = "resource_exhausted";
            e.InvalidArgument = "invalid_argument";
            e.Unimplemented = "unimplemented";
            e.Unavailable = "unavailable";
            e.InternalError = "internal_error";
            e.UnknownError = "unknown_error";
            e.Cancelled = "cancelled";
            e.AlreadyExists = "already_exists";
            e.FailedPrecondition = "failed_precondition";
            e.Aborted = "aborted";
            e.OutOfRange = "out_of_range";
            e.DataLoss = "data_loss";
          })(s || (s = {}));
        const o = i;
        function a(e, t) {
          e.setTag("http.status_code", String(t)),
            e.setData("http.response.status_code", t);
          const n = i(t);
          "unknown_error" !== n && e.setStatus(n);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            getMetricSummaryJsonForSpan: () => r,
            updateMetricSummaryOnActiveSpan: () => l,
          });
        var s = n(5),
          i = n(53);
        let o;
        function a(e) {
          return o ? o.get(e) : void 0;
        }
        function r(e) {
          const t = a(e);
          if (!t) return;
          const n = {};
          for (const [, [e, i]] of t)
            n[e] || (n[e] = []), n[e].push((0, s.dropUndefinedKeys)(i));
          return n;
        }
        function l(e, t, n, s, r, l) {
          const c = (0, i.getActiveSpan)();
          if (c) {
            const i = a(c) || new Map(),
              u = `${e}:${t}@${s}`,
              m = i.get(l);
            if (m) {
              const [, e] = m;
              i.set(l, [
                u,
                {
                  min: Math.min(e.min, n),
                  max: Math.max(e.max, n),
                  count: (e.count += 1),
                  sum: (e.sum += n),
                  tags: e.tags,
                },
              ]);
            } else i.set(l, [u, { min: n, max: n, count: 1, sum: n, tags: r }]);
            o || (o = new WeakMap()), o.set(c, i);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            continueTrace: () => b,
            getActiveSpan: () => S,
            getCapturedScopesOnSpan: () => E,
            startActiveSpan: () => h,
            startInactiveSpan: () => f,
            startSpan: () => p,
            startSpanManual: () => g,
            trace: () => d,
          });
        var s = n(21),
          i = n(7),
          o = n(5),
          a = n(28),
          r = n(12),
          l = n(13),
          c = n(54),
          u = n(55),
          m = n(20);
        function d(e, t, n = () => {}, s = () => {}) {
          const i = (0, l.getCurrentHub)(),
            o = (0, r.getCurrentScope)(),
            a = o.getSpan(),
            u = _(e),
            m = y(i, a, u);
          return (
            o.setSpan(m),
            (0, c.handleCallbackErrors)(
              () => t(m),
              (e) => {
                m && m.setStatus("internal_error"), n(e, m);
              },
              () => {
                m && m.end(), o.setSpan(a), s();
              },
            )
          );
        }
        function p(e, t) {
          const n = _(e);
          return (0, l.runWithAsyncContext)(() =>
            (0, r.withScope)(e.scope, (s) => {
              const i = (0, l.getCurrentHub)(),
                o = s.getSpan(),
                a = e.onlyIfParent && !o ? void 0 : y(i, o, n);
              return (
                s.setSpan(a),
                (0, c.handleCallbackErrors)(
                  () => t(a),
                  () => {
                    if (a) {
                      const { status: e } = (0, m.spanToJSON)(a);
                      (e && "ok" !== e) || a.setStatus("internal_error");
                    }
                  },
                  () => a && a.end(),
                )
              );
            }),
          );
        }
        const h = p;
        function g(e, t) {
          const n = _(e);
          return (0, l.runWithAsyncContext)(() =>
            (0, r.withScope)(e.scope, (s) => {
              const i = (0, l.getCurrentHub)(),
                o = s.getSpan(),
                a = e.onlyIfParent && !o ? void 0 : y(i, o, n);
              function r() {
                a && a.end();
              }
              return (
                s.setSpan(a),
                (0, c.handleCallbackErrors)(
                  () => t(a, r),
                  () => {
                    if (a && a.isRecording()) {
                      const { status: e } = (0, m.spanToJSON)(a);
                      (e && "ok" !== e) || a.setStatus("internal_error");
                    }
                  },
                )
              );
            }),
          );
        }
        function f(e) {
          if (!(0, u.hasTracingEnabled)()) return;
          const t = _(e),
            n = (0, l.getCurrentHub)(),
            s = e.scope ? e.scope.getSpan() : S();
          if (e.onlyIfParent && !s) return;
          const i = (0, l.getIsolationScope)(),
            o = (0, r.getCurrentScope)();
          let a;
          if (s) a = s.startChild(t);
          else {
            const {
              traceId: e,
              dsc: s,
              parentSpanId: r,
              sampled: l,
            } = { ...i.getPropagationContext(), ...o.getPropagationContext() };
            a = n.startTransaction({
              traceId: e,
              parentSpanId: r,
              parentSampled: l,
              ...t,
              metadata: { dynamicSamplingContext: s, ...t.metadata },
            });
          }
          return k(a, o, i), a;
        }
        function S() {
          return (0, r.getCurrentScope)().getSpan();
        }
        const b = ({ sentryTrace: e, baggage: t }, n) => {
          const c = (0, r.getCurrentScope)(),
            {
              traceparentData: u,
              dynamicSamplingContext: m,
              propagationContext: d,
            } = (0, s.tracingContextFromHeaders)(e, t);
          c.setPropagationContext(d),
            a.DEBUG_BUILD &&
              u &&
              i.logger.log(`[Tracing] Continuing trace ${u.traceId}.`);
          const p = {
            ...u,
            metadata: (0, o.dropUndefinedKeys)({ dynamicSamplingContext: m }),
          };
          return n ? (0, l.runWithAsyncContext)(() => n(p)) : p;
        };
        function y(e, t, n) {
          if (!(0, u.hasTracingEnabled)()) return;
          const s = (0, l.getIsolationScope)(),
            i = (0, r.getCurrentScope)();
          let o;
          if (t) o = t.startChild(n);
          else {
            const {
              traceId: t,
              dsc: a,
              parentSpanId: r,
              sampled: l,
            } = { ...s.getPropagationContext(), ...i.getPropagationContext() };
            o = e.startTransaction({
              traceId: t,
              parentSpanId: r,
              parentSampled: l,
              ...n,
              metadata: { dynamicSamplingContext: a, ...n.metadata },
            });
          }
          return k(o, i, s), o;
        }
        function _(e) {
          if (e.startTime) {
            const t = { ...e };
            return (
              (t.startTimestamp = (0, m.spanTimeInputToSeconds)(e.startTime)),
              delete t.startTime,
              t
            );
          }
          return e;
        }
        const v = "_sentryScope",
          x = "_sentryIsolationScope";
        function k(e, t, n) {
          e &&
            ((0, o.addNonEnumerableProperty)(e, x, n),
            (0, o.addNonEnumerableProperty)(e, v, t));
        }
        function E(e) {
          return { scope: e[v], isolationScope: e[x] };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { handleCallbackErrors: () => i });
        var s = n(9);
        function i(e, t, n = () => {}) {
          let i;
          try {
            i = e();
          } catch (e) {
            throw (t(e), n(), e);
          }
          return (function (e, t, n) {
            if ((0, s.isThenable)(e))
              return e.then(
                (e) => (n(), e),
                (e) => {
                  throw (t(e), n(), e);
                },
              );
            return n(), e;
          })(i, t, n);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { hasTracingEnabled: () => i });
        var s = n(12);
        function i(e) {
          if ("boolean" == typeof __SENTRY_TRACING__ && !__SENTRY_TRACING__)
            return !1;
          const t = (0, s.getClient)(),
            n = e || (t && t.getOptions());
          return (
            !!n &&
            (n.enableTracing || "tracesSampleRate" in n || "tracesSampler" in n)
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { sampleTransaction: () => c });
        var s = n(7),
          i = n(9),
          o = n(28),
          a = n(40),
          r = n(55),
          l = n(20);
        function c(e, t, n) {
          if (!(0, r.hasTracingEnabled)(t)) return (e.sampled = !1), e;
          if (void 0 !== e.sampled)
            return (
              e.setAttribute(
                a.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
                Number(e.sampled),
              ),
              e
            );
          let c;
          return (
            "function" == typeof t.tracesSampler
              ? ((c = t.tracesSampler(n)),
                e.setAttribute(
                  a.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
                  Number(c),
                ))
              : void 0 !== n.parentSampled
                ? (c = n.parentSampled)
                : void 0 !== t.tracesSampleRate
                  ? ((c = t.tracesSampleRate),
                    e.setAttribute(
                      a.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
                      Number(c),
                    ))
                  : ((c = 1),
                    e.setAttribute(a.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, c)),
            (function (e) {
              if (
                (0, i.isNaN)(e) ||
                ("number" != typeof e && "boolean" != typeof e)
              )
                return (
                  o.DEBUG_BUILD &&
                    s.logger.warn(
                      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e)} of type ${JSON.stringify(typeof e)}.`,
                    ),
                  !1
                );
              if (e < 0 || e > 1)
                return (
                  o.DEBUG_BUILD &&
                    s.logger.warn(
                      `[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got ${e}.`,
                    ),
                  !1
                );
              return !0;
            })(c)
              ? c
                ? ((e.sampled = Math.random() < c),
                  e.sampled
                    ? (o.DEBUG_BUILD &&
                        s.logger.log(
                          `[Tracing] starting ${e.op} transaction - ${(0, l.spanToJSON)(e).description}`,
                        ),
                      e)
                    : (o.DEBUG_BUILD &&
                        s.logger.log(
                          `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(c)})`,
                        ),
                      e))
                : (o.DEBUG_BUILD &&
                    s.logger.log(
                      "[Tracing] Discarding transaction because " +
                        ("function" == typeof t.tracesSampler
                          ? "tracesSampler returned 0 or false"
                          : "a negative sampling decision was inherited or tracesSampleRate is set to 0"),
                    ),
                  (e.sampled = !1),
                  e)
              : (o.DEBUG_BUILD &&
                  s.logger.warn(
                    "[Tracing] Discarding transaction because of invalid sample rate.",
                  ),
                (e.sampled = !1),
                e)
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            IdleTransaction: () => d,
            IdleTransactionSpanRecorder: () => m,
            TRACING_DEFAULTS: () => c,
          });
        var s = n(7),
          i = n(17),
          o = n(28),
          a = n(20),
          r = n(50),
          l = n(49);
        const c = {
            idleTimeout: 1e3,
            finalTimeout: 3e4,
            heartbeatInterval: 5e3,
          },
          u = [
            "heartbeatFailed",
            "idleTimeout",
            "documentHidden",
            "finalTimeout",
            "externalFinish",
            "cancelled",
          ];
        class m extends r.SpanRecorder {
          constructor(e, t, n, s) {
            super(s),
              (this._pushActivity = e),
              (this._popActivity = t),
              (this.transactionSpanId = n);
          }
          add(e) {
            if (e.spanContext().spanId !== this.transactionSpanId) {
              const t = e.end;
              (e.end = (...n) => (
                this._popActivity(e.spanContext().spanId), t.apply(e, n)
              )),
                void 0 === (0, a.spanToJSON)(e).timestamp &&
                  this._pushActivity(e.spanContext().spanId);
            }
            super.add(e);
          }
        }
        class d extends l.Transaction {
          constructor(
            e,
            t,
            n = c.idleTimeout,
            i = c.finalTimeout,
            a = c.heartbeatInterval,
            r = !1,
            l = !1,
          ) {
            super(e, t),
              (this._idleHub = t),
              (this._idleTimeout = n),
              (this._finalTimeout = i),
              (this._heartbeatInterval = a),
              (this._onScope = r),
              (this.activities = {}),
              (this._heartbeatCounter = 0),
              (this._finished = !1),
              (this._idleTimeoutCanceledPermanently = !1),
              (this._beforeFinishCallbacks = []),
              (this._finishReason = u[4]),
              (this._autoFinishAllowed = !l),
              r &&
                (o.DEBUG_BUILD &&
                  s.logger.log(
                    `Setting idle transaction on scope. Span ID: ${this.spanContext().spanId}`,
                  ),
                t.getScope().setSpan(this)),
              l || this._restartIdleTimeout(),
              setTimeout(() => {
                this._finished ||
                  (this.setStatus("deadline_exceeded"),
                  (this._finishReason = u[3]),
                  this.end());
              }, this._finalTimeout);
          }
          end(e) {
            const t = (0, a.spanTimeInputToSeconds)(e);
            if (
              ((this._finished = !0),
              (this.activities = {}),
              "ui.action.click" === this.op &&
                this.setAttribute("finishReason", this._finishReason),
              this.spanRecorder)
            ) {
              o.DEBUG_BUILD &&
                s.logger.log(
                  "[Tracing] finishing IdleTransaction",
                  new Date(1e3 * t).toISOString(),
                  this.op,
                );
              for (const e of this._beforeFinishCallbacks) e(this, t);
              (this.spanRecorder.spans = this.spanRecorder.spans.filter((e) => {
                if (e.spanContext().spanId === this.spanContext().spanId)
                  return !0;
                (0, a.spanToJSON)(e).timestamp ||
                  (e.setStatus("cancelled"),
                  e.end(t),
                  o.DEBUG_BUILD &&
                    s.logger.log(
                      "[Tracing] cancelling span since transaction ended early",
                      JSON.stringify(e, void 0, 2),
                    ));
                const { start_timestamp: n, timestamp: i } = (0, a.spanToJSON)(
                    e,
                  ),
                  r = n && n < t,
                  l = (this._finalTimeout + this._idleTimeout) / 1e3,
                  c = i && n && i - n < l;
                if (o.DEBUG_BUILD) {
                  const t = JSON.stringify(e, void 0, 2);
                  r
                    ? c ||
                      s.logger.log(
                        "[Tracing] discarding Span since it finished after Transaction final timeout",
                        t,
                      )
                    : s.logger.log(
                        "[Tracing] discarding Span since it happened after Transaction was finished",
                        t,
                      );
                }
                return r && c;
              })),
                o.DEBUG_BUILD &&
                  s.logger.log("[Tracing] flushing IdleTransaction");
            } else
              o.DEBUG_BUILD &&
                s.logger.log("[Tracing] No active IdleTransaction");
            if (this._onScope) {
              const e = this._idleHub.getScope();
              e.getTransaction() === this && e.setSpan(void 0);
            }
            return super.end(e);
          }
          registerBeforeFinishCallback(e) {
            this._beforeFinishCallbacks.push(e);
          }
          initSpanRecorder(e) {
            if (!this.spanRecorder) {
              const t = (e) => {
                  this._finished || this._pushActivity(e);
                },
                n = (e) => {
                  this._finished || this._popActivity(e);
                };
              (this.spanRecorder = new m(t, n, this.spanContext().spanId, e)),
                o.DEBUG_BUILD && s.logger.log("Starting heartbeat"),
                this._pingHeartbeat();
            }
            this.spanRecorder.add(this);
          }
          cancelIdleTimeout(
            e,
            { restartOnChildSpanChange: t } = { restartOnChildSpanChange: !0 },
          ) {
            (this._idleTimeoutCanceledPermanently = !1 === t),
              this._idleTimeoutID &&
                (clearTimeout(this._idleTimeoutID),
                (this._idleTimeoutID = void 0),
                0 === Object.keys(this.activities).length &&
                  this._idleTimeoutCanceledPermanently &&
                  ((this._finishReason = u[5]), this.end(e)));
          }
          setFinishReason(e) {
            this._finishReason = e;
          }
          sendAutoFinishSignal() {
            this._autoFinishAllowed ||
              (o.DEBUG_BUILD &&
                s.logger.log(
                  "[Tracing] Received finish signal for idle transaction.",
                ),
              this._restartIdleTimeout(),
              (this._autoFinishAllowed = !0));
          }
          _restartIdleTimeout(e) {
            this.cancelIdleTimeout(),
              (this._idleTimeoutID = setTimeout(() => {
                this._finished ||
                  0 !== Object.keys(this.activities).length ||
                  ((this._finishReason = u[1]), this.end(e));
              }, this._idleTimeout));
          }
          _pushActivity(e) {
            this.cancelIdleTimeout(void 0, {
              restartOnChildSpanChange: !this._idleTimeoutCanceledPermanently,
            }),
              o.DEBUG_BUILD && s.logger.log(`[Tracing] pushActivity: ${e}`),
              (this.activities[e] = !0),
              o.DEBUG_BUILD &&
                s.logger.log(
                  "[Tracing] new activities count",
                  Object.keys(this.activities).length,
                );
          }
          _popActivity(e) {
            if (
              (this.activities[e] &&
                (o.DEBUG_BUILD && s.logger.log(`[Tracing] popActivity ${e}`),
                delete this.activities[e],
                o.DEBUG_BUILD &&
                  s.logger.log(
                    "[Tracing] new activities count",
                    Object.keys(this.activities).length,
                  )),
              0 === Object.keys(this.activities).length)
            ) {
              const e = (0, i.timestampInSeconds)();
              this._idleTimeoutCanceledPermanently
                ? this._autoFinishAllowed &&
                  ((this._finishReason = u[5]), this.end(e))
                : this._restartIdleTimeout(e + this._idleTimeout / 1e3);
            }
          }
          _beat() {
            if (this._finished) return;
            const e = Object.keys(this.activities).join("");
            e === this._prevHeartbeatString
              ? this._heartbeatCounter++
              : (this._heartbeatCounter = 1),
              (this._prevHeartbeatString = e),
              this._heartbeatCounter >= 3
                ? this._autoFinishAllowed &&
                  (o.DEBUG_BUILD &&
                    s.logger.log(
                      "[Tracing] Transaction finished because of no change for 3 heart beats",
                    ),
                  this.setStatus("deadline_exceeded"),
                  (this._finishReason = u[0]),
                  this.end())
                : this._pingHeartbeat();
          }
          _pingHeartbeat() {
            o.DEBUG_BUILD &&
              s.logger.log(
                `pinging Heartbeat -> current counter: ${this._heartbeatCounter}`,
              ),
              setTimeout(() => {
                this._beat();
              }, this._heartbeatInterval);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { registerErrorInstrumentation: () => c });
        var s = n(59),
          i = n(61),
          o = n(7),
          a = n(28),
          r = n(62);
        let l = !1;
        function c() {
          l ||
            ((l = !0),
            (0, s.addGlobalErrorInstrumentationHandler)(u),
            (0, i.addGlobalUnhandledRejectionInstrumentationHandler)(u));
        }
        function u() {
          const e = (0, r.getActiveTransaction)();
          if (e) {
            const t = "internal_error";
            a.DEBUG_BUILD &&
              o.logger.log(
                `[Tracing] Transaction: ${t} -> Global error occured`,
              ),
              e.setStatus(t);
          }
        }
        u.tag = "sentry_tracingErrorCallback";
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { addGlobalErrorInstrumentationHandler: () => a });
        var s = n(8),
          i = n(60);
        let o = null;
        function a(e) {
          const t = "error";
          (0, i.addHandler)(t, e), (0, i.maybeInstrument)(t, r);
        }
        function r() {
          (o = s.GLOBAL_OBJ.onerror),
            (s.GLOBAL_OBJ.onerror = function (e, t, n, s, a) {
              const r = { column: s, error: a, line: n, msg: e, url: t };
              return (
                (0, i.triggerHandlers)("error", r),
                !(!o || o.__SENTRY_LOADER__) && o.apply(this, arguments)
              );
            }),
            (s.GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addHandler: () => l,
            maybeInstrument: () => u,
            resetInstrumentationHandlers: () => c,
            triggerHandlers: () => m,
          });
        var s = n(6),
          i = n(7),
          o = n(32);
        const a = {},
          r = {};
        function l(e, t) {
          (a[e] = a[e] || []), a[e].push(t);
        }
        function c() {
          Object.keys(a).forEach((e) => {
            a[e] = void 0;
          });
        }
        function u(e, t) {
          r[e] || (t(), (r[e] = !0));
        }
        function m(e, t) {
          const n = e && a[e];
          if (n)
            for (const a of n)
              try {
                a(t);
              } catch (t) {
                s.DEBUG_BUILD &&
                  i.logger.error(
                    `Error while triggering instrumentation handler.\nType: ${e}\nName: ${(0, o.getFunctionName)(a)}\nError:`,
                    t,
                  );
              }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addGlobalUnhandledRejectionInstrumentationHandler: () => a,
          });
        var s = n(8),
          i = n(60);
        let o = null;
        function a(e) {
          const t = "unhandledrejection";
          (0, i.addHandler)(t, e), (0, i.maybeInstrument)(t, r);
        }
        function r() {
          (o = s.GLOBAL_OBJ.onunhandledrejection),
            (s.GLOBAL_OBJ.onunhandledrejection = function (e) {
              const t = e;
              return (
                (0, i.triggerHandlers)("unhandledrejection", t),
                !(o && !o.__SENTRY_LOADER__) || o.apply(this, arguments)
              );
            }),
            (s.GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            extractTraceparentData: () => r,
            getActiveTransaction: () => a,
            stripUrlQueryAndFragment: () => i.stripUrlQueryAndFragment,
          });
        var s = n(21),
          i = n(63),
          o = n(13);
        function a(e) {
          return (e || (0, o.getCurrentHub)()).getScope().getTransaction();
        }
        const r = s.extractTraceparentData;
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          if (!e) return {};
          const t = e.match(
            /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/,
          );
          if (!t) return {};
          const n = t[6] || "",
            s = t[8] || "";
          return {
            host: t[4],
            path: t[5],
            protocol: t[2],
            search: n,
            hash: s,
            relative: t[5] + n + s,
          };
        }
        function i(e) {
          return e.split(/[\?#]/, 1)[0];
        }
        function o(e) {
          return e.split(/\\?\//).filter((e) => e.length > 0 && "," !== e)
            .length;
        }
        function a(e) {
          const { protocol: t, host: n, path: s } = e;
          return `${t ? `${t}://` : ""}${
            (n &&
              n
                .replace(/^.*@/, "[filtered]:[filtered]@")
                .replace(/(:80)$/, "")
                .replace(/(:443)$/, "")) ||
            ""
          }${s}`;
        }
        n.r(t),
          n.d(t, {
            getNumberOfUrlSegments: () => o,
            getSanitizedUrlString: () => a,
            parseUrl: () => s,
            stripUrlQueryAndFragment: () => i,
          });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            DEFAULT_TRANSPORT_BUFFER_SIZE: () => u,
            createTransport: () => m,
          });
        var s = n(65),
          i = n(37),
          o = n(66),
          a = n(27),
          r = n(7),
          l = n(47),
          c = n(28);
        const u = 30;
        function m(e, t, n = (0, s.makePromiseBuffer)(e.bufferSize || u)) {
          let m = {};
          function p(s) {
            const u = [];
            if (
              ((0, i.forEachEnvelopeItem)(s, (t, n) => {
                const s = (0, i.envelopeItemTypeToDataCategory)(n);
                if ((0, o.isRateLimited)(m, s)) {
                  const i = d(t, n);
                  e.recordDroppedEvent("ratelimit_backoff", s, i);
                } else u.push(t);
              }),
              0 === u.length)
            )
              return (0, a.resolvedSyncPromise)();
            const p = (0, i.createEnvelope)(s[0], u),
              h = (t) => {
                (0, i.forEachEnvelopeItem)(p, (n, s) => {
                  const o = d(n, s);
                  e.recordDroppedEvent(
                    t,
                    (0, i.envelopeItemTypeToDataCategory)(s),
                    o,
                  );
                });
              };
            return n
              .add(() =>
                t({ body: (0, i.serializeEnvelope)(p, e.textEncoder) }).then(
                  (e) => (
                    void 0 !== e.statusCode &&
                      (e.statusCode < 200 || e.statusCode >= 300) &&
                      c.DEBUG_BUILD &&
                      r.logger.warn(
                        `Sentry responded with status code ${e.statusCode} to sent event.`,
                      ),
                    (m = (0, o.updateRateLimits)(m, e)),
                    e
                  ),
                  (e) => {
                    throw (h("network_error"), e);
                  },
                ),
              )
              .then(
                (e) => e,
                (e) => {
                  if (e instanceof l.SentryError)
                    return (
                      c.DEBUG_BUILD &&
                        r.logger.error(
                          "Skipped sending event because buffer is full.",
                        ),
                      h("queue_overflow"),
                      (0, a.resolvedSyncPromise)()
                    );
                  throw e;
                },
              );
          }
          return (
            (p.__sentry__baseTransport__ = !0),
            { send: p, flush: (e) => n.drain(e) }
          );
        }
        function d(e, t) {
          if ("event" === t || "transaction" === t)
            return Array.isArray(e) ? e[1] : void 0;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { makePromiseBuffer: () => o });
        var s = n(47),
          i = n(27);
        function o(e) {
          const t = [];
          function n(e) {
            return t.splice(t.indexOf(e), 1)[0];
          }
          return {
            $: t,
            add: function (o) {
              if (!(void 0 === e || t.length < e))
                return (0, i.rejectedSyncPromise)(
                  new s.SentryError(
                    "Not adding Promise because buffer limit was reached.",
                  ),
                );
              const a = o();
              return (
                -1 === t.indexOf(a) && t.push(a),
                a.then(() => n(a)).then(null, () => n(a).then(null, () => {})),
                a
              );
            },
            drain: function (e) {
              return new i.SyncPromise((n, s) => {
                let o = t.length;
                if (!o) return n(!0);
                const a = setTimeout(() => {
                  e && e > 0 && n(!1);
                }, e);
                t.forEach((e) => {
                  (0, i.resolvedSyncPromise)(e).then(() => {
                    --o || (clearTimeout(a), n(!0));
                  }, s);
                });
              });
            },
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            DEFAULT_RETRY_AFTER: () => s,
            disabledUntil: () => o,
            isRateLimited: () => a,
            parseRetryAfterHeader: () => i,
            updateRateLimits: () => r,
          });
        const s = 6e4;
        function i(e, t = Date.now()) {
          const n = parseInt(`${e}`, 10);
          if (!isNaN(n)) return 1e3 * n;
          const i = Date.parse(`${e}`);
          return isNaN(i) ? s : i - t;
        }
        function o(e, t) {
          return e[t] || e.all || 0;
        }
        function a(e, t, n = Date.now()) {
          return o(e, t) > n;
        }
        function r(e, { statusCode: t, headers: n }, s = Date.now()) {
          const o = { ...e },
            a = n && n["x-sentry-rate-limits"],
            r = n && n["retry-after"];
          if (a)
            for (const e of a.trim().split(",")) {
              const [t, n] = e.split(":", 2),
                i = parseInt(t, 10),
                a = 1e3 * (isNaN(i) ? 60 : i);
              if (n) for (const e of n.split(";")) o[e] = s + a;
              else o.all = s + a;
            }
          else r ? (o.all = s + i(r, s)) : 429 === t && (o.all = s + 6e4);
          return o;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            eventFromEnvelope: () => a,
            makeMultiplexedTransport: () => r,
          });
        var s = n(37),
          i = n(38),
          o = n(42);
        function a(e, t) {
          let n;
          return (
            (0, s.forEachEnvelopeItem)(
              e,
              (e, s) => (
                t.includes(s) && (n = Array.isArray(e) ? e[1] : void 0), !!n
              ),
            ),
            n
          );
        }
        function r(e, t) {
          return (n) => {
            const s = e(n),
              r = {};
            function l(t, s) {
              const l = s ? `${t}:${s}` : t;
              if (!r[l]) {
                const c = (0, i.dsnFromString)(t);
                if (!c) return;
                const u = (0, o.getEnvelopeEndpointWithUrlEncodedAuth)(c);
                r[l] = s
                  ? (function (e, t) {
                      return (n) => {
                        const s = e(n);
                        return {
                          send: async (e) => {
                            const n = a(e, [
                              "event",
                              "transaction",
                              "profile",
                              "replay_event",
                            ]);
                            return n && (n.release = t), s.send(e);
                          },
                          flush: (e) => s.flush(e),
                        };
                      };
                    })(
                      e,
                      s,
                    )({ ...n, url: u })
                  : e({ ...n, url: u });
              }
              return r[l];
            }
            return {
              send: async function (e) {
                const n = t({
                  envelope: e,
                  getEvent: function (t) {
                    const n = t && t.length ? t : ["event"];
                    return a(e, n);
                  },
                })
                  .map((e) =>
                    "string" == typeof e ? l(e, void 0) : l(e.dsn, e.release),
                  )
                  .filter((e) => !!e);
                return (
                  0 === n.length && n.push(s),
                  (await Promise.all(n.map((t) => t.send(e))))[0]
                );
              },
              flush: async function (e) {
                const t = [...Object.keys(r).map((e) => r[e]), s];
                return (await Promise.all(t.map((t) => t.flush(e)))).every(
                  (e) => e,
                );
              },
            };
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            distribution: () => m,
            gauge: () => p,
            increment: () => u,
            metrics: () => h,
            set: () => d,
          });
        var s = n(7),
          i = n(28),
          o = n(12),
          a = n(20),
          r = n(46),
          l = n(69);
        function c(e, t, n, r = {}) {
          const l = (0, o.getClient)(),
            c = (0, o.getCurrentScope)();
          if (l) {
            if (!l.metricsAggregator)
              return void (
                i.DEBUG_BUILD &&
                s.logger.warn(
                  "No metrics aggregator enabled. Please add the MetricsAggregator integration to use metrics APIs",
                )
              );
            const { unit: o, tags: u, timestamp: m } = r,
              { release: d, environment: p } = l.getOptions(),
              h = c.getTransaction(),
              g = {};
            d && (g.release = d),
              p && (g.environment = p),
              h && (g.transaction = (0, a.spanToJSON)(h).description || ""),
              i.DEBUG_BUILD &&
                s.logger.log(`Adding value of ${n} to ${e} metric ${t}`),
              l.metricsAggregator.add(e, t, n, o, { ...g, ...u }, m);
          }
        }
        function u(e, t = 1, n) {
          c(r.COUNTER_METRIC_TYPE, e, t, n);
        }
        function m(e, t, n) {
          c(r.DISTRIBUTION_METRIC_TYPE, e, t, n);
        }
        function d(e, t, n) {
          c(r.SET_METRIC_TYPE, e, t, n);
        }
        function p(e, t, n) {
          c(r.GAUGE_METRIC_TYPE, e, t, n);
        }
        const h = {
          increment: u,
          distribution: m,
          set: d,
          gauge: p,
          MetricsAggregator: l.MetricsAggregator,
          metricsAggregatorIntegration: l.metricsAggregatorIntegration,
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            MetricsAggregator: () => r,
            metricsAggregatorIntegration: () => a,
          });
        var s = n(34),
          i = n(70);
        const o = "MetricsAggregator",
          a = (0, s.defineIntegration)(() => ({
            name: o,
            setupOnce() {},
            setup(e) {
              e.metricsAggregator = new i.BrowserMetricsAggregator(e);
            },
          })),
          r = (0, s.convertIntegrationFnToClass)(o, a);
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { BrowserMetricsAggregator: () => l });
        var s = n(17),
          i = n(46),
          o = n(71),
          a = n(52),
          r = n(45);
        class l {
          constructor(e) {
            (this._client = e),
              (this._buckets = new Map()),
              (this._interval = setInterval(
                () => this.flush(),
                i.DEFAULT_BROWSER_FLUSH_INTERVAL,
              ));
          }
          add(e, t, n, l = "none", c = {}, u = (0, s.timestampInSeconds)()) {
            const m = Math.floor(u),
              d = t.replace(i.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_"),
              p = (0, r.sanitizeTags)(c),
              h = (0, r.getBucketKey)(e, d, l, p);
            let g = this._buckets.get(h);
            const f = g && e === i.SET_METRIC_TYPE ? g.metric.weight : 0;
            g
              ? (g.metric.add(n), g.timestamp < m && (g.timestamp = m))
              : ((g = {
                  metric: new o.METRIC_MAP[e](n),
                  timestamp: m,
                  metricType: e,
                  name: d,
                  unit: l,
                  tags: p,
                }),
                this._buckets.set(h, g));
            const S = "string" == typeof n ? g.metric.weight - f : n;
            (0, a.updateMetricSummaryOnActiveSpan)(e, d, S, l, c, h);
          }
          flush() {
            if (0 !== this._buckets.size) {
              if (this._client.captureAggregateMetrics) {
                const e = Array.from(this._buckets).map(([, e]) => e);
                this._client.captureAggregateMetrics(e);
              }
              this._buckets.clear();
            }
          }
          close() {
            clearInterval(this._interval), this.flush();
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            CounterMetric: () => o,
            DistributionMetric: () => r,
            GaugeMetric: () => a,
            METRIC_MAP: () => c,
            SetMetric: () => l,
          });
        var s = n(46),
          i = n(45);
        class o {
          constructor(e) {
            this._value = e;
          }
          get weight() {
            return 1;
          }
          add(e) {
            this._value += e;
          }
          toString() {
            return `${this._value}`;
          }
        }
        class a {
          constructor(e) {
            (this._last = e),
              (this._min = e),
              (this._max = e),
              (this._sum = e),
              (this._count = 1);
          }
          get weight() {
            return 5;
          }
          add(e) {
            (this._last = e),
              e < this._min && (this._min = e),
              e > this._max && (this._max = e),
              (this._sum += e),
              this._count++;
          }
          toString() {
            return `${this._last}:${this._min}:${this._max}:${this._sum}:${this._count}`;
          }
        }
        class r {
          constructor(e) {
            this._value = [e];
          }
          get weight() {
            return this._value.length;
          }
          add(e) {
            this._value.push(e);
          }
          toString() {
            return this._value.join(":");
          }
        }
        class l {
          constructor(e) {
            (this.first = e), (this._value = new Set([e]));
          }
          get weight() {
            return this._value.size;
          }
          add(e) {
            this._value.add(e);
          }
          toString() {
            return Array.from(this._value)
              .map((e) => ("string" == typeof e ? (0, i.simpleHash)(e) : e))
              .join(":");
          }
        }
        const c = {
          [s.COUNTER_METRIC_TYPE]: o,
          [s.GAUGE_METRIC_TYPE]: a,
          [s.DISTRIBUTION_METRIC_TYPE]: r,
          [s.SET_METRIC_TYPE]: l,
        };
      },
      (e, t, n) => {
        "use strict";
        function s(e, ...t) {
          const n = new String(String.raw(e, ...t));
          return (
            (n.__sentry_template_string__ = e
              .join("\0")
              .replace(/%/g, "%%")
              .replace(/\0/g, "%s")),
            (n.__sentry_template_values__ = t),
            n
          );
        }
        n.r(t), n.d(t, { parameterize: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { initAndBind: () => r, setCurrentClient: () => l });
        var s = n(7),
          i = n(28),
          o = n(12),
          a = n(13);
        function r(e, t) {
          !0 === t.debug &&
            (i.DEBUG_BUILD
              ? s.logger.enable()
              : (0, s.consoleSandbox)(() => {
                  console.warn(
                    "[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.",
                  );
                }));
          (0, o.getCurrentScope)().update(t.initialScope);
          const n = new e(t);
          l(n),
            (function (e) {
              e.init ? e.init() : e.setupIntegrations && e.setupIntegrations();
            })(n);
        }
        function l(e) {
          const t = (0, a.getCurrentHub)().getStackTop();
          (t.client = e), t.scope.setClient(e);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { setMeasurement: () => i });
        var s = n(62);
        function i(e, t, n) {
          const i = (0, s.getActiveTransaction)();
          i && i.setMeasurement(e, t, n);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            WINDOW: () => r,
            ignoreNextOnError: () => u,
            shouldIgnoreOnError: () => c,
            wrap: () => m,
          });
        var s = n(12),
          i = n(8),
          o = n(5),
          a = n(18);
        const r = i.GLOBAL_OBJ;
        let l = 0;
        function c() {
          return l > 0;
        }
        function u() {
          l++,
            setTimeout(() => {
              l--;
            });
        }
        function m(e, t = {}, n) {
          if ("function" != typeof e) return e;
          try {
            const t = e.__sentry_wrapped__;
            if (t) return t;
            if ((0, o.getOriginalFunction)(e)) return e;
          } catch (t) {
            return e;
          }
          const i = function () {
            const i = Array.prototype.slice.call(arguments);
            try {
              n && "function" == typeof n && n.apply(this, arguments);
              const s = i.map((e) => m(e, t));
              return e.apply(this, s);
            } catch (e) {
              throw (
                (u(),
                (0, s.withScope)((n) => {
                  n.addEventProcessor(
                    (e) => (
                      t.mechanism &&
                        ((0, a.addExceptionTypeValue)(e, void 0, void 0),
                        (0, a.addExceptionMechanism)(e, t.mechanism)),
                      (e.extra = { ...e.extra, arguments: i }),
                      e
                    ),
                  ),
                    (0, s.captureException)(e);
                }),
                e)
              );
            }
          };
          try {
            for (const t in e)
              Object.prototype.hasOwnProperty.call(e, t) && (i[t] = e[t]);
          } catch (e) {}
          (0, o.markFunctionWrapped)(i, e),
            (0, o.addNonEnumerableProperty)(e, "__sentry_wrapped__", i);
          try {
            Object.getOwnPropertyDescriptor(i, "name").configurable &&
              Object.defineProperty(i, "name", { get: () => e.name });
          } catch (e) {}
          return i;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { BrowserClient: () => p });
        var s = n(41),
          i = n(78),
          o = n(77),
          a = n(7),
          r = n(82),
          l = n(38),
          c = n(80),
          u = n(79),
          m = n(75),
          d = n(81);
        class p extends s.BaseClient {
          constructor(e) {
            const t = m.WINDOW.SENTRY_SDK_SOURCE || (0, o.getSDKSource)();
            (0, i.applySdkMetadata)(e, "browser", ["browser"], t),
              super(e),
              e.sendClientReports &&
                m.WINDOW.document &&
                m.WINDOW.document.addEventListener("visibilitychange", () => {
                  "hidden" === m.WINDOW.document.visibilityState &&
                    this._flushOutcomes();
                });
          }
          eventFromException(e, t) {
            return (0, u.eventFromException)(
              this._options.stackParser,
              e,
              t,
              this._options.attachStacktrace,
            );
          }
          eventFromMessage(e, t = "info", n) {
            return (0, u.eventFromMessage)(
              this._options.stackParser,
              e,
              t,
              n,
              this._options.attachStacktrace,
            );
          }
          captureUserFeedback(e) {
            if (!this._isEnabled())
              return void (
                c.DEBUG_BUILD &&
                a.logger.warn(
                  "SDK not enabled, will not capture user feedback.",
                )
              );
            const t = (0, d.createUserFeedbackEnvelope)(e, {
              metadata: this.getSdkMetadata(),
              dsn: this.getDsn(),
              tunnel: this.getOptions().tunnel,
            });
            this._sendEnvelope(t);
          }
          _prepareEvent(e, t, n) {
            return (
              (e.platform = e.platform || "javascript"),
              super._prepareEvent(e, t, n)
            );
          }
          _flushOutcomes() {
            const e = this._clearOutcomes();
            if (0 === e.length)
              return void (
                c.DEBUG_BUILD && a.logger.log("No outcomes to send")
              );
            if (!this._dsn)
              return void (
                c.DEBUG_BUILD &&
                a.logger.log("No dsn provided, will not send outcomes")
              );
            c.DEBUG_BUILD && a.logger.log("Sending outcomes:", e);
            const t = (0, r.createClientReportEnvelope)(
              e,
              this._options.tunnel && (0, l.dsnToString)(this._dsn),
            );
            this._sendEnvelope(t);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        function s() {
          return (
            "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ &&
            !!__SENTRY_BROWSER_BUNDLE__
          );
        }
        function i() {
          return "npm";
        }
        n.r(t), n.d(t, { getSDKSource: () => i, isBrowserBundle: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { applySdkMetadata: () => i });
        var s = n(14);
        function i(e, t, n = [t], i = "npm") {
          const o = e._metadata || {};
          o.sdk ||
            (o.sdk = {
              name: `sentry.javascript.${t}`,
              packages: n.map((e) => ({
                name: `${i}:@sentry/${e}`,
                version: s.SDK_VERSION,
              })),
              version: s.SDK_VERSION,
            }),
            (e._metadata = o);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            eventFromError: () => m,
            eventFromException: () => g,
            eventFromMessage: () => f,
            eventFromPlainObject: () => u,
            eventFromString: () => b,
            eventFromUnknownInput: () => S,
            exceptionFromError: () => c,
            parseStackFrames: () => d,
          });
        var s = n(12),
          i = n(9),
          o = n(30),
          a = n(18),
          r = n(27),
          l = n(5);
        function c(e, t) {
          const n = d(e, t),
            s = { type: t && t.name, value: h(t) };
          return (
            n.length && (s.stacktrace = { frames: n }),
            void 0 === s.type &&
              "" === s.value &&
              (s.value = "Unrecoverable error caught"),
            s
          );
        }
        function u(e, t, n, a) {
          const r = (0, s.getClient)(),
            l = r && r.getOptions().normalizeDepth,
            c = {
              exception: {
                values: [
                  {
                    type: (0, i.isEvent)(t)
                      ? t.constructor.name
                      : a
                        ? "UnhandledRejection"
                        : "Error",
                    value: y(t, { isUnhandledRejection: a }),
                  },
                ],
              },
              extra: { __serialized__: (0, o.normalizeToSize)(t, l) },
            };
          if (n) {
            const t = d(e, n);
            t.length && (c.exception.values[0].stacktrace = { frames: t });
          }
          return c;
        }
        function m(e, t) {
          return { exception: { values: [c(e, t)] } };
        }
        function d(e, t) {
          const n = t.stacktrace || t.stack || "",
            s = (function (e) {
              if (e) {
                if ("number" == typeof e.framesToPop) return e.framesToPop;
                if (p.test(e.message)) return 1;
              }
              return 0;
            })(t);
          try {
            return e(n, s);
          } catch (e) {}
          return [];
        }
        const p = /Minified React error #\d+;/i;
        function h(e) {
          const t = e && e.message;
          return t
            ? t.error && "string" == typeof t.error.message
              ? t.error.message
              : t
            : "No error message";
        }
        function g(e, t, n, s) {
          const i = S(e, t, (n && n.syntheticException) || void 0, s);
          return (
            (0, a.addExceptionMechanism)(i),
            (i.level = "error"),
            n && n.event_id && (i.event_id = n.event_id),
            (0, r.resolvedSyncPromise)(i)
          );
        }
        function f(e, t, n = "info", s, i) {
          const o = b(e, t, (s && s.syntheticException) || void 0, i);
          return (
            (o.level = n),
            s && s.event_id && (o.event_id = s.event_id),
            (0, r.resolvedSyncPromise)(o)
          );
        }
        function S(e, t, n, s, o) {
          let r;
          if ((0, i.isErrorEvent)(t) && t.error) {
            return m(e, t.error);
          }
          if ((0, i.isDOMError)(t) || (0, i.isDOMException)(t)) {
            const o = t;
            if ("stack" in t) r = m(e, t);
            else {
              const t =
                  o.name ||
                  ((0, i.isDOMError)(o) ? "DOMError" : "DOMException"),
                l = o.message ? `${t}: ${o.message}` : t;
              (r = b(e, l, n, s)), (0, a.addExceptionTypeValue)(r, l);
            }
            return (
              "code" in o &&
                (r.tags = { ...r.tags, "DOMException.code": `${o.code}` }),
              r
            );
          }
          if ((0, i.isError)(t)) return m(e, t);
          if ((0, i.isPlainObject)(t) || (0, i.isEvent)(t)) {
            return (
              (r = u(e, t, n, o)),
              (0, a.addExceptionMechanism)(r, { synthetic: !0 }),
              r
            );
          }
          return (
            (r = b(e, t, n, s)),
            (0, a.addExceptionTypeValue)(r, `${t}`, void 0),
            (0, a.addExceptionMechanism)(r, { synthetic: !0 }),
            r
          );
        }
        function b(e, t, n, s) {
          const o = {};
          if (s && n) {
            const s = d(e, n);
            s.length &&
              (o.exception = {
                values: [{ value: t, stacktrace: { frames: s } }],
              });
          }
          if ((0, i.isParameterizedString)(t)) {
            const {
              __sentry_template_string__: e,
              __sentry_template_values__: n,
            } = t;
            return (o.logentry = { message: e, params: n }), o;
          }
          return (o.message = t), o;
        }
        function y(e, { isUnhandledRejection: t }) {
          const n = (0, l.extractExceptionKeysForMessage)(e),
            s = t ? "promise rejection" : "exception";
          if ((0, i.isErrorEvent)(e))
            return `Event \`ErrorEvent\` captured as ${s} with message \`${e.message}\``;
          if ((0, i.isEvent)(e)) {
            return `Event \`${(function (e) {
              try {
                const t = Object.getPrototypeOf(e);
                return t ? t.constructor.name : void 0;
              } catch (e) {}
            })(e)}\` (type=${e.type}) captured as ${s}`;
          }
          return `Object captured as ${s} with keys: ${n}`;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { DEBUG_BUILD: () => s });
        const s = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { createUserFeedbackEnvelope: () => o });
        var s = n(38),
          i = n(37);
        function o(e, { metadata: t, tunnel: n, dsn: o }) {
          const a = {
              event_id: e.event_id,
              sent_at: new Date().toISOString(),
              ...(t &&
                t.sdk && { sdk: { name: t.sdk.name, version: t.sdk.version } }),
              ...(!!n && !!o && { dsn: (0, s.dsnToString)(o) }),
            },
            r = (function (e) {
              return [{ type: "user_report" }, e];
            })(e);
          return (0, i.createEnvelope)(a, [r]);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { createClientReportEnvelope: () => o });
        var s = n(37),
          i = n(17);
        function o(e, t, n) {
          const o = [
            { type: "client_report" },
            {
              timestamp: n || (0, i.dateTimestampInSeconds)(),
              discarded_events: e,
            },
          ];
          return (0, s.createEnvelope)(t ? { dsn: t } : {}, [o]);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { makeFetchTransport: () => a });
        var s = n(64),
          i = n(27),
          o = n(84);
        function a(e, t = (0, o.getNativeFetchImplementation)()) {
          let n = 0,
            a = 0;
          return (0, s.createTransport)(e, function (s) {
            const r = s.body.length;
            (n += r), a++;
            const l = {
              body: s.body,
              method: "POST",
              referrerPolicy: "origin",
              headers: e.headers,
              keepalive: n <= 6e4 && a < 15,
              ...e.fetchOptions,
            };
            try {
              return t(e.url, l).then(
                (e) => (
                  (n -= r),
                  a--,
                  {
                    statusCode: e.status,
                    headers: {
                      "x-sentry-rate-limits": e.headers.get(
                        "X-Sentry-Rate-Limits",
                      ),
                      "retry-after": e.headers.get("Retry-After"),
                    },
                  }
                ),
              );
            } catch (e) {
              return (
                (0, o.clearCachedFetchImplementation)(),
                (n -= r),
                a--,
                (0, i.rejectedSyncPromise)(e)
              );
            }
          });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            clearCachedFetchImplementation: () => c,
            getNativeFetchImplementation: () => l,
          });
        var s = n(85),
          i = n(7),
          o = n(80),
          a = n(75);
        let r;
        function l() {
          if (r) return r;
          if ((0, s.isNativeFetch)(a.WINDOW.fetch))
            return (r = a.WINDOW.fetch.bind(a.WINDOW));
          const e = a.WINDOW.document;
          let t = a.WINDOW.fetch;
          if (e && "function" == typeof e.createElement)
            try {
              const n = e.createElement("iframe");
              (n.hidden = !0), e.head.appendChild(n);
              const s = n.contentWindow;
              s && s.fetch && (t = s.fetch), e.head.removeChild(n);
            } catch (e) {
              o.DEBUG_BUILD &&
                i.logger.warn(
                  "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
                  e,
                );
            }
          return (r = t.bind(a.WINDOW));
        }
        function c() {
          r = void 0;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            isNativeFetch: () => u,
            supportsDOMError: () => r,
            supportsDOMException: () => l,
            supportsErrorEvent: () => a,
            supportsFetch: () => c,
            supportsNativeFetch: () => m,
            supportsReferrerPolicy: () => p,
            supportsReportingObserver: () => d,
          });
        var s = n(6),
          i = n(7);
        const o = (0, n(8).getGlobalObject)();
        function a() {
          try {
            return new ErrorEvent(""), !0;
          } catch (e) {
            return !1;
          }
        }
        function r() {
          try {
            return new DOMError(""), !0;
          } catch (e) {
            return !1;
          }
        }
        function l() {
          try {
            return new DOMException(""), !0;
          } catch (e) {
            return !1;
          }
        }
        function c() {
          if (!("fetch" in o)) return !1;
          try {
            return (
              new Headers(),
              new Request("http://www.example.com"),
              new Response(),
              !0
            );
          } catch (e) {
            return !1;
          }
        }
        function u(e) {
          return (
            e &&
            /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(
              e.toString(),
            )
          );
        }
        function m() {
          if ("string" == typeof EdgeRuntime) return !0;
          if (!c()) return !1;
          if (u(o.fetch)) return !0;
          let e = !1;
          const t = o.document;
          if (t && "function" == typeof t.createElement)
            try {
              const n = t.createElement("iframe");
              (n.hidden = !0),
                t.head.appendChild(n),
                n.contentWindow &&
                  n.contentWindow.fetch &&
                  (e = u(n.contentWindow.fetch)),
                t.head.removeChild(n);
            } catch (e) {
              s.DEBUG_BUILD &&
                i.logger.warn(
                  "Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ",
                  e,
                );
            }
          return e;
        }
        function d() {
          return "ReportingObserver" in o;
        }
        function p() {
          if (!c()) return !1;
          try {
            return new Request("_", { referrerPolicy: "origin" }), !0;
          } catch (e) {
            return !1;
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { makeXHRTransport: () => a });
        var s = n(64),
          i = n(27);
        const o = 4;
        function a(e) {
          return (0, s.createTransport)(e, function (t) {
            return new i.SyncPromise((n, s) => {
              const i = new XMLHttpRequest();
              (i.onerror = s),
                (i.onreadystatechange = () => {
                  i.readyState === o &&
                    n({
                      statusCode: i.status,
                      headers: {
                        "x-sentry-rate-limits": i.getResponseHeader(
                          "X-Sentry-Rate-Limits",
                        ),
                        "retry-after": i.getResponseHeader("Retry-After"),
                      },
                    });
                }),
                i.open("POST", e.url);
              for (const t in e.headers)
                Object.prototype.hasOwnProperty.call(e.headers, t) &&
                  i.setRequestHeader(t, e.headers[t]);
              i.send(t.body);
            });
          });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            chromeStackLineParser: () => l,
            defaultStackLineParsers: () => b,
            defaultStackParser: () => y,
            geckoStackLineParser: () => m,
            opera10StackLineParser: () => g,
            opera11StackLineParser: () => S,
            winjsStackLineParser: () => p,
          });
        var s = n(32);
        const i = "?";
        function o(e, t, n, s) {
          const i = { filename: e, function: t, in_app: !0 };
          return (
            void 0 !== n && (i.lineno = n), void 0 !== s && (i.colno = s), i
          );
        }
        const a =
            /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
          r = /\((\S*)(?::(\d+))(?::(\d+))\)/,
          l = [
            30,
            (e) => {
              const t = a.exec(e);
              if (t) {
                if (t[2] && 0 === t[2].indexOf("eval")) {
                  const e = r.exec(t[2]);
                  e && ((t[2] = e[1]), (t[3] = e[2]), (t[4] = e[3]));
                }
                const [e, n] = _(t[1] || i, t[2]);
                return o(n, e, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0);
              }
            },
          ],
          c =
            /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
          u = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
          m = [
            50,
            (e) => {
              const t = c.exec(e);
              if (t) {
                if (t[3] && t[3].indexOf(" > eval") > -1) {
                  const e = u.exec(t[3]);
                  e &&
                    ((t[1] = t[1] || "eval"),
                    (t[3] = e[1]),
                    (t[4] = e[2]),
                    (t[5] = ""));
                }
                let e = t[3],
                  n = t[1] || i;
                return (
                  ([n, e] = _(n, e)),
                  o(e, n, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0)
                );
              }
            },
          ],
          d =
            /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
          p = [
            40,
            (e) => {
              const t = d.exec(e);
              return t
                ? o(t[2], t[1] || i, +t[3], t[4] ? +t[4] : void 0)
                : void 0;
            },
          ],
          h = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i,
          g = [
            10,
            (e) => {
              const t = h.exec(e);
              return t ? o(t[2], t[3] || i, +t[1]) : void 0;
            },
          ],
          f =
            / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\(.*\))? in (.*):\s*$/i,
          S = [
            20,
            (e) => {
              const t = f.exec(e);
              return t ? o(t[5], t[3] || t[4] || i, +t[1], +t[2]) : void 0;
            },
          ],
          b = [l, m, p],
          y = (0, s.createStackParser)(...b),
          _ = (e, t) => {
            const n = -1 !== e.indexOf("safari-extension"),
              s = -1 !== e.indexOf("safari-web-extension");
            return n || s
              ? [
                  -1 !== e.indexOf("@") ? e.split("@")[0] : i,
                  n ? `safari-extension:${t}` : `safari-web-extension:${t}`,
                ]
              : [e, t];
          };
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            captureUserFeedback: () => M,
            defaultIntegrations: () => C,
            forceLoad: () => P,
            getDefaultIntegrations: () => w,
            init: () => I,
            onLoad: () => R,
            showReportDialog: () => A,
            wrap: () => D,
          });
        var s = n(35),
          i = n(4),
          o = n(34),
          a = n(73),
          r = n(13),
          l = n(42),
          c = n(12),
          u = n(32),
          m = n(85),
          d = n(7),
          p = n(95),
          h = n(76),
          g = n(80),
          f = n(75),
          S = n(90),
          b = n(101),
          y = n(98),
          _ = n(102),
          v = n(99),
          x = n(89),
          k = n(87),
          E = n(83),
          T = n(86);
        const C = [
          (0, s.inboundFiltersIntegration)(),
          (0, i.functionToStringIntegration)(),
          (0, x.browserApiErrorsIntegration)(),
          (0, S.breadcrumbsIntegration)(),
          (0, y.globalHandlersIntegration)(),
          (0, v.linkedErrorsIntegration)(),
          (0, b.dedupeIntegration)(),
          (0, _.httpContextIntegration)(),
        ];
        function w(e) {
          return [...C];
        }
        function I(e = {}) {
          void 0 === e.defaultIntegrations && (e.defaultIntegrations = w()),
            void 0 === e.release &&
              ("string" == typeof __SENTRY_RELEASE__ &&
                (e.release = __SENTRY_RELEASE__),
              f.WINDOW.SENTRY_RELEASE &&
                f.WINDOW.SENTRY_RELEASE.id &&
                (e.release = f.WINDOW.SENTRY_RELEASE.id)),
            void 0 === e.autoSessionTracking && (e.autoSessionTracking = !0),
            void 0 === e.sendClientReports && (e.sendClientReports = !0);
          const t = {
            ...e,
            stackParser: (0, u.stackParserFromStackParserOptions)(
              e.stackParser || k.defaultStackParser,
            ),
            integrations: (0, o.getIntegrationsToSetup)(e),
            transport:
              e.transport ||
              ((0, m.supportsFetch)()
                ? E.makeFetchTransport
                : T.makeXHRTransport),
          };
          (0, a.initAndBind)(h.BrowserClient, t),
            e.autoSessionTracking &&
              (function () {
                if (void 0 === f.WINDOW.document)
                  return void (
                    g.DEBUG_BUILD &&
                    d.logger.warn(
                      "Session tracking in non-browser environment with @sentry/browser is not supported.",
                    )
                  );
                (0, c.startSession)({ ignoreDuration: !0 }),
                  (0, c.captureSession)(),
                  (0, p.addHistoryInstrumentationHandler)(
                    ({ from: e, to: t }) => {
                      void 0 !== e &&
                        e !== t &&
                        ((0, c.startSession)({ ignoreDuration: !0 }),
                        (0, c.captureSession)());
                    },
                  );
              })();
        }
        const A = (e = {}, t = (0, r.getCurrentHub)()) => {
          if (!f.WINDOW.document)
            return void (
              g.DEBUG_BUILD &&
              d.logger.error(
                "Global document not defined in showReportDialog call",
              )
            );
          const { client: n, scope: s } = t.getStackTop(),
            i = e.dsn || (n && n.getDsn());
          if (!i)
            return void (
              g.DEBUG_BUILD &&
              d.logger.error("DSN not configured for showReportDialog call")
            );
          s && (e.user = { ...s.getUser(), ...e.user }),
            e.eventId || (e.eventId = t.lastEventId());
          const o = f.WINDOW.document.createElement("script");
          (o.async = !0),
            (o.crossOrigin = "anonymous"),
            (o.src = (0, l.getReportDialogEndpoint)(i, e)),
            e.onLoad && (o.onload = e.onLoad);
          const { onClose: a } = e;
          if (a) {
            const e = (t) => {
              if ("__sentry_reportdialog_closed__" === t.data)
                try {
                  a();
                } finally {
                  f.WINDOW.removeEventListener("message", e);
                }
            };
            f.WINDOW.addEventListener("message", e);
          }
          const c = f.WINDOW.document.head || f.WINDOW.document.body;
          c
            ? c.appendChild(o)
            : g.DEBUG_BUILD &&
              d.logger.error(
                "Not injecting report dialog. No injection point found in HTML",
              );
        };
        function P() {}
        function R(e) {
          e();
        }
        function D(e) {
          return (0, f.wrap)(e)();
        }
        function M(e) {
          const t = (0, c.getClient)();
          t && t.captureUserFeedback(e);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { TryCatch: () => u, browserApiErrorsIntegration: () => c });
        var s = n(34),
          i = n(5),
          o = n(32),
          a = n(75);
        const r = [
            "EventTarget",
            "Window",
            "Node",
            "ApplicationCache",
            "AudioTrackList",
            "BroadcastChannel",
            "ChannelMergerNode",
            "CryptoOperation",
            "EventSource",
            "FileReader",
            "HTMLUnknownElement",
            "IDBDatabase",
            "IDBRequest",
            "IDBTransaction",
            "KeyOperation",
            "MediaController",
            "MessagePort",
            "ModalWindow",
            "Notification",
            "SVGElementInstance",
            "Screen",
            "SharedWorker",
            "TextTrack",
            "TextTrackCue",
            "TextTrackList",
            "WebSocket",
            "WebSocketWorker",
            "Worker",
            "XMLHttpRequest",
            "XMLHttpRequestEventTarget",
            "XMLHttpRequestUpload",
          ],
          l = "TryCatch",
          c = (0, s.defineIntegration)((e = {}) => {
            const t = {
              XMLHttpRequest: !0,
              eventTarget: !0,
              requestAnimationFrame: !0,
              setInterval: !0,
              setTimeout: !0,
              ...e,
            };
            return {
              name: l,
              setupOnce() {
                t.setTimeout && (0, i.fill)(a.WINDOW, "setTimeout", m),
                  t.setInterval && (0, i.fill)(a.WINDOW, "setInterval", m),
                  t.requestAnimationFrame &&
                    (0, i.fill)(a.WINDOW, "requestAnimationFrame", d),
                  t.XMLHttpRequest &&
                    "XMLHttpRequest" in a.WINDOW &&
                    (0, i.fill)(XMLHttpRequest.prototype, "send", p);
                const e = t.eventTarget;
                if (e) {
                  (Array.isArray(e) ? e : r).forEach(h);
                }
              },
            };
          }),
          u = (0, s.convertIntegrationFnToClass)(l, c);
        function m(e) {
          return function (...t) {
            const n = t[0];
            return (
              (t[0] = (0, a.wrap)(n, {
                mechanism: {
                  data: { function: (0, o.getFunctionName)(e) },
                  handled: !1,
                  type: "instrument",
                },
              })),
              e.apply(this, t)
            );
          };
        }
        function d(e) {
          return function (t) {
            return e.apply(this, [
              (0, a.wrap)(t, {
                mechanism: {
                  data: {
                    function: "requestAnimationFrame",
                    handler: (0, o.getFunctionName)(e),
                  },
                  handled: !1,
                  type: "instrument",
                },
              }),
            ]);
          };
        }
        function p(e) {
          return function (...t) {
            const n = this;
            return (
              ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(
                (e) => {
                  e in n &&
                    "function" == typeof n[e] &&
                    (0, i.fill)(n, e, function (t) {
                      const n = {
                          mechanism: {
                            data: {
                              function: e,
                              handler: (0, o.getFunctionName)(t),
                            },
                            handled: !1,
                            type: "instrument",
                          },
                        },
                        s = (0, i.getOriginalFunction)(t);
                      return (
                        s &&
                          (n.mechanism.data.handler = (0, o.getFunctionName)(
                            s,
                          )),
                        (0, a.wrap)(t, n)
                      );
                    });
                },
              ),
              e.apply(this, t)
            );
          };
        }
        function h(e) {
          const t = a.WINDOW,
            n = t[e] && t[e].prototype;
          n &&
            n.hasOwnProperty &&
            n.hasOwnProperty("addEventListener") &&
            ((0, i.fill)(n, "addEventListener", function (t) {
              return function (n, s, i) {
                try {
                  "function" == typeof s.handleEvent &&
                    (s.handleEvent = (0, a.wrap)(s.handleEvent, {
                      mechanism: {
                        data: {
                          function: "handleEvent",
                          handler: (0, o.getFunctionName)(s),
                          target: e,
                        },
                        handled: !1,
                        type: "instrument",
                      },
                    }));
                } catch (e) {}
                return t.apply(this, [
                  n,
                  (0, a.wrap)(s, {
                    mechanism: {
                      data: {
                        function: "addEventListener",
                        handler: (0, o.getFunctionName)(s),
                        target: e,
                      },
                      handled: !1,
                      type: "instrument",
                    },
                  }),
                  i,
                ]);
              };
            }),
            (0, i.fill)(n, "removeEventListener", function (e) {
              return function (t, n, s) {
                const i = n;
                try {
                  const n = i && i.__sentry_wrapped__;
                  n && e.call(this, t, n, s);
                } catch (e) {}
                return e.call(this, t, i, s);
              };
            }));
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { Breadcrumbs: () => v, breadcrumbsIntegration: () => _ });
        var s = n(34),
          i = n(12),
          o = n(91),
          a = n(92),
          r = n(93),
          l = n(94),
          c = n(95),
          u = n(18),
          m = n(7),
          d = n(10),
          p = n(97),
          h = n(11),
          g = n(63),
          f = n(80),
          S = n(75);
        const b = 1024,
          y = "Breadcrumbs",
          _ = (0, s.defineIntegration)((e = {}) => {
            const t = {
              console: !0,
              dom: !0,
              fetch: !0,
              history: !0,
              sentry: !0,
              xhr: !0,
              ...e,
            };
            return {
              name: y,
              setupOnce() {},
              setup(e) {
                t.console &&
                  (0, o.addConsoleInstrumentationHandler)(
                    (function (e) {
                      return function (t) {
                        if ((0, i.getClient)() !== e) return;
                        const n = {
                          category: "console",
                          data: { arguments: t.args, logger: "console" },
                          level: (0, p.severityLevelFromString)(t.level),
                          message: (0, h.safeJoin)(t.args, " "),
                        };
                        if ("assert" === t.level) {
                          if (!1 !== t.args[0]) return;
                          (n.message = `Assertion failed: ${(0, h.safeJoin)(t.args.slice(1), " ") || "console.assert"}`),
                            (n.data.arguments = t.args.slice(1));
                        }
                        (0, i.addBreadcrumb)(n, {
                          input: t.args,
                          level: t.level,
                        });
                      };
                    })(e),
                  ),
                  t.dom &&
                    (0, a.addClickKeypressInstrumentationHandler)(
                      (function (e, t) {
                        return function (n) {
                          if ((0, i.getClient)() !== e) return;
                          let s,
                            o,
                            a =
                              "object" == typeof t
                                ? t.serializeAttribute
                                : void 0,
                            r =
                              "object" == typeof t &&
                              "number" == typeof t.maxStringLength
                                ? t.maxStringLength
                                : void 0;
                          r &&
                            r > b &&
                            (f.DEBUG_BUILD &&
                              m.logger.warn(
                                `\`dom.maxStringLength\` cannot exceed 1024, but a value of ${r} was configured. Sentry will use 1024 instead.`,
                              ),
                            (r = b)),
                            "string" == typeof a && (a = [a]);
                          try {
                            const e = n.event,
                              t = (function (e) {
                                return !!e && !!e.target;
                              })(e)
                                ? e.target
                                : e;
                            (s = (0, d.htmlTreeAsString)(t, {
                              keyAttrs: a,
                              maxStringLength: r,
                            })),
                              (o = (0, d.getComponentName)(t));
                          } catch (e) {
                            s = "<unknown>";
                          }
                          if (0 === s.length) return;
                          const l = { category: `ui.${n.name}`, message: s };
                          o && (l.data = { "ui.component_name": o }),
                            (0, i.addBreadcrumb)(l, {
                              event: n.event,
                              name: n.name,
                              global: n.global,
                            });
                        };
                      })(e, t.dom),
                    ),
                  t.xhr &&
                    (0, r.addXhrInstrumentationHandler)(
                      (function (e) {
                        return function (t) {
                          if ((0, i.getClient)() !== e) return;
                          const { startTimestamp: n, endTimestamp: s } = t,
                            o = t.xhr[r.SENTRY_XHR_DATA_KEY];
                          if (!n || !s || !o) return;
                          const {
                              method: a,
                              url: l,
                              status_code: c,
                              body: u,
                            } = o,
                            m = { method: a, url: l, status_code: c },
                            d = {
                              xhr: t.xhr,
                              input: u,
                              startTimestamp: n,
                              endTimestamp: s,
                            };
                          (0, i.addBreadcrumb)(
                            { category: "xhr", data: m, type: "http" },
                            d,
                          );
                        };
                      })(e),
                    ),
                  t.fetch &&
                    (0, l.addFetchInstrumentationHandler)(
                      (function (e) {
                        return function (t) {
                          if ((0, i.getClient)() !== e) return;
                          const { startTimestamp: n, endTimestamp: s } = t;
                          if (
                            s &&
                            (!t.fetchData.url.match(/sentry_key/) ||
                              "POST" !== t.fetchData.method)
                          )
                            if (t.error) {
                              const e = t.fetchData,
                                o = {
                                  data: t.error,
                                  input: t.args,
                                  startTimestamp: n,
                                  endTimestamp: s,
                                };
                              (0, i.addBreadcrumb)(
                                {
                                  category: "fetch",
                                  data: e,
                                  level: "error",
                                  type: "http",
                                },
                                o,
                              );
                            } else {
                              const e = t.response,
                                o = {
                                  ...t.fetchData,
                                  status_code: e && e.status,
                                },
                                a = {
                                  input: t.args,
                                  response: e,
                                  startTimestamp: n,
                                  endTimestamp: s,
                                };
                              (0, i.addBreadcrumb)(
                                { category: "fetch", data: o, type: "http" },
                                a,
                              );
                            }
                        };
                      })(e),
                    ),
                  t.history &&
                    (0, c.addHistoryInstrumentationHandler)(
                      (function (e) {
                        return function (t) {
                          if ((0, i.getClient)() !== e) return;
                          let n = t.from,
                            s = t.to;
                          const o = (0, g.parseUrl)(S.WINDOW.location.href);
                          let a = n ? (0, g.parseUrl)(n) : void 0;
                          const r = (0, g.parseUrl)(s);
                          (a && a.path) || (a = o),
                            o.protocol === r.protocol &&
                              o.host === r.host &&
                              (s = r.relative),
                            o.protocol === a.protocol &&
                              o.host === a.host &&
                              (n = a.relative),
                            (0, i.addBreadcrumb)({
                              category: "navigation",
                              data: { from: n, to: s },
                            });
                        };
                      })(e),
                    ),
                  t.sentry &&
                    e.on &&
                    e.on(
                      "beforeSendEvent",
                      (function (e) {
                        return function (t) {
                          (0, i.getClient)() === e &&
                            (0, i.addBreadcrumb)(
                              {
                                category:
                                  "sentry." +
                                  ("transaction" === t.type
                                    ? "transaction"
                                    : "event"),
                                event_id: t.event_id,
                                level: t.level,
                                message: (0, u.getEventDescription)(t),
                              },
                              { event: t },
                            );
                        };
                      })(e),
                    );
              },
            };
          }),
          v = (0, s.convertIntegrationFnToClass)(y, _);
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { addConsoleInstrumentationHandler: () => r });
        var s = n(7),
          i = n(5),
          o = n(8),
          a = n(60);
        function r(e) {
          const t = "console";
          (0, a.addHandler)(t, e), (0, a.maybeInstrument)(t, l);
        }
        function l() {
          "console" in o.GLOBAL_OBJ &&
            s.CONSOLE_LEVELS.forEach(function (e) {
              e in o.GLOBAL_OBJ.console &&
                (0, i.fill)(o.GLOBAL_OBJ.console, e, function (t) {
                  return (
                    (s.originalConsoleMethods[e] = t),
                    function (...t) {
                      const n = { args: t, level: e };
                      (0, a.triggerHandlers)("console", n);
                      const i = s.originalConsoleMethods[e];
                      i && i.apply(o.GLOBAL_OBJ.console, t);
                    }
                  );
                });
            });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addClickKeypressInstrumentationHandler: () => d,
            instrumentDOM: () => p,
          });
        var s = n(18),
          i = n(5),
          o = n(8),
          a = n(60);
        const r = o.GLOBAL_OBJ,
          l = 1e3;
        let c, u, m;
        function d(e) {
          (0, a.addHandler)("dom", e), (0, a.maybeInstrument)("dom", p);
        }
        function p() {
          if (!r.document) return;
          const e = a.triggerHandlers.bind(null, "dom"),
            t = h(e, !0);
          r.document.addEventListener("click", t, !1),
            r.document.addEventListener("keypress", t, !1),
            ["EventTarget", "Node"].forEach((t) => {
              const n = r[t] && r[t].prototype;
              n &&
                n.hasOwnProperty &&
                n.hasOwnProperty("addEventListener") &&
                ((0, i.fill)(n, "addEventListener", function (t) {
                  return function (n, s, i) {
                    if ("click" === n || "keypress" == n)
                      try {
                        const s = this,
                          o = (s.__sentry_instrumentation_handlers__ =
                            s.__sentry_instrumentation_handlers__ || {}),
                          a = (o[n] = o[n] || { refCount: 0 });
                        if (!a.handler) {
                          const s = h(e);
                          (a.handler = s), t.call(this, n, s, i);
                        }
                        a.refCount++;
                      } catch (e) {}
                    return t.call(this, n, s, i);
                  };
                }),
                (0, i.fill)(n, "removeEventListener", function (e) {
                  return function (t, n, s) {
                    if ("click" === t || "keypress" == t)
                      try {
                        const n = this,
                          i = n.__sentry_instrumentation_handlers__ || {},
                          o = i[t];
                        o &&
                          (o.refCount--,
                          o.refCount <= 0 &&
                            (e.call(this, t, o.handler, s),
                            (o.handler = void 0),
                            delete i[t]),
                          0 === Object.keys(i).length &&
                            delete n.__sentry_instrumentation_handlers__);
                      } catch (e) {}
                    return e.call(this, t, n, s);
                  };
                }));
            });
        }
        function h(e, t = !1) {
          return (n) => {
            if (!n || n._sentryCaptured) return;
            const o = (function (e) {
              try {
                return e.target;
              } catch (e) {
                return null;
              }
            })(n);
            if (
              (function (e, t) {
                return (
                  "keypress" === e &&
                  (!t ||
                    !t.tagName ||
                    ("INPUT" !== t.tagName &&
                      "TEXTAREA" !== t.tagName &&
                      !t.isContentEditable))
                );
              })(n.type, o)
            )
              return;
            (0, i.addNonEnumerableProperty)(n, "_sentryCaptured", !0),
              o &&
                !o._sentryId &&
                (0, i.addNonEnumerableProperty)(o, "_sentryId", (0, s.uuid4)());
            const a = "keypress" === n.type ? "input" : n.type;
            if (
              !(function (e) {
                if (e.type !== u) return !1;
                try {
                  if (!e.target || e.target._sentryId !== m) return !1;
                } catch (e) {}
                return !0;
              })(n)
            ) {
              e({ event: n, name: a, global: t }),
                (u = n.type),
                (m = o ? o._sentryId : void 0);
            }
            clearTimeout(c),
              (c = r.setTimeout(() => {
                (m = void 0), (u = void 0);
              }, l));
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            SENTRY_XHR_DATA_KEY: () => l,
            addXhrInstrumentationHandler: () => c,
            instrumentXHR: () => u,
          });
        var s = n(9),
          i = n(5),
          o = n(8),
          a = n(60);
        const r = o.GLOBAL_OBJ,
          l = "__sentry_xhr_v3__";
        function c(e) {
          (0, a.addHandler)("xhr", e), (0, a.maybeInstrument)("xhr", u);
        }
        function u() {
          if (!r.XMLHttpRequest) return;
          const e = XMLHttpRequest.prototype;
          (0, i.fill)(e, "open", function (e) {
            return function (...t) {
              const n = Date.now(),
                o = (0, s.isString)(t[0]) ? t[0].toUpperCase() : void 0,
                r = (function (e) {
                  if ((0, s.isString)(e)) return e;
                  try {
                    return e.toString();
                  } catch (e) {}
                  return;
                })(t[1]);
              if (!o || !r) return e.apply(this, t);
              (this[l] = { method: o, url: r, request_headers: {} }),
                "POST" === o &&
                  r.match(/sentry_key/) &&
                  (this.__sentry_own_request__ = !0);
              const c = () => {
                const e = this[l];
                if (e && 4 === this.readyState) {
                  try {
                    e.status_code = this.status;
                  } catch (e) {}
                  const t = {
                    args: [o, r],
                    endTimestamp: Date.now(),
                    startTimestamp: n,
                    xhr: this,
                  };
                  (0, a.triggerHandlers)("xhr", t);
                }
              };
              return (
                "onreadystatechange" in this &&
                "function" == typeof this.onreadystatechange
                  ? (0, i.fill)(this, "onreadystatechange", function (e) {
                      return function (...t) {
                        return c(), e.apply(this, t);
                      };
                    })
                  : this.addEventListener("readystatechange", c),
                (0, i.fill)(this, "setRequestHeader", function (e) {
                  return function (...t) {
                    const [n, i] = t,
                      o = this[l];
                    return (
                      o &&
                        (0, s.isString)(n) &&
                        (0, s.isString)(i) &&
                        (o.request_headers[n.toLowerCase()] = i),
                      e.apply(this, t)
                    );
                  };
                }),
                e.apply(this, t)
              );
            };
          }),
            (0, i.fill)(e, "send", function (e) {
              return function (...t) {
                const n = this[l];
                if (!n) return e.apply(this, t);
                void 0 !== t[0] && (n.body = t[0]);
                const s = {
                  args: [n.method, n.url],
                  startTimestamp: Date.now(),
                  xhr: this,
                };
                return (0, a.triggerHandlers)("xhr", s), e.apply(this, t);
              };
            });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addFetchInstrumentationHandler: () => r,
            parseFetchArgs: () => m,
          });
        var s = n(5),
          i = n(85),
          o = n(8),
          a = n(60);
        function r(e) {
          const t = "fetch";
          (0, a.addHandler)(t, e), (0, a.maybeInstrument)(t, l);
        }
        function l() {
          (0, i.supportsNativeFetch)() &&
            (0, s.fill)(o.GLOBAL_OBJ, "fetch", function (e) {
              return function (...t) {
                const { method: n, url: s } = m(t),
                  i = {
                    args: t,
                    fetchData: { method: n, url: s },
                    startTimestamp: Date.now(),
                  };
                return (
                  (0, a.triggerHandlers)("fetch", { ...i }),
                  e.apply(o.GLOBAL_OBJ, t).then(
                    (e) => {
                      const t = { ...i, endTimestamp: Date.now(), response: e };
                      return (0, a.triggerHandlers)("fetch", t), e;
                    },
                    (e) => {
                      const t = { ...i, endTimestamp: Date.now(), error: e };
                      throw ((0, a.triggerHandlers)("fetch", t), e);
                    },
                  )
                );
              };
            });
        }
        function c(e, t) {
          return !!e && "object" == typeof e && !!e[t];
        }
        function u(e) {
          return "string" == typeof e
            ? e
            : e
              ? c(e, "url")
                ? e.url
                : e.toString
                  ? e.toString()
                  : ""
              : "";
        }
        function m(e) {
          if (0 === e.length) return { method: "GET", url: "" };
          if (2 === e.length) {
            const [t, n] = e;
            return {
              url: u(t),
              method: c(n, "method") ? String(n.method).toUpperCase() : "GET",
            };
          }
          const t = e[0];
          return {
            url: u(t),
            method: c(t, "method") ? String(t.method).toUpperCase() : "GET",
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { addHistoryInstrumentationHandler: () => c });
        var s = n(5),
          i = n(8),
          o = n(96),
          a = n(60);
        const r = i.GLOBAL_OBJ;
        let l;
        function c(e) {
          const t = "history";
          (0, a.addHandler)(t, e), (0, a.maybeInstrument)(t, u);
        }
        function u() {
          if (!(0, o.supportsHistory)()) return;
          const e = r.onpopstate;
          function t(e) {
            return function (...t) {
              const n = t.length > 2 ? t[2] : void 0;
              if (n) {
                const e = l,
                  t = String(n);
                l = t;
                const s = { from: e, to: t };
                (0, a.triggerHandlers)("history", s);
              }
              return e.apply(this, t);
            };
          }
          (r.onpopstate = function (...t) {
            const n = r.location.href,
              s = l;
            l = n;
            const i = { from: s, to: n };
            if (((0, a.triggerHandlers)("history", i), e))
              try {
                return e.apply(this, t);
              } catch (e) {}
          }),
            (0, s.fill)(r.history, "pushState", t),
            (0, s.fill)(r.history, "replaceState", t);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { supportsHistory: () => i });
        const s = (0, n(8).getGlobalObject)();
        function i() {
          const e = s.chrome,
            t = e && e.app && e.app.runtime,
            n =
              "history" in s &&
              !!s.history.pushState &&
              !!s.history.replaceState;
          return !t && n;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            severityFromString: () => i,
            severityLevelFromString: () => o,
            validSeverityLevels: () => s,
          });
        const s = ["fatal", "error", "warning", "log", "info", "debug"];
        function i(e) {
          return o(e);
        }
        function o(e) {
          return "warn" === e ? "warning" : s.includes(e) ? e : "log";
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            GlobalHandlers: () => g,
            globalHandlersIntegration: () => h,
          });
        var s = n(34),
          i = n(12),
          o = n(59),
          a = n(9),
          r = n(61),
          l = n(10),
          c = n(7),
          u = n(80),
          m = n(79),
          d = n(75);
        const p = "GlobalHandlers",
          h = (0, s.defineIntegration)((e = {}) => {
            const t = { onerror: !0, onunhandledrejection: !0, ...e };
            return {
              name: p,
              setupOnce() {
                Error.stackTraceLimit = 50;
              },
              setup(e) {
                t.onerror &&
                  (!(function (e) {
                    (0, o.addGlobalErrorInstrumentationHandler)((t) => {
                      const { stackParser: n, attachStacktrace: s } = b();
                      if (
                        (0, i.getClient)() !== e ||
                        (0, d.shouldIgnoreOnError)()
                      )
                        return;
                      const {
                          msg: o,
                          url: r,
                          line: l,
                          column: c,
                          error: u,
                        } = t,
                        p =
                          void 0 === u && (0, a.isString)(o)
                            ? (function (e, t, n, s) {
                                const i =
                                  /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
                                let o = (0, a.isErrorEvent)(e) ? e.message : e,
                                  r = "Error";
                                const l = o.match(i);
                                l && ((r = l[1]), (o = l[2]));
                                const c = {
                                  exception: {
                                    values: [{ type: r, value: o }],
                                  },
                                };
                                return f(c, t, n, s);
                              })(o, r, l, c)
                            : f(
                                (0, m.eventFromUnknownInput)(
                                  n,
                                  u || o,
                                  void 0,
                                  s,
                                  !1,
                                ),
                                r,
                                l,
                                c,
                              );
                      (p.level = "error"),
                        (0, i.captureEvent)(p, {
                          originalException: u,
                          mechanism: { handled: !1, type: "onerror" },
                        });
                    });
                  })(e),
                  S("onerror")),
                  t.onunhandledrejection &&
                    (!(function (e) {
                      (0, r.addGlobalUnhandledRejectionInstrumentationHandler)(
                        (t) => {
                          const { stackParser: n, attachStacktrace: s } = b();
                          if (
                            (0, i.getClient)() !== e ||
                            (0, d.shouldIgnoreOnError)()
                          )
                            return;
                          const o = (function (e) {
                              if ((0, a.isPrimitive)(e)) return e;
                              const t = e;
                              try {
                                if ("reason" in t) return t.reason;
                                if ("detail" in t && "reason" in t.detail)
                                  return t.detail.reason;
                              } catch (e) {}
                              return e;
                            })(t),
                            r = (0, a.isPrimitive)(o)
                              ? {
                                  exception: {
                                    values: [
                                      {
                                        type: "UnhandledRejection",
                                        value: `Non-Error promise rejection captured with value: ${String(o)}`,
                                      },
                                    ],
                                  },
                                }
                              : (0, m.eventFromUnknownInput)(
                                  n,
                                  o,
                                  void 0,
                                  s,
                                  !0,
                                );
                          (r.level = "error"),
                            (0, i.captureEvent)(r, {
                              originalException: o,
                              mechanism: {
                                handled: !1,
                                type: "onunhandledrejection",
                              },
                            });
                        },
                      );
                    })(e),
                    S("onunhandledrejection"));
              },
            };
          }),
          g = (0, s.convertIntegrationFnToClass)(p, h);
        function f(e, t, n, s) {
          const i = (e.exception = e.exception || {}),
            o = (i.values = i.values || []),
            r = (o[0] = o[0] || {}),
            c = (r.stacktrace = r.stacktrace || {}),
            u = (c.frames = c.frames || []),
            m = isNaN(parseInt(s, 10)) ? void 0 : s,
            d = isNaN(parseInt(n, 10)) ? void 0 : n,
            p =
              (0, a.isString)(t) && t.length > 0 ? t : (0, l.getLocationHref)();
          return (
            0 === u.length &&
              u.push({
                colno: m,
                filename: p,
                function: "?",
                in_app: !0,
                lineno: d,
              }),
            e
          );
        }
        function S(e) {
          u.DEBUG_BUILD && c.logger.log(`Global Handler attached: ${e}`);
        }
        function b() {
          const e = (0, i.getClient)();
          return (
            (e && e.getOptions()) || {
              stackParser: () => [],
              attachStacktrace: !1,
            }
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { LinkedErrors: () => l, linkedErrorsIntegration: () => r });
        var s = n(34),
          i = n(100),
          o = n(79);
        const a = "LinkedErrors",
          r = (0, s.defineIntegration)((e = {}) => {
            const t = e.limit || 5,
              n = e.key || "cause";
            return {
              name: a,
              setupOnce() {},
              preprocessEvent(e, s, a) {
                const r = a.getOptions();
                (0, i.applyAggregateErrorsToEvent)(
                  o.exceptionFromError,
                  r.stackParser,
                  r.maxValueLength,
                  n,
                  t,
                  e,
                  s,
                );
              },
            };
          }),
          l = (0, s.convertIntegrationFnToClass)(a, r);
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { applyAggregateErrorsToEvent: () => o });
        var s = n(9),
          i = n(11);
        function o(e, t, n = 250, o, r, l, c) {
          if (
            !(
              l.exception &&
              l.exception.values &&
              c &&
              (0, s.isInstanceOf)(c.originalException, Error)
            )
          )
            return;
          const u =
            l.exception.values.length > 0
              ? l.exception.values[l.exception.values.length - 1]
              : void 0;
          var m, d;
          u &&
            (l.exception.values =
              ((m = a(
                e,
                t,
                r,
                c.originalException,
                o,
                l.exception.values,
                u,
                0,
              )),
              (d = n),
              m.map(
                (e) => (e.value && (e.value = (0, i.truncate)(e.value, d)), e),
              )));
        }
        function a(e, t, n, i, o, c, u, m) {
          if (c.length >= n + 1) return c;
          let d = [...c];
          if ((0, s.isInstanceOf)(i[o], Error)) {
            r(u, m);
            const s = e(t, i[o]),
              c = d.length;
            l(s, o, c, m), (d = a(e, t, n, i[o], o, [s, ...d], s, c));
          }
          return (
            Array.isArray(i.errors) &&
              i.errors.forEach((i, c) => {
                if ((0, s.isInstanceOf)(i, Error)) {
                  r(u, m);
                  const s = e(t, i),
                    p = d.length;
                  l(s, `errors[${c}]`, p, m),
                    (d = a(e, t, n, i, o, [s, ...d], s, p));
                }
              }),
            d
          );
        }
        function r(e, t) {
          (e.mechanism = e.mechanism || { type: "generic", handled: !0 }),
            (e.mechanism = {
              ...e.mechanism,
              is_exception_group: !0,
              exception_id: t,
            });
        }
        function l(e, t, n, s) {
          (e.mechanism = e.mechanism || { type: "generic", handled: !0 }),
            (e.mechanism = {
              ...e.mechanism,
              type: "chained",
              source: t,
              exception_id: n,
              parent_id: s,
            });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { Dedupe: () => l, dedupeIntegration: () => r });
        var s = n(34),
          i = n(7),
          o = n(80);
        const a = "Dedupe",
          r = (0, s.defineIntegration)(() => {
            let e;
            return {
              name: a,
              setupOnce() {},
              processEvent(t) {
                if (t.type) return t;
                try {
                  if (
                    (function (e, t) {
                      if (!t) return !1;
                      if (
                        (function (e, t) {
                          const n = e.message,
                            s = t.message;
                          if (!n && !s) return !1;
                          if ((n && !s) || (!n && s)) return !1;
                          if (n !== s) return !1;
                          if (!u(e, t)) return !1;
                          if (!c(e, t)) return !1;
                          return !0;
                        })(e, t)
                      )
                        return !0;
                      if (
                        (function (e, t) {
                          const n = m(t),
                            s = m(e);
                          if (!n || !s) return !1;
                          if (n.type !== s.type || n.value !== s.value)
                            return !1;
                          if (!u(e, t)) return !1;
                          if (!c(e, t)) return !1;
                          return !0;
                        })(e, t)
                      )
                        return !0;
                      return !1;
                    })(t, e)
                  )
                    return (
                      o.DEBUG_BUILD &&
                        i.logger.warn(
                          "Event dropped due to being a duplicate of previously captured event.",
                        ),
                      null
                    );
                } catch (e) {}
                return (e = t);
              },
            };
          }),
          l = (0, s.convertIntegrationFnToClass)(a, r);
        function c(e, t) {
          let n = d(e),
            s = d(t);
          if (!n && !s) return !0;
          if ((n && !s) || (!n && s)) return !1;
          if (s.length !== n.length) return !1;
          for (let e = 0; e < s.length; e++) {
            const t = s[e],
              i = n[e];
            if (
              t.filename !== i.filename ||
              t.lineno !== i.lineno ||
              t.colno !== i.colno ||
              t.function !== i.function
            )
              return !1;
          }
          return !0;
        }
        function u(e, t) {
          let n = e.fingerprint,
            s = t.fingerprint;
          if (!n && !s) return !0;
          if ((n && !s) || (!n && s)) return !1;
          try {
            return !(n.join("") !== s.join(""));
          } catch (e) {
            return !1;
          }
        }
        function m(e) {
          return e.exception && e.exception.values && e.exception.values[0];
        }
        function d(e) {
          const t = e.exception;
          if (t)
            try {
              return t.values[0].stacktrace.frames;
            } catch (e) {
              return;
            }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { HttpContext: () => r, httpContextIntegration: () => a });
        var s = n(34),
          i = n(75);
        const o = "HttpContext",
          a = (0, s.defineIntegration)(() => ({
            name: o,
            setupOnce() {},
            preprocessEvent(e) {
              if (
                !i.WINDOW.navigator &&
                !i.WINDOW.location &&
                !i.WINDOW.document
              )
                return;
              const t =
                  (e.request && e.request.url) ||
                  (i.WINDOW.location && i.WINDOW.location.href),
                { referrer: n } = i.WINDOW.document || {},
                { userAgent: s } = i.WINDOW.navigator || {},
                o = {
                  ...(e.request && e.request.headers),
                  ...(n && { Referer: n }),
                  ...(s && { "User-Agent": s }),
                },
                a = { ...e.request, ...(t && { url: t }), headers: o };
              e.request = a;
            },
          })),
          r = (0, s.convertIntegrationFnToClass)(o, a);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            Replay: () => xs,
            getReplay: () => Es,
            replayIntegration: () => vs,
          });
        var s = n(104),
          i = n(105),
          o = n(12),
          a = n(120),
          r = n(41),
          l = n(29),
          c = n(13),
          u = n(20),
          m = n(40),
          d = n(8),
          p = n(30),
          h = n(5),
          g = n(10),
          f = n(17),
          S = n(7),
          b = n(18),
          y = n(93),
          _ = n(11),
          v = n(94),
          x = n(92),
          k = n(95),
          E = n(37),
          T = n(66),
          C = n(121),
          w = n(106);
        const I = d.GLOBAL_OBJ,
          A = "sentryReplaySession",
          P = "replay_event",
          R = "Unable to send Replay",
          D = 15e4,
          M = 5e3,
          O = 2e7,
          N = 36e5;
        function L(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        var B;
        function U(e) {
          const t = L([e, "optionalAccess", (e) => e.host]);
          return Boolean(L([t, "optionalAccess", (e) => e.shadowRoot]) === e);
        }
        function F(e) {
          return "[object ShadowRoot]" === Object.prototype.toString.call(e);
        }
        function H(e) {
          try {
            const n = e.rules || e.cssRules;
            return n
              ? ((t = Array.from(n, j).join("")).includes(
                  " background-clip: text;",
                ) &&
                  !t.includes(" -webkit-background-clip: text;") &&
                  (t = t.replace(
                    " background-clip: text;",
                    " -webkit-background-clip: text; background-clip: text;",
                  )),
                t)
              : null;
          } catch (e) {
            return null;
          }
          var t;
        }
        function j(e) {
          let t;
          if (
            (function (e) {
              return "styleSheet" in e;
            })(e)
          )
            try {
              t =
                H(e.styleSheet) ||
                (function (e) {
                  const { cssText: t } = e;
                  if (t.split('"').length < 3) return t;
                  const n = ["@import", `url(${JSON.stringify(e.href)})`];
                  return (
                    "" === e.layerName
                      ? n.push("layer")
                      : e.layerName && n.push(`layer(${e.layerName})`),
                    e.supportsText && n.push(`supports(${e.supportsText})`),
                    e.media.length && n.push(e.media.mediaText),
                    n.join(" ") + ";"
                  );
                })(e);
            } catch (e) {}
          else if (
            (function (e) {
              return "selectorText" in e;
            })(e) &&
            e.selectorText.includes(":")
          )
            return (function (e) {
              const t = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
              return e.replace(t, "$1\\$2");
            })(e.cssText);
          return t || e.cssText;
        }
        !(function (e) {
          (e[(e.Document = 0)] = "Document"),
            (e[(e.DocumentType = 1)] = "DocumentType"),
            (e[(e.Element = 2)] = "Element"),
            (e[(e.Text = 3)] = "Text"),
            (e[(e.CDATA = 4)] = "CDATA"),
            (e[(e.Comment = 5)] = "Comment");
        })(B || (B = {}));
        class G {
          constructor() {
            (this.idNodeMap = new Map()), (this.nodeMetaMap = new WeakMap());
          }
          getId(e) {
            if (!e) return -1;
            const t = L([
              this,
              "access",
              (e) => e.getMeta,
              "call",
              (t) => t(e),
              "optionalAccess",
              (e) => e.id,
            ]);
            return (s = () => -1), null != (n = t) ? n : s();
            var n, s;
          }
          getNode(e) {
            return this.idNodeMap.get(e) || null;
          }
          getIds() {
            return Array.from(this.idNodeMap.keys());
          }
          getMeta(e) {
            return this.nodeMetaMap.get(e) || null;
          }
          removeNodeFromMap(e) {
            const t = this.getId(e);
            this.idNodeMap.delete(t),
              e.childNodes &&
                e.childNodes.forEach((e) => this.removeNodeFromMap(e));
          }
          has(e) {
            return this.idNodeMap.has(e);
          }
          hasNode(e) {
            return this.nodeMetaMap.has(e);
          }
          add(e, t) {
            const n = t.id;
            this.idNodeMap.set(n, e), this.nodeMetaMap.set(e, t);
          }
          replace(e, t) {
            const n = this.getNode(e);
            if (n) {
              const e = this.nodeMetaMap.get(n);
              e && this.nodeMetaMap.set(t, e);
            }
            this.idNodeMap.set(e, t);
          }
          reset() {
            (this.idNodeMap = new Map()), (this.nodeMetaMap = new WeakMap());
          }
        }
        function W({ maskInputOptions: e, tagName: t, type: n }) {
          return (
            "OPTION" === t && (t = "SELECT"),
            Boolean(
              e[t.toLowerCase()] ||
                (n && e[n]) ||
                "password" === n ||
                ("INPUT" === t && !n && e.text),
            )
          );
        }
        function q({ isMasked: e, element: t, value: n, maskInputFn: s }) {
          let i = n || "";
          return e ? (s && (i = s(i, t)), "*".repeat(i.length)) : i;
        }
        function $(e) {
          return e.toLowerCase();
        }
        function V(e) {
          return e.toUpperCase();
        }
        const z = "__rrweb_original__";
        function Y(e) {
          const t = e.type;
          return e.hasAttribute("data-rr-is-password")
            ? "password"
            : t
              ? $(t)
              : null;
        }
        function K(e, t, n) {
          return "INPUT" !== t || ("radio" !== n && "checkbox" !== n)
            ? e.value
            : e.getAttribute("value") || "";
        }
        let J = 1;
        const X = new RegExp("[^a-z0-9-_:]"),
          Z = -2;
        function Q() {
          return J++;
        }
        let ee, te;
        const ne = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,
          se = /^(?:[a-z+]+:)?\/\//i,
          ie = /^www\..*/i,
          oe = /^(data:)([^,]*),(.*)/i;
        function ae(e, t) {
          return (e || "").replace(ne, (e, n, s, i, o, a) => {
            const r = s || o || a,
              l = n || i || "";
            if (!r) return e;
            if (se.test(r) || ie.test(r)) return `url(${l}${r}${l})`;
            if (oe.test(r)) return `url(${l}${r}${l})`;
            if ("/" === r[0])
              return `url(${l}${
                (function (e) {
                  let t = "";
                  return (
                    (t =
                      e.indexOf("//") > -1
                        ? e.split("/").slice(0, 3).join("/")
                        : e.split("/")[0]),
                    (t = t.split("?")[0]),
                    t
                  );
                })(t) + r
              }${l})`;
            const c = t.split("/"),
              u = r.split("/");
            c.pop();
            for (const e of u) "." !== e && (".." === e ? c.pop() : c.push(e));
            return `url(${l}${c.join("/")}${l})`;
          });
        }
        const re = /^[^ \t\n\r\u000c]+/,
          le = /^[, \t\n\r\u000c]+/;
        function ce(e, t) {
          if (!t || "" === t.trim()) return t;
          const n = e.createElement("a");
          return (n.href = t), n.href;
        }
        function ue(e) {
          return Boolean("svg" === e.tagName || e.ownerSVGElement);
        }
        function me() {
          const e = document.createElement("a");
          return (e.href = ""), e.href;
        }
        function de(e, t, n, s, i, o) {
          return s
            ? "src" === n ||
              ("href" === n && ("use" !== t || "#" !== s[0])) ||
              ("xlink:href" === n && "#" !== s[0])
              ? ce(e, s)
              : "background" !== n ||
                  ("table" !== t && "td" !== t && "th" !== t)
                ? "srcset" === n
                  ? (function (e, t) {
                      if ("" === t.trim()) return t;
                      let n = 0;
                      function s(e) {
                        let s;
                        const i = e.exec(t.substring(n));
                        return i ? ((s = i[0]), (n += s.length), s) : "";
                      }
                      const i = [];
                      for (; s(le), !(n >= t.length); ) {
                        let o = s(re);
                        if ("," === o.slice(-1))
                          (o = ce(e, o.substring(0, o.length - 1))), i.push(o);
                        else {
                          let s = "";
                          o = ce(e, o);
                          let a = !1;
                          for (;;) {
                            const e = t.charAt(n);
                            if ("" === e) {
                              i.push((o + s).trim());
                              break;
                            }
                            if (a) ")" === e && (a = !1);
                            else {
                              if ("," === e) {
                                (n += 1), i.push((o + s).trim());
                                break;
                              }
                              "(" === e && (a = !0);
                            }
                            (s += e), (n += 1);
                          }
                        }
                      }
                      return i.join(", ");
                    })(e, s)
                  : "style" === n
                    ? ae(s, me())
                    : "object" === t && "data" === n
                      ? ce(e, s)
                      : "function" == typeof o
                        ? o(n, s, i)
                        : s
                : ce(e, s)
            : s;
        }
        function pe(e, t, n) {
          return ("video" === e || "audio" === e) && "autoplay" === t;
        }
        function he(e, t, n = 1 / 0, s = 0) {
          return e
            ? e.nodeType !== e.ELEMENT_NODE || s > n
              ? -1
              : t(e)
                ? s
                : he(e.parentNode, t, n, s + 1)
            : -1;
        }
        function ge(e, t) {
          return (n) => {
            const s = n;
            if (null === s) return !1;
            try {
              if (e)
                if ("string" == typeof e) {
                  if (s.matches(`.${e}`)) return !0;
                } else if (
                  (function (e, t) {
                    for (let n = e.classList.length; n--; ) {
                      const s = e.classList[n];
                      if (t.test(s)) return !0;
                    }
                    return !1;
                  })(s, e)
                )
                  return !0;
              return !(!t || !s.matches(t));
            } catch (e) {
              return !1;
            }
          };
        }
        function fe(e, t, n, s, i, o) {
          try {
            const a = e.nodeType === e.ELEMENT_NODE ? e : e.parentElement;
            if (null === a) return !1;
            if ("INPUT" === a.tagName) {
              const e = a.getAttribute("autocomplete");
              if (
                [
                  "current-password",
                  "new-password",
                  "cc-number",
                  "cc-exp",
                  "cc-exp-month",
                  "cc-exp-year",
                  "cc-csc",
                ].includes(e)
              )
                return !0;
            }
            let r = -1,
              l = -1;
            if (o) {
              if (((l = he(a, ge(s, i))), l < 0)) return !0;
              r = he(a, ge(t, n), l >= 0 ? l : 1 / 0);
            } else {
              if (((r = he(a, ge(t, n))), r < 0)) return !1;
              l = he(a, ge(s, i), r >= 0 ? r : 1 / 0);
            }
            return r >= 0 ? !(l >= 0) || r <= l : !(l >= 0) && !!o;
          } catch (e) {}
          return !!o;
        }
        function Se(e, t) {
          const {
              doc: n,
              mirror: s,
              blockClass: i,
              blockSelector: o,
              unblockSelector: a,
              maskAllText: r,
              maskAttributeFn: l,
              maskTextClass: c,
              unmaskTextClass: u,
              maskTextSelector: m,
              unmaskTextSelector: d,
              inlineStylesheet: p,
              maskInputOptions: h = {},
              maskTextFn: g,
              maskInputFn: f,
              dataURLOptions: S = {},
              inlineImages: b,
              recordCanvas: y,
              keepIframeSrcFn: _,
              newlyAddedElement: v = !1,
            } = t,
            x = (function (e, t) {
              if (!t.hasNode(e)) return;
              const n = t.getId(e);
              return 1 === n ? void 0 : n;
            })(n, s);
          switch (e.nodeType) {
            case e.DOCUMENT_NODE:
              return "CSS1Compat" !== e.compatMode
                ? { type: B.Document, childNodes: [], compatMode: e.compatMode }
                : { type: B.Document, childNodes: [] };
            case e.DOCUMENT_TYPE_NODE:
              return {
                type: B.DocumentType,
                name: e.name,
                publicId: e.publicId,
                systemId: e.systemId,
                rootId: x,
              };
            case e.ELEMENT_NODE:
              return (function (e, t) {
                const {
                    doc: n,
                    blockClass: s,
                    blockSelector: i,
                    unblockSelector: o,
                    inlineStylesheet: a,
                    maskInputOptions: r = {},
                    maskAttributeFn: l,
                    maskInputFn: c,
                    dataURLOptions: u = {},
                    inlineImages: m,
                    recordCanvas: d,
                    keepIframeSrcFn: p,
                    newlyAddedElement: h = !1,
                    rootId: g,
                    maskAllText: f,
                    maskTextClass: S,
                    unmaskTextClass: b,
                    maskTextSelector: y,
                    unmaskTextSelector: _,
                  } = t,
                  v = (function (e, t, n, s) {
                    try {
                      if (s && e.matches(s)) return !1;
                      if ("string" == typeof t) {
                        if (e.classList.contains(t)) return !0;
                      } else
                        for (let n = e.classList.length; n--; ) {
                          const s = e.classList[n];
                          if (t.test(s)) return !0;
                        }
                      if (n) return e.matches(n);
                    } catch (e) {}
                    return !1;
                  })(e, s, i, o),
                  x = (function (e) {
                    if (e instanceof HTMLFormElement) return "form";
                    const t = $(e.tagName);
                    return X.test(t) ? "div" : t;
                  })(e);
                let k = {};
                const E = e.attributes.length;
                for (let t = 0; t < E; t++) {
                  const s = e.attributes[t];
                  s.name &&
                    !pe(x, s.name, s.value) &&
                    (k[s.name] = de(n, x, $(s.name), s.value, e, l));
                }
                if ("link" === x && a) {
                  const t = Array.from(n.styleSheets).find(
                    (t) => t.href === e.href,
                  );
                  let s = null;
                  t && (s = H(t)),
                    s &&
                      (delete k.rel,
                      delete k.href,
                      (k._cssText = ae(s, t.href)));
                }
                if (
                  "style" === x &&
                  e.sheet &&
                  !(e.innerText || e.textContent || "").trim().length
                ) {
                  const t = H(e.sheet);
                  t && (k._cssText = ae(t, me()));
                }
                if (
                  "input" === x ||
                  "textarea" === x ||
                  "select" === x ||
                  "option" === x
                ) {
                  const t = e,
                    n = Y(t),
                    s = K(t, V(x), n),
                    i = t.checked;
                  if ("submit" !== n && "button" !== n && s) {
                    const e = fe(
                      t,
                      S,
                      y,
                      b,
                      _,
                      W({ type: n, tagName: V(x), maskInputOptions: r }),
                    );
                    k.value = q({
                      isMasked: e,
                      element: t,
                      value: s,
                      maskInputFn: c,
                    });
                  }
                  i && (k.checked = i);
                }
                "option" === x &&
                  (e.selected && !r.select
                    ? (k.selected = !0)
                    : delete k.selected);
                if ("canvas" === x && d)
                  if ("2d" === e.__context)
                    (function (e) {
                      const t = e.getContext("2d");
                      if (!t) return !0;
                      for (let n = 0; n < e.width; n += 50)
                        for (let s = 0; s < e.height; s += 50) {
                          const i = t.getImageData,
                            o = z in i ? i[z] : i;
                          if (
                            new Uint32Array(
                              o.call(
                                t,
                                n,
                                s,
                                Math.min(50, e.width - n),
                                Math.min(50, e.height - s),
                              ).data.buffer,
                            ).some((e) => 0 !== e)
                          )
                            return !1;
                        }
                      return !0;
                    })(e) || (k.rr_dataURL = e.toDataURL(u.type, u.quality));
                  else if (!("__context" in e)) {
                    const t = e.toDataURL(u.type, u.quality),
                      n = document.createElement("canvas");
                    (n.width = e.width), (n.height = e.height);
                    t !== n.toDataURL(u.type, u.quality) && (k.rr_dataURL = t);
                  }
                if ("img" === x && m) {
                  ee ||
                    ((ee = n.createElement("canvas")),
                    (te = ee.getContext("2d")));
                  const t = e,
                    s = t.crossOrigin;
                  t.crossOrigin = "anonymous";
                  const i = () => {
                    t.removeEventListener("load", i);
                    try {
                      (ee.width = t.naturalWidth),
                        (ee.height = t.naturalHeight),
                        te.drawImage(t, 0, 0),
                        (k.rr_dataURL = ee.toDataURL(u.type, u.quality));
                    } catch (e) {
                      console.warn(
                        `Cannot inline img src=${t.currentSrc}! Error: ${e}`,
                      );
                    }
                    s ? (k.crossOrigin = s) : t.removeAttribute("crossorigin");
                  };
                  t.complete && 0 !== t.naturalWidth
                    ? i()
                    : t.addEventListener("load", i);
                }
                ("audio" !== x && "video" !== x) ||
                  ((k.rr_mediaState = e.paused ? "paused" : "played"),
                  (k.rr_mediaCurrentTime = e.currentTime));
                h ||
                  (e.scrollLeft && (k.rr_scrollLeft = e.scrollLeft),
                  e.scrollTop && (k.rr_scrollTop = e.scrollTop));
                if (v) {
                  const { width: t, height: n } = e.getBoundingClientRect();
                  k = {
                    class: k.class,
                    rr_width: `${t}px`,
                    rr_height: `${n}px`,
                  };
                }
                "iframe" !== x ||
                  p(k.src) ||
                  (e.contentDocument || (k.rr_src = k.src), delete k.src);
                let T;
                try {
                  customElements.get(x) && (T = !0);
                } catch (e) {}
                return {
                  type: B.Element,
                  tagName: x,
                  attributes: k,
                  childNodes: [],
                  isSVG: ue(e) || void 0,
                  needBlock: v,
                  rootId: g,
                  isCustom: T,
                };
              })(e, {
                doc: n,
                blockClass: i,
                blockSelector: o,
                unblockSelector: a,
                inlineStylesheet: p,
                maskAttributeFn: l,
                maskInputOptions: h,
                maskInputFn: f,
                dataURLOptions: S,
                inlineImages: b,
                recordCanvas: y,
                keepIframeSrcFn: _,
                newlyAddedElement: v,
                rootId: x,
                maskAllText: r,
                maskTextClass: c,
                unmaskTextClass: u,
                maskTextSelector: m,
                unmaskTextSelector: d,
              });
            case e.TEXT_NODE:
              return (function (e, t) {
                const {
                    maskAllText: n,
                    maskTextClass: s,
                    unmaskTextClass: i,
                    maskTextSelector: o,
                    unmaskTextSelector: a,
                    maskTextFn: r,
                    maskInputOptions: l,
                    maskInputFn: c,
                    rootId: u,
                  } = t,
                  m = e.parentNode && e.parentNode.tagName;
                let d = e.textContent;
                const p = "STYLE" === m || void 0,
                  h = "SCRIPT" === m || void 0,
                  g = "TEXTAREA" === m || void 0;
                if (p && d) {
                  try {
                    e.nextSibling ||
                      e.previousSibling ||
                      (L([
                        e,
                        "access",
                        (e) => e.parentNode,
                        "access",
                        (e) => e.sheet,
                        "optionalAccess",
                        (e) => e.cssRules,
                      ]) &&
                        (d = H(e.parentNode.sheet)));
                  } catch (t) {
                    console.warn(
                      `Cannot get CSS styles from text's parentNode. Error: ${t}`,
                      e,
                    );
                  }
                  d = ae(d, me());
                }
                h && (d = "SCRIPT_PLACEHOLDER");
                const f = fe(e, s, o, i, a, n);
                p ||
                  h ||
                  g ||
                  !d ||
                  !f ||
                  (d = r ? r(d) : d.replace(/[\S]/g, "*"));
                g &&
                  d &&
                  (l.textarea || f) &&
                  (d = c ? c(d, e.parentNode) : d.replace(/[\S]/g, "*"));
                if ("OPTION" === m && d) {
                  d = q({
                    isMasked: fe(
                      e,
                      s,
                      o,
                      i,
                      a,
                      W({ type: null, tagName: m, maskInputOptions: l }),
                    ),
                    element: e,
                    value: d,
                    maskInputFn: c,
                  });
                }
                return {
                  type: B.Text,
                  textContent: d || "",
                  isStyle: p,
                  rootId: u,
                };
              })(e, {
                maskAllText: r,
                maskTextClass: c,
                unmaskTextClass: u,
                maskTextSelector: m,
                unmaskTextSelector: d,
                maskTextFn: g,
                maskInputOptions: h,
                maskInputFn: f,
                rootId: x,
              });
            case e.CDATA_SECTION_NODE:
              return { type: B.CDATA, textContent: "", rootId: x };
            case e.COMMENT_NODE:
              return {
                type: B.Comment,
                textContent: e.textContent || "",
                rootId: x,
              };
            default:
              return !1;
          }
        }
        function be(e) {
          return null == e ? "" : e.toLowerCase();
        }
        function ye(e, t) {
          const {
            doc: n,
            mirror: s,
            blockClass: i,
            blockSelector: o,
            unblockSelector: a,
            maskAllText: r,
            maskTextClass: l,
            unmaskTextClass: c,
            maskTextSelector: u,
            unmaskTextSelector: m,
            skipChild: d = !1,
            inlineStylesheet: p = !0,
            maskInputOptions: h = {},
            maskAttributeFn: g,
            maskTextFn: f,
            maskInputFn: S,
            slimDOMOptions: b,
            dataURLOptions: y = {},
            inlineImages: _ = !1,
            recordCanvas: v = !1,
            onSerialize: x,
            onIframeLoad: k,
            iframeLoadTimeout: E = 5e3,
            onStylesheetLoad: T,
            stylesheetLoadTimeout: C = 5e3,
            keepIframeSrcFn: w = () => !1,
            newlyAddedElement: I = !1,
          } = t;
          let { preserveWhiteSpace: A = !0 } = t;
          const P = Se(e, {
            doc: n,
            mirror: s,
            blockClass: i,
            blockSelector: o,
            maskAllText: r,
            unblockSelector: a,
            maskTextClass: l,
            unmaskTextClass: c,
            maskTextSelector: u,
            unmaskTextSelector: m,
            inlineStylesheet: p,
            maskInputOptions: h,
            maskAttributeFn: g,
            maskTextFn: f,
            maskInputFn: S,
            dataURLOptions: y,
            inlineImages: _,
            recordCanvas: v,
            keepIframeSrcFn: w,
            newlyAddedElement: I,
          });
          if (!P) return console.warn(e, "not serialized"), null;
          let R;
          R = s.hasNode(e)
            ? s.getId(e)
            : !(function (e, t) {
                  if (t.comment && e.type === B.Comment) return !0;
                  if (e.type === B.Element) {
                    if (
                      t.script &&
                      ("script" === e.tagName ||
                        ("link" === e.tagName &&
                          ("preload" === e.attributes.rel ||
                            "modulepreload" === e.attributes.rel) &&
                          "script" === e.attributes.as) ||
                        ("link" === e.tagName &&
                          "prefetch" === e.attributes.rel &&
                          "string" == typeof e.attributes.href &&
                          e.attributes.href.endsWith(".js")))
                    )
                      return !0;
                    if (
                      t.headFavicon &&
                      (("link" === e.tagName &&
                        "shortcut icon" === e.attributes.rel) ||
                        ("meta" === e.tagName &&
                          (be(e.attributes.name).match(
                            /^msapplication-tile(image|color)$/,
                          ) ||
                            "application-name" === be(e.attributes.name) ||
                            "icon" === be(e.attributes.rel) ||
                            "apple-touch-icon" === be(e.attributes.rel) ||
                            "shortcut icon" === be(e.attributes.rel))))
                    )
                      return !0;
                    if ("meta" === e.tagName) {
                      if (
                        t.headMetaDescKeywords &&
                        be(e.attributes.name).match(/^description|keywords$/)
                      )
                        return !0;
                      if (
                        t.headMetaSocial &&
                        (be(e.attributes.property).match(/^(og|twitter|fb):/) ||
                          be(e.attributes.name).match(/^(og|twitter):/) ||
                          "pinterest" === be(e.attributes.name))
                      )
                        return !0;
                      if (
                        t.headMetaRobots &&
                        ("robots" === be(e.attributes.name) ||
                          "googlebot" === be(e.attributes.name) ||
                          "bingbot" === be(e.attributes.name))
                      )
                        return !0;
                      if (
                        t.headMetaHttpEquiv &&
                        void 0 !== e.attributes["http-equiv"]
                      )
                        return !0;
                      if (
                        t.headMetaAuthorship &&
                        ("author" === be(e.attributes.name) ||
                          "generator" === be(e.attributes.name) ||
                          "framework" === be(e.attributes.name) ||
                          "publisher" === be(e.attributes.name) ||
                          "progid" === be(e.attributes.name) ||
                          be(e.attributes.property).match(/^article:/) ||
                          be(e.attributes.property).match(/^product:/))
                      )
                        return !0;
                      if (
                        t.headMetaVerification &&
                        ("google-site-verification" === be(e.attributes.name) ||
                          "yandex-verification" === be(e.attributes.name) ||
                          "csrf-token" === be(e.attributes.name) ||
                          "p:domain_verify" === be(e.attributes.name) ||
                          "verify-v1" === be(e.attributes.name) ||
                          "verification" === be(e.attributes.name) ||
                          "shopify-checkout-api-token" ===
                            be(e.attributes.name))
                      )
                        return !0;
                    }
                  }
                  return !1;
                })(P, b) &&
                (A ||
                  P.type !== B.Text ||
                  P.isStyle ||
                  P.textContent.replace(/^\s+|\s+$/gm, "").length)
              ? Q()
              : Z;
          const D = Object.assign(P, { id: R });
          if ((s.add(e, D), R === Z)) return null;
          x && x(e);
          let M = !d;
          if (D.type === B.Element) {
            (M = M && !D.needBlock), delete D.needBlock;
            const t = e.shadowRoot;
            t && F(t) && (D.isShadowHost = !0);
          }
          if ((D.type === B.Document || D.type === B.Element) && M) {
            b.headWhitespace &&
              D.type === B.Element &&
              "head" === D.tagName &&
              (A = !1);
            const t = {
              doc: n,
              mirror: s,
              blockClass: i,
              blockSelector: o,
              maskAllText: r,
              unblockSelector: a,
              maskTextClass: l,
              unmaskTextClass: c,
              maskTextSelector: u,
              unmaskTextSelector: m,
              skipChild: d,
              inlineStylesheet: p,
              maskInputOptions: h,
              maskAttributeFn: g,
              maskTextFn: f,
              maskInputFn: S,
              slimDOMOptions: b,
              dataURLOptions: y,
              inlineImages: _,
              recordCanvas: v,
              preserveWhiteSpace: A,
              onSerialize: x,
              onIframeLoad: k,
              iframeLoadTimeout: E,
              onStylesheetLoad: T,
              stylesheetLoadTimeout: C,
              keepIframeSrcFn: w,
            };
            for (const n of Array.from(e.childNodes)) {
              const e = ye(n, t);
              e && D.childNodes.push(e);
            }
            if (
              (function (e) {
                return e.nodeType === e.ELEMENT_NODE;
              })(e) &&
              e.shadowRoot
            )
              for (const n of Array.from(e.shadowRoot.childNodes)) {
                const s = ye(n, t);
                s &&
                  (F(e.shadowRoot) && (s.isShadow = !0), D.childNodes.push(s));
              }
          }
          return (
            e.parentNode &&
              U(e.parentNode) &&
              F(e.parentNode) &&
              (D.isShadow = !0),
            D.type === B.Element &&
              "iframe" === D.tagName &&
              (function (e, t, n) {
                const s = e.contentWindow;
                if (!s) return;
                let i,
                  o = !1;
                try {
                  i = s.document.readyState;
                } catch (e) {
                  return;
                }
                if ("complete" !== i) {
                  const s = setTimeout(() => {
                    o || (t(), (o = !0));
                  }, n);
                  return void e.addEventListener("load", () => {
                    clearTimeout(s), (o = !0), t();
                  });
                }
                const a = "about:blank";
                if (s.location.href !== a || e.src === a || "" === e.src)
                  return setTimeout(t, 0), e.addEventListener("load", t);
                e.addEventListener("load", t);
              })(
                e,
                () => {
                  const t = e.contentDocument;
                  if (t && k) {
                    const n = ye(t, {
                      doc: t,
                      mirror: s,
                      blockClass: i,
                      blockSelector: o,
                      unblockSelector: a,
                      maskAllText: r,
                      maskTextClass: l,
                      unmaskTextClass: c,
                      maskTextSelector: u,
                      unmaskTextSelector: m,
                      skipChild: !1,
                      inlineStylesheet: p,
                      maskInputOptions: h,
                      maskAttributeFn: g,
                      maskTextFn: f,
                      maskInputFn: S,
                      slimDOMOptions: b,
                      dataURLOptions: y,
                      inlineImages: _,
                      recordCanvas: v,
                      preserveWhiteSpace: A,
                      onSerialize: x,
                      onIframeLoad: k,
                      iframeLoadTimeout: E,
                      onStylesheetLoad: T,
                      stylesheetLoadTimeout: C,
                      keepIframeSrcFn: w,
                    });
                    n && k(e, n);
                  }
                },
                E,
              ),
            D.type === B.Element &&
              "link" === D.tagName &&
              "stylesheet" === D.attributes.rel &&
              (function (e, t, n) {
                let s,
                  i = !1;
                try {
                  s = e.sheet;
                } catch (e) {
                  return;
                }
                if (s) return;
                const o = setTimeout(() => {
                  i || (t(), (i = !0));
                }, n);
                e.addEventListener("load", () => {
                  clearTimeout(o), (i = !0), t();
                });
              })(
                e,
                () => {
                  if (T) {
                    const t = ye(e, {
                      doc: n,
                      mirror: s,
                      blockClass: i,
                      blockSelector: o,
                      unblockSelector: a,
                      maskAllText: r,
                      maskTextClass: l,
                      unmaskTextClass: c,
                      maskTextSelector: u,
                      unmaskTextSelector: m,
                      skipChild: !1,
                      inlineStylesheet: p,
                      maskInputOptions: h,
                      maskAttributeFn: g,
                      maskTextFn: f,
                      maskInputFn: S,
                      slimDOMOptions: b,
                      dataURLOptions: y,
                      inlineImages: _,
                      recordCanvas: v,
                      preserveWhiteSpace: A,
                      onSerialize: x,
                      onIframeLoad: k,
                      iframeLoadTimeout: E,
                      onStylesheetLoad: T,
                      stylesheetLoadTimeout: C,
                      keepIframeSrcFn: w,
                    });
                    t && T(e, t);
                  }
                },
                C,
              ),
            D
          );
        }
        function _e(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        function ve(e, t, n = document) {
          const s = { capture: !0, passive: !0 };
          return (
            n.addEventListener(e, t, s), () => n.removeEventListener(e, t, s)
          );
        }
        const xe =
          "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
        let ke = {
          map: {},
          getId: () => (console.error(xe), -1),
          getNode: () => (console.error(xe), null),
          removeNodeFromMap() {
            console.error(xe);
          },
          has: () => (console.error(xe), !1),
          reset() {
            console.error(xe);
          },
        };
        function Ee(e, t, n = {}) {
          let s = null,
            i = 0;
          return function (...o) {
            const a = Date.now();
            i || !1 !== n.leading || (i = a);
            const r = t - (a - i),
              l = this;
            r <= 0 || r > t
              ? (s && (clearTimeout(s), (s = null)), (i = a), e.apply(l, o))
              : s ||
                !1 === n.trailing ||
                (s = setTimeout(() => {
                  (i = !1 === n.leading ? 0 : Date.now()),
                    (s = null),
                    e.apply(l, o);
                }, r));
          };
        }
        function Te(e, t, n, s, i = window) {
          const o = i.Object.getOwnPropertyDescriptor(e, t);
          return (
            i.Object.defineProperty(
              e,
              t,
              s
                ? n
                : {
                    set(e) {
                      setTimeout(() => {
                        n.set.call(this, e);
                      }, 0),
                        o && o.set && o.set.call(this, e);
                    },
                  },
            ),
            () => Te(e, t, o || {}, !0)
          );
        }
        function Ce(e, t, n) {
          try {
            if (!(t in e)) return () => {};
            const s = e[t],
              i = n(s);
            return (
              "function" == typeof i &&
                ((i.prototype = i.prototype || {}),
                Object.defineProperties(i, {
                  __rrweb_original__: { enumerable: !1, value: s },
                })),
              (e[t] = i),
              () => {
                e[t] = s;
              }
            );
          } catch (e) {
            return () => {};
          }
        }
        "undefined" != typeof window &&
          window.Proxy &&
          window.Reflect &&
          (ke = new Proxy(ke, {
            get: (e, t, n) => (
              "map" === t && console.error(xe), Reflect.get(e, t, n)
            ),
          }));
        let we,
          Ie = Date.now;
        function Ae(e) {
          const t = e.document;
          return {
            left: t.scrollingElement
              ? t.scrollingElement.scrollLeft
              : void 0 !== e.pageXOffset
                ? e.pageXOffset
                : _e([
                    t,
                    "optionalAccess",
                    (e) => e.documentElement,
                    "access",
                    (e) => e.scrollLeft,
                  ]) ||
                  _e([
                    t,
                    "optionalAccess",
                    (e) => e.body,
                    "optionalAccess",
                    (e) => e.parentElement,
                    "optionalAccess",
                    (e) => e.scrollLeft,
                  ]) ||
                  _e([
                    t,
                    "optionalAccess",
                    (e) => e.body,
                    "optionalAccess",
                    (e) => e.scrollLeft,
                  ]) ||
                  0,
            top: t.scrollingElement
              ? t.scrollingElement.scrollTop
              : void 0 !== e.pageYOffset
                ? e.pageYOffset
                : _e([
                    t,
                    "optionalAccess",
                    (e) => e.documentElement,
                    "access",
                    (e) => e.scrollTop,
                  ]) ||
                  _e([
                    t,
                    "optionalAccess",
                    (e) => e.body,
                    "optionalAccess",
                    (e) => e.parentElement,
                    "optionalAccess",
                    (e) => e.scrollTop,
                  ]) ||
                  _e([
                    t,
                    "optionalAccess",
                    (e) => e.body,
                    "optionalAccess",
                    (e) => e.scrollTop,
                  ]) ||
                  0,
          };
        }
        function Pe() {
          return (
            window.innerHeight ||
            (document.documentElement &&
              document.documentElement.clientHeight) ||
            (document.body && document.body.clientHeight)
          );
        }
        function Re() {
          return (
            window.innerWidth ||
            (document.documentElement &&
              document.documentElement.clientWidth) ||
            (document.body && document.body.clientWidth)
          );
        }
        function De(e, t, n, s, i) {
          if (!e) return !1;
          const o = e.nodeType === e.ELEMENT_NODE ? e : e.parentElement;
          if (!o) return !1;
          const a = ge(t, n);
          if (!i) {
            const e = s && o.matches(s);
            return a(o) && !e;
          }
          const r = he(o, a);
          let l = -1;
          return (
            !(r < 0) &&
            (s && (l = he(o, ge(null, s))), (r > -1 && l < 0) || r < l)
          );
        }
        function Me(e, t) {
          return t.getId(e) === Z;
        }
        function Oe(e, t) {
          if (U(e)) return !1;
          const n = t.getId(e);
          return (
            !t.has(n) ||
            ((!e.parentNode || e.parentNode.nodeType !== e.DOCUMENT_NODE) &&
              (!e.parentNode || Oe(e.parentNode, t)))
          );
        }
        function Ne(e) {
          return Boolean(e.changedTouches);
        }
        function Le(e, t) {
          return Boolean("IFRAME" === e.nodeName && t.getMeta(e));
        }
        function Be(e, t) {
          return Boolean(
            "LINK" === e.nodeName &&
              e.nodeType === e.ELEMENT_NODE &&
              e.getAttribute &&
              "stylesheet" === e.getAttribute("rel") &&
              t.getMeta(e),
          );
        }
        function Ue(e) {
          return Boolean(_e([e, "optionalAccess", (e) => e.shadowRoot]));
        }
        /[1-9][0-9]{12}/.test(Date.now().toString()) ||
          (Ie = () => new Date().getTime());
        class Fe {
          constructor() {
            (this.id = 1),
              (this.styleIDMap = new WeakMap()),
              (this.idStyleMap = new Map());
          }
          getId(e) {
            return (0, s._nullishCoalesce)(this.styleIDMap.get(e), () => -1);
          }
          has(e) {
            return this.styleIDMap.has(e);
          }
          add(e, t) {
            if (this.has(e)) return this.getId(e);
            let n;
            return (
              (n = void 0 === t ? this.id++ : t),
              this.styleIDMap.set(e, n),
              this.idStyleMap.set(n, e),
              n
            );
          }
          getStyle(e) {
            return this.idStyleMap.get(e) || null;
          }
          reset() {
            (this.styleIDMap = new WeakMap()),
              (this.idStyleMap = new Map()),
              (this.id = 1);
          }
          generateId() {
            return this.id++;
          }
        }
        function He(e) {
          let t = null;
          return (
            _e([
              e,
              "access",
              (e) => e.getRootNode,
              "optionalCall",
              (e) => e(),
              "optionalAccess",
              (e) => e.nodeType,
            ]) === Node.DOCUMENT_FRAGMENT_NODE &&
              e.getRootNode().host &&
              (t = e.getRootNode().host),
            t
          );
        }
        function je(e) {
          const t = e.ownerDocument;
          if (!t) return !1;
          const n = (function (e) {
            let t,
              n = e;
            for (; (t = He(n)); ) n = t;
            return n;
          })(e);
          return t.contains(n);
        }
        function Ge(e) {
          const t = e.ownerDocument;
          return !!t && (t.contains(e) || je(e));
        }
        function We(...e) {
          return (function () {
            if (we) return we;
            const e = window.document;
            let t = window.requestAnimationFrame;
            if (e && "function" == typeof e.createElement)
              try {
                const n = e.createElement("iframe");
                (n.hidden = !0), e.head.appendChild(n);
                const s = n.contentWindow;
                s && s.requestAnimationFrame && (t = s.requestAnimationFrame),
                  e.head.removeChild(n);
              } catch (e) {}
            return (we = t.bind(window));
          })()(...e);
        }
        var qe = ((e) => (
            (e[(e.DomContentLoaded = 0)] = "DomContentLoaded"),
            (e[(e.Load = 1)] = "Load"),
            (e[(e.FullSnapshot = 2)] = "FullSnapshot"),
            (e[(e.IncrementalSnapshot = 3)] = "IncrementalSnapshot"),
            (e[(e.Meta = 4)] = "Meta"),
            (e[(e.Custom = 5)] = "Custom"),
            (e[(e.Plugin = 6)] = "Plugin"),
            e
          ))(qe || {}),
          $e = ((e) => (
            (e[(e.Mutation = 0)] = "Mutation"),
            (e[(e.MouseMove = 1)] = "MouseMove"),
            (e[(e.MouseInteraction = 2)] = "MouseInteraction"),
            (e[(e.Scroll = 3)] = "Scroll"),
            (e[(e.ViewportResize = 4)] = "ViewportResize"),
            (e[(e.Input = 5)] = "Input"),
            (e[(e.TouchMove = 6)] = "TouchMove"),
            (e[(e.MediaInteraction = 7)] = "MediaInteraction"),
            (e[(e.StyleSheetRule = 8)] = "StyleSheetRule"),
            (e[(e.CanvasMutation = 9)] = "CanvasMutation"),
            (e[(e.Font = 10)] = "Font"),
            (e[(e.Log = 11)] = "Log"),
            (e[(e.Drag = 12)] = "Drag"),
            (e[(e.StyleDeclaration = 13)] = "StyleDeclaration"),
            (e[(e.Selection = 14)] = "Selection"),
            (e[(e.AdoptedStyleSheet = 15)] = "AdoptedStyleSheet"),
            (e[(e.CustomElement = 16)] = "CustomElement"),
            e
          ))($e || {}),
          Ve = ((e) => (
            (e[(e.MouseUp = 0)] = "MouseUp"),
            (e[(e.MouseDown = 1)] = "MouseDown"),
            (e[(e.Click = 2)] = "Click"),
            (e[(e.ContextMenu = 3)] = "ContextMenu"),
            (e[(e.DblClick = 4)] = "DblClick"),
            (e[(e.Focus = 5)] = "Focus"),
            (e[(e.Blur = 6)] = "Blur"),
            (e[(e.TouchStart = 7)] = "TouchStart"),
            (e[(e.TouchMove_Departed = 8)] = "TouchMove_Departed"),
            (e[(e.TouchEnd = 9)] = "TouchEnd"),
            (e[(e.TouchCancel = 10)] = "TouchCancel"),
            e
          ))(Ve || {}),
          ze = ((e) => (
            (e[(e.Mouse = 0)] = "Mouse"),
            (e[(e.Pen = 1)] = "Pen"),
            (e[(e.Touch = 2)] = "Touch"),
            e
          ))(ze || {});
        function Ye(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        function Ke(e) {
          return "__ln" in e;
        }
        class Je {
          constructor() {
            (this.length = 0), (this.head = null), (this.tail = null);
          }
          get(e) {
            if (e >= this.length)
              throw new Error("Position outside of list range");
            let t = this.head;
            for (let n = 0; n < e; n++)
              t = Ye([t, "optionalAccess", (e) => e.next]) || null;
            return t;
          }
          addNode(e) {
            const t = { value: e, previous: null, next: null };
            if (((e.__ln = t), e.previousSibling && Ke(e.previousSibling))) {
              const n = e.previousSibling.__ln.next;
              (t.next = n),
                (t.previous = e.previousSibling.__ln),
                (e.previousSibling.__ln.next = t),
                n && (n.previous = t);
            } else if (
              e.nextSibling &&
              Ke(e.nextSibling) &&
              e.nextSibling.__ln.previous
            ) {
              const n = e.nextSibling.__ln.previous;
              (t.previous = n),
                (t.next = e.nextSibling.__ln),
                (e.nextSibling.__ln.previous = t),
                n && (n.next = t);
            } else
              this.head && (this.head.previous = t),
                (t.next = this.head),
                (this.head = t);
            null === t.next && (this.tail = t), this.length++;
          }
          removeNode(e) {
            const t = e.__ln;
            this.head &&
              (t.previous
                ? ((t.previous.next = t.next),
                  t.next
                    ? (t.next.previous = t.previous)
                    : (this.tail = t.previous))
                : ((this.head = t.next),
                  this.head ? (this.head.previous = null) : (this.tail = null)),
              e.__ln && delete e.__ln,
              this.length--);
          }
        }
        const Xe = (e, t) => `${e}@${t}`;
        class Ze {
          constructor() {
            (this.frozen = !1),
              (this.locked = !1),
              (this.texts = []),
              (this.attributes = []),
              (this.removes = []),
              (this.mapRemoves = []),
              (this.movedMap = {}),
              (this.addedSet = new Set()),
              (this.movedSet = new Set()),
              (this.droppedSet = new Set()),
              (this.processMutations = (e) => {
                e.forEach(this.processMutation), this.emit();
              }),
              (this.emit = () => {
                if (this.frozen || this.locked) return;
                const e = [],
                  t = new Set(),
                  n = new Je(),
                  s = (e) => {
                    let t = e,
                      n = Z;
                    for (; n === Z; )
                      (t = t && t.nextSibling), (n = t && this.mirror.getId(t));
                    return n;
                  },
                  i = (i) => {
                    if (!i.parentNode || !Ge(i)) return;
                    const o = U(i.parentNode)
                        ? this.mirror.getId(He(i))
                        : this.mirror.getId(i.parentNode),
                      a = s(i);
                    if (-1 === o || -1 === a) return n.addNode(i);
                    const r = ye(i, {
                      doc: this.doc,
                      mirror: this.mirror,
                      blockClass: this.blockClass,
                      blockSelector: this.blockSelector,
                      maskAllText: this.maskAllText,
                      unblockSelector: this.unblockSelector,
                      maskTextClass: this.maskTextClass,
                      unmaskTextClass: this.unmaskTextClass,
                      maskTextSelector: this.maskTextSelector,
                      unmaskTextSelector: this.unmaskTextSelector,
                      skipChild: !0,
                      newlyAddedElement: !0,
                      inlineStylesheet: this.inlineStylesheet,
                      maskInputOptions: this.maskInputOptions,
                      maskAttributeFn: this.maskAttributeFn,
                      maskTextFn: this.maskTextFn,
                      maskInputFn: this.maskInputFn,
                      slimDOMOptions: this.slimDOMOptions,
                      dataURLOptions: this.dataURLOptions,
                      recordCanvas: this.recordCanvas,
                      inlineImages: this.inlineImages,
                      onSerialize: (e) => {
                        Le(e, this.mirror) && this.iframeManager.addIframe(e),
                          Be(e, this.mirror) &&
                            this.stylesheetManager.trackLinkElement(e),
                          Ue(i) &&
                            this.shadowDomManager.addShadowRoot(
                              i.shadowRoot,
                              this.doc,
                            );
                      },
                      onIframeLoad: (e, t) => {
                        this.iframeManager.attachIframe(e, t),
                          this.shadowDomManager.observeAttachShadow(e);
                      },
                      onStylesheetLoad: (e, t) => {
                        this.stylesheetManager.attachLinkElement(e, t);
                      },
                    });
                    r &&
                      (e.push({ parentId: o, nextId: a, node: r }),
                      t.add(r.id));
                  };
                for (; this.mapRemoves.length; )
                  this.mirror.removeNodeFromMap(this.mapRemoves.shift());
                for (const e of this.movedSet)
                  (et(this.removes, e, this.mirror) &&
                    !this.movedSet.has(e.parentNode)) ||
                    i(e);
                for (const e of this.addedSet)
                  nt(this.droppedSet, e) || et(this.removes, e, this.mirror)
                    ? nt(this.movedSet, e)
                      ? i(e)
                      : this.droppedSet.add(e)
                    : i(e);
                let o = null;
                for (; n.length; ) {
                  let e = null;
                  if (o) {
                    const t = this.mirror.getId(o.value.parentNode),
                      n = s(o.value);
                    -1 !== t && -1 !== n && (e = o);
                  }
                  if (!e) {
                    let t = n.tail;
                    for (; t; ) {
                      const n = t;
                      if (((t = t.previous), n)) {
                        const t = this.mirror.getId(n.value.parentNode);
                        if (-1 === s(n.value)) continue;
                        if (-1 !== t) {
                          e = n;
                          break;
                        }
                        {
                          const t = n.value;
                          if (
                            t.parentNode &&
                            t.parentNode.nodeType ===
                              Node.DOCUMENT_FRAGMENT_NODE
                          ) {
                            const s = t.parentNode.host;
                            if (-1 !== this.mirror.getId(s)) {
                              e = n;
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                  if (!e) {
                    for (; n.head; ) n.removeNode(n.head.value);
                    break;
                  }
                  (o = e.previous), n.removeNode(e.value), i(e.value);
                }
                const a = {
                  texts: this.texts
                    .map((e) => ({
                      id: this.mirror.getId(e.node),
                      value: e.value,
                    }))
                    .filter((e) => !t.has(e.id))
                    .filter((e) => this.mirror.has(e.id)),
                  attributes: this.attributes
                    .map((e) => {
                      const { attributes: t } = e;
                      if ("string" == typeof t.style) {
                        const n = JSON.stringify(e.styleDiff),
                          s = JSON.stringify(e._unchangedStyles);
                        n.length < t.style.length &&
                          (n + s).split("var(").length ===
                            t.style.split("var(").length &&
                          (t.style = e.styleDiff);
                      }
                      return { id: this.mirror.getId(e.node), attributes: t };
                    })
                    .filter((e) => !t.has(e.id))
                    .filter((e) => this.mirror.has(e.id)),
                  removes: this.removes,
                  adds: e,
                };
                (a.texts.length ||
                  a.attributes.length ||
                  a.removes.length ||
                  a.adds.length) &&
                  ((this.texts = []),
                  (this.attributes = []),
                  (this.removes = []),
                  (this.addedSet = new Set()),
                  (this.movedSet = new Set()),
                  (this.droppedSet = new Set()),
                  (this.movedMap = {}),
                  this.mutationCb(a));
              }),
              (this.processMutation = (e) => {
                if (Me(e.target, this.mirror)) return;
                let t;
                try {
                  t = document.implementation.createHTMLDocument();
                } catch (e) {
                  t = this.doc;
                }
                switch (e.type) {
                  case "characterData": {
                    const t = e.target.textContent;
                    De(
                      e.target,
                      this.blockClass,
                      this.blockSelector,
                      this.unblockSelector,
                      !1,
                    ) ||
                      t === e.oldValue ||
                      this.texts.push({
                        value:
                          fe(
                            e.target,
                            this.maskTextClass,
                            this.maskTextSelector,
                            this.unmaskTextClass,
                            this.unmaskTextSelector,
                            this.maskAllText,
                          ) && t
                            ? this.maskTextFn
                              ? this.maskTextFn(t)
                              : t.replace(/[\S]/g, "*")
                            : t,
                        node: e.target,
                      });
                    break;
                  }
                  case "attributes": {
                    const n = e.target;
                    let s = e.attributeName,
                      i = e.target.getAttribute(s);
                    if ("value" === s) {
                      const t = Y(n),
                        s = n.tagName;
                      i = K(n, s, t);
                      const o = W({
                        maskInputOptions: this.maskInputOptions,
                        tagName: s,
                        type: t,
                      });
                      i = q({
                        isMasked: fe(
                          e.target,
                          this.maskTextClass,
                          this.maskTextSelector,
                          this.unmaskTextClass,
                          this.unmaskTextSelector,
                          o,
                        ),
                        element: n,
                        value: i,
                        maskInputFn: this.maskInputFn,
                      });
                    }
                    if (
                      De(
                        e.target,
                        this.blockClass,
                        this.blockSelector,
                        this.unblockSelector,
                        !1,
                      ) ||
                      i === e.oldValue
                    )
                      return;
                    let o = this.attributes.find((t) => t.node === e.target);
                    if (
                      "IFRAME" === n.tagName &&
                      "src" === s &&
                      !this.keepIframeSrcFn(i)
                    ) {
                      if (n.contentDocument) return;
                      s = "rr_src";
                    }
                    if (
                      (o ||
                        ((o = {
                          node: e.target,
                          attributes: {},
                          styleDiff: {},
                          _unchangedStyles: {},
                        }),
                        this.attributes.push(o)),
                      "type" === s &&
                        "INPUT" === n.tagName &&
                        "password" === (e.oldValue || "").toLowerCase() &&
                        n.setAttribute("data-rr-is-password", "true"),
                      !pe(n.tagName, s) &&
                        ((o.attributes[s] = de(
                          this.doc,
                          $(n.tagName),
                          $(s),
                          i,
                          n,
                          this.maskAttributeFn,
                        )),
                        "style" === s))
                    ) {
                      const s = t.createElement("span");
                      e.oldValue && s.setAttribute("style", e.oldValue);
                      for (const e of Array.from(n.style)) {
                        const t = n.style.getPropertyValue(e),
                          i = n.style.getPropertyPriority(e);
                        t !== s.style.getPropertyValue(e) ||
                        i !== s.style.getPropertyPriority(e)
                          ? (o.styleDiff[e] = "" === i ? t : [t, i])
                          : (o._unchangedStyles[e] = [t, i]);
                      }
                      for (const e of Array.from(s.style))
                        "" === n.style.getPropertyValue(e) &&
                          (o.styleDiff[e] = !1);
                    }
                    break;
                  }
                  case "childList":
                    if (
                      De(
                        e.target,
                        this.blockClass,
                        this.blockSelector,
                        this.unblockSelector,
                        !0,
                      )
                    )
                      return;
                    e.addedNodes.forEach((t) => this.genAdds(t, e.target)),
                      e.removedNodes.forEach((t) => {
                        const n = this.mirror.getId(t),
                          s = U(e.target)
                            ? this.mirror.getId(e.target.host)
                            : this.mirror.getId(e.target);
                        De(
                          e.target,
                          this.blockClass,
                          this.blockSelector,
                          this.unblockSelector,
                          !1,
                        ) ||
                          Me(t, this.mirror) ||
                          !(function (e, t) {
                            return -1 !== t.getId(e);
                          })(t, this.mirror) ||
                          (this.addedSet.has(t)
                            ? (Qe(this.addedSet, t), this.droppedSet.add(t))
                            : (this.addedSet.has(e.target) && -1 === n) ||
                              Oe(e.target, this.mirror) ||
                              (this.movedSet.has(t) && this.movedMap[Xe(n, s)]
                                ? Qe(this.movedSet, t)
                                : this.removes.push({
                                    parentId: s,
                                    id: n,
                                    isShadow:
                                      !(!U(e.target) || !F(e.target)) || void 0,
                                  })),
                          this.mapRemoves.push(t));
                      });
                }
              }),
              (this.genAdds = (e, t) => {
                if (
                  !this.processedNodeManager.inOtherBuffer(e, this) &&
                  !this.addedSet.has(e) &&
                  !this.movedSet.has(e)
                ) {
                  if (this.mirror.hasNode(e)) {
                    if (Me(e, this.mirror)) return;
                    this.movedSet.add(e);
                    let n = null;
                    t && this.mirror.hasNode(t) && (n = this.mirror.getId(t)),
                      n &&
                        -1 !== n &&
                        (this.movedMap[Xe(this.mirror.getId(e), n)] = !0);
                  } else this.addedSet.add(e), this.droppedSet.delete(e);
                  De(
                    e,
                    this.blockClass,
                    this.blockSelector,
                    this.unblockSelector,
                    !1,
                  ) ||
                    (e.childNodes.forEach((e) => this.genAdds(e)),
                    Ue(e) &&
                      e.shadowRoot.childNodes.forEach((t) => {
                        this.processedNodeManager.add(t, this),
                          this.genAdds(t, e);
                      }));
                }
              });
          }
          init(e) {
            [
              "mutationCb",
              "blockClass",
              "blockSelector",
              "unblockSelector",
              "maskAllText",
              "maskTextClass",
              "unmaskTextClass",
              "maskTextSelector",
              "unmaskTextSelector",
              "inlineStylesheet",
              "maskInputOptions",
              "maskAttributeFn",
              "maskTextFn",
              "maskInputFn",
              "keepIframeSrcFn",
              "recordCanvas",
              "inlineImages",
              "slimDOMOptions",
              "dataURLOptions",
              "doc",
              "mirror",
              "iframeManager",
              "stylesheetManager",
              "shadowDomManager",
              "canvasManager",
              "processedNodeManager",
            ].forEach((t) => {
              this[t] = e[t];
            });
          }
          freeze() {
            (this.frozen = !0), this.canvasManager.freeze();
          }
          unfreeze() {
            (this.frozen = !1), this.canvasManager.unfreeze(), this.emit();
          }
          isFrozen() {
            return this.frozen;
          }
          lock() {
            (this.locked = !0), this.canvasManager.lock();
          }
          unlock() {
            (this.locked = !1), this.canvasManager.unlock(), this.emit();
          }
          reset() {
            this.shadowDomManager.reset(), this.canvasManager.reset();
          }
        }
        function Qe(e, t) {
          e.delete(t), t.childNodes.forEach((t) => Qe(e, t));
        }
        function et(e, t, n) {
          return 0 !== e.length && tt(e, t, n);
        }
        function tt(e, t, n) {
          const { parentNode: s } = t;
          if (!s) return !1;
          const i = n.getId(s);
          return !!e.some((e) => e.id === i) || tt(e, s, n);
        }
        function nt(e, t) {
          return 0 !== e.size && st(e, t);
        }
        function st(e, t) {
          const { parentNode: n } = t;
          return !!n && (!!e.has(n) || st(e, n));
        }
        let it;
        function ot(e) {
          it = e;
        }
        function at() {
          it = void 0;
        }
        const rt = (e) => {
          if (!it) return e;
          return (...t) => {
            try {
              return e(...t);
            } catch (e) {
              if (it && !0 === it(e)) return () => {};
              throw e;
            }
          };
        };
        function lt(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        const ct = [];
        function ut(e) {
          try {
            if ("composedPath" in e) {
              const t = e.composedPath();
              if (t.length) return t[0];
            } else if ("path" in e && e.path.length) return e.path[0];
          } catch (e) {}
          return e && e.target;
        }
        function mt(e, t) {
          const n = new Ze();
          ct.push(n), n.init(e);
          let s = window.MutationObserver || window.__rrMutationObserver;
          const i = lt([
            window,
            "optionalAccess",
            (e) => e.Zone,
            "optionalAccess",
            (e) => e.__symbol__,
            "optionalCall",
            (e) => e("MutationObserver"),
          ]);
          i && window[i] && (s = window[i]);
          const o = new s(
            rt((t) => {
              (e.onMutation && !1 === e.onMutation(t)) ||
                n.processMutations.bind(n)(t);
            }),
          );
          return (
            o.observe(t, {
              attributes: !0,
              attributeOldValue: !0,
              characterData: !0,
              characterDataOldValue: !0,
              childList: !0,
              subtree: !0,
            }),
            o
          );
        }
        function dt({
          mouseInteractionCb: e,
          doc: t,
          mirror: n,
          blockClass: s,
          blockSelector: i,
          unblockSelector: o,
          sampling: a,
        }) {
          if (!1 === a.mouseInteraction) return () => {};
          const r =
              !0 === a.mouseInteraction || void 0 === a.mouseInteraction
                ? {}
                : a.mouseInteraction,
            l = [];
          let c = null;
          return (
            Object.keys(Ve)
              .filter(
                (e) =>
                  Number.isNaN(Number(e)) &&
                  !e.endsWith("_Departed") &&
                  !1 !== r[e],
              )
              .forEach((a) => {
                let r = $(a);
                const u = ((t) => (a) => {
                  const r = ut(a);
                  if (De(r, s, i, o, !0)) return;
                  let l = null,
                    u = t;
                  if ("pointerType" in a) {
                    switch (a.pointerType) {
                      case "mouse":
                        l = ze.Mouse;
                        break;
                      case "touch":
                        l = ze.Touch;
                        break;
                      case "pen":
                        l = ze.Pen;
                    }
                    l === ze.Touch
                      ? Ve[t] === Ve.MouseDown
                        ? (u = "TouchStart")
                        : Ve[t] === Ve.MouseUp && (u = "TouchEnd")
                      : ze.Pen;
                  } else Ne(a) && (l = ze.Touch);
                  null !== l
                    ? ((c = l),
                      ((u.startsWith("Touch") && l === ze.Touch) ||
                        (u.startsWith("Mouse") && l === ze.Mouse)) &&
                        (l = null))
                    : Ve[t] === Ve.Click && ((l = c), (c = null));
                  const m = Ne(a) ? a.changedTouches[0] : a;
                  if (!m) return;
                  const d = n.getId(r),
                    { clientX: p, clientY: h } = m;
                  rt(e)({
                    type: Ve[u],
                    id: d,
                    x: p,
                    y: h,
                    ...(null !== l && { pointerType: l }),
                  });
                })(a);
                if (window.PointerEvent)
                  switch (Ve[a]) {
                    case Ve.MouseDown:
                    case Ve.MouseUp:
                      r = r.replace("mouse", "pointer");
                      break;
                    case Ve.TouchStart:
                    case Ve.TouchEnd:
                      return;
                  }
                l.push(ve(r, u, t));
              }),
            rt(() => {
              l.forEach((e) => e());
            })
          );
        }
        function pt({
          scrollCb: e,
          doc: t,
          mirror: n,
          blockClass: s,
          blockSelector: i,
          unblockSelector: o,
          sampling: a,
        }) {
          return ve(
            "scroll",
            rt(
              Ee(
                rt((a) => {
                  const r = ut(a);
                  if (!r || De(r, s, i, o, !0)) return;
                  const l = n.getId(r);
                  if (r === t && t.defaultView) {
                    const n = Ae(t.defaultView);
                    e({ id: l, x: n.left, y: n.top });
                  } else e({ id: l, x: r.scrollLeft, y: r.scrollTop });
                }),
                a.scroll || 100,
              ),
            ),
            t,
          );
        }
        const ht = ["INPUT", "TEXTAREA", "SELECT"],
          gt = new WeakMap();
        function ft({
          inputCb: e,
          doc: t,
          mirror: n,
          blockClass: s,
          blockSelector: i,
          unblockSelector: o,
          ignoreClass: a,
          ignoreSelector: r,
          maskInputOptions: l,
          maskInputFn: c,
          sampling: u,
          userTriggeredOnInput: m,
          maskTextClass: d,
          unmaskTextClass: p,
          maskTextSelector: h,
          unmaskTextSelector: g,
        }) {
          function f(e) {
            let n = ut(e);
            const u = e.isTrusted,
              f = n && V(n.tagName);
            if (
              ("OPTION" === f && (n = n.parentElement),
              !n || !f || ht.indexOf(f) < 0 || De(n, s, i, o, !0))
            )
              return;
            const b = n;
            if (b.classList.contains(a) || (r && b.matches(r))) return;
            const y = Y(n);
            let _ = K(b, f, y),
              v = !1;
            const x = W({ maskInputOptions: l, tagName: f, type: y }),
              k = fe(n, d, h, p, g, x);
            ("radio" !== y && "checkbox" !== y) || (v = n.checked),
              (_ = q({ isMasked: k, element: n, value: _, maskInputFn: c })),
              S(
                n,
                m
                  ? { text: _, isChecked: v, userTriggered: u }
                  : { text: _, isChecked: v },
              );
            const E = n.name;
            "radio" === y &&
              E &&
              v &&
              t
                .querySelectorAll(`input[type="radio"][name="${E}"]`)
                .forEach((e) => {
                  if (e !== n) {
                    const t = q({
                      isMasked: k,
                      element: e,
                      value: K(e, f, y),
                      maskInputFn: c,
                    });
                    S(
                      e,
                      m
                        ? { text: t, isChecked: !v, userTriggered: !1 }
                        : { text: t, isChecked: !v },
                    );
                  }
                });
          }
          function S(t, s) {
            const i = gt.get(t);
            if (!i || i.text !== s.text || i.isChecked !== s.isChecked) {
              gt.set(t, s);
              const i = n.getId(t);
              rt(e)({ ...s, id: i });
            }
          }
          const b = ("last" === u.input ? ["change"] : ["input", "change"]).map(
              (e) => ve(e, rt(f), t),
            ),
            y = t.defaultView;
          if (!y)
            return () => {
              b.forEach((e) => e());
            };
          const _ = y.Object.getOwnPropertyDescriptor(
              y.HTMLInputElement.prototype,
              "value",
            ),
            v = [
              [y.HTMLInputElement.prototype, "value"],
              [y.HTMLInputElement.prototype, "checked"],
              [y.HTMLSelectElement.prototype, "value"],
              [y.HTMLTextAreaElement.prototype, "value"],
              [y.HTMLSelectElement.prototype, "selectedIndex"],
              [y.HTMLOptionElement.prototype, "selected"],
            ];
          return (
            _ &&
              _.set &&
              b.push(
                ...v.map((e) =>
                  Te(
                    e[0],
                    e[1],
                    {
                      set() {
                        rt(f)({ target: this, isTrusted: !1 });
                      },
                    },
                    !1,
                    y,
                  ),
                ),
              ),
            rt(() => {
              b.forEach((e) => e());
            })
          );
        }
        function St(e) {
          return (function (e, t) {
            if (
              (vt("CSSGroupingRule") &&
                e.parentRule instanceof CSSGroupingRule) ||
              (vt("CSSMediaRule") && e.parentRule instanceof CSSMediaRule) ||
              (vt("CSSSupportsRule") &&
                e.parentRule instanceof CSSSupportsRule) ||
              (vt("CSSConditionRule") &&
                e.parentRule instanceof CSSConditionRule)
            ) {
              const n = Array.from(e.parentRule.cssRules).indexOf(e);
              t.unshift(n);
            } else if (e.parentStyleSheet) {
              const n = Array.from(e.parentStyleSheet.cssRules).indexOf(e);
              t.unshift(n);
            }
            return t;
          })(e, []);
        }
        function bt(e, t, n) {
          let s, i;
          return e
            ? (e.ownerNode ? (s = t.getId(e.ownerNode)) : (i = n.getId(e)),
              { styleId: i, id: s })
            : {};
        }
        function yt({ mirror: e, stylesheetManager: t }, n) {
          let s = null;
          s = "#document" === n.nodeName ? e.getId(n) : e.getId(n.host);
          const i =
              "#document" === n.nodeName
                ? lt([
                    n,
                    "access",
                    (e) => e.defaultView,
                    "optionalAccess",
                    (e) => e.Document,
                  ])
                : lt([
                    n,
                    "access",
                    (e) => e.ownerDocument,
                    "optionalAccess",
                    (e) => e.defaultView,
                    "optionalAccess",
                    (e) => e.ShadowRoot,
                  ]),
            o = lt([i, "optionalAccess", (e) => e.prototype])
              ? Object.getOwnPropertyDescriptor(
                  lt([i, "optionalAccess", (e) => e.prototype]),
                  "adoptedStyleSheets",
                )
              : void 0;
          return null !== s && -1 !== s && i && o
            ? (Object.defineProperty(n, "adoptedStyleSheets", {
                configurable: o.configurable,
                enumerable: o.enumerable,
                get() {
                  return lt([
                    o,
                    "access",
                    (e) => e.get,
                    "optionalAccess",
                    (e) => e.call,
                    "call",
                    (e) => e(this),
                  ]);
                },
                set(e) {
                  const n = lt([
                    o,
                    "access",
                    (e) => e.set,
                    "optionalAccess",
                    (e) => e.call,
                    "call",
                    (t) => t(this, e),
                  ]);
                  if (null !== s && -1 !== s)
                    try {
                      t.adoptStyleSheets(e, s);
                    } catch (e) {}
                  return n;
                },
              }),
              rt(() => {
                Object.defineProperty(n, "adoptedStyleSheets", {
                  configurable: o.configurable,
                  enumerable: o.enumerable,
                  get: o.get,
                  set: o.set,
                });
              }))
            : () => {};
        }
        function _t(e, t = {}) {
          const n = e.doc.defaultView;
          if (!n) return () => {};
          const s = mt(e, e.doc),
            i = (function ({ mousemoveCb: e, sampling: t, doc: n, mirror: s }) {
              if (!1 === t.mousemove) return () => {};
              const i = "number" == typeof t.mousemove ? t.mousemove : 50,
                o =
                  "number" == typeof t.mousemoveCallback
                    ? t.mousemoveCallback
                    : 500;
              let a,
                r = [];
              const l = Ee(
                  rt((t) => {
                    const n = Date.now() - a;
                    e(
                      r.map((e) => ((e.timeOffset -= n), e)),
                      t,
                    ),
                      (r = []),
                      (a = null);
                  }),
                  o,
                ),
                c = rt(
                  Ee(
                    rt((e) => {
                      const t = ut(e),
                        { clientX: n, clientY: i } = Ne(e)
                          ? e.changedTouches[0]
                          : e;
                      a || (a = Ie()),
                        r.push({
                          x: n,
                          y: i,
                          id: s.getId(t),
                          timeOffset: Ie() - a,
                        }),
                        l(
                          "undefined" != typeof DragEvent &&
                            e instanceof DragEvent
                            ? $e.Drag
                            : e instanceof MouseEvent
                              ? $e.MouseMove
                              : $e.TouchMove,
                        );
                    }),
                    i,
                    { trailing: !1 },
                  ),
                ),
                u = [
                  ve("mousemove", c, n),
                  ve("touchmove", c, n),
                  ve("drag", c, n),
                ];
              return rt(() => {
                u.forEach((e) => e());
              });
            })(e),
            o = dt(e),
            a = pt(e),
            r = (function ({ viewportResizeCb: e }, { win: t }) {
              let n = -1,
                s = -1;
              return ve(
                "resize",
                rt(
                  Ee(
                    rt(() => {
                      const t = Pe(),
                        i = Re();
                      (n === t && s === i) ||
                        (e({ width: Number(i), height: Number(t) }),
                        (n = t),
                        (s = i));
                    }),
                    200,
                  ),
                ),
                t,
              );
            })(e, { win: n }),
            l = ft(e),
            c = (function ({
              mediaInteractionCb: e,
              blockClass: t,
              blockSelector: n,
              unblockSelector: s,
              mirror: i,
              sampling: o,
              doc: a,
            }) {
              const r = rt((a) =>
                  Ee(
                    rt((o) => {
                      const r = ut(o);
                      if (!r || De(r, t, n, s, !0)) return;
                      const {
                        currentTime: l,
                        volume: c,
                        muted: u,
                        playbackRate: m,
                      } = r;
                      e({
                        type: a,
                        id: i.getId(r),
                        currentTime: l,
                        volume: c,
                        muted: u,
                        playbackRate: m,
                      });
                    }),
                    o.media || 500,
                  ),
                ),
                l = [
                  ve("play", r(0), a),
                  ve("pause", r(1), a),
                  ve("seeked", r(2), a),
                  ve("volumechange", r(3), a),
                  ve("ratechange", r(4), a),
                ];
              return rt(() => {
                l.forEach((e) => e());
              });
            })(e),
            u = (function (
              { styleSheetRuleCb: e, mirror: t, stylesheetManager: n },
              { win: s },
            ) {
              if (!s.CSSStyleSheet || !s.CSSStyleSheet.prototype)
                return () => {};
              const i = s.CSSStyleSheet.prototype.insertRule;
              s.CSSStyleSheet.prototype.insertRule = new Proxy(i, {
                apply: rt((s, i, o) => {
                  const [a, r] = o,
                    { id: l, styleId: c } = bt(i, t, n.styleMirror);
                  return (
                    ((l && -1 !== l) || (c && -1 !== c)) &&
                      e({ id: l, styleId: c, adds: [{ rule: a, index: r }] }),
                    s.apply(i, o)
                  );
                }),
              });
              const o = s.CSSStyleSheet.prototype.deleteRule;
              let a, r;
              (s.CSSStyleSheet.prototype.deleteRule = new Proxy(o, {
                apply: rt((s, i, o) => {
                  const [a] = o,
                    { id: r, styleId: l } = bt(i, t, n.styleMirror);
                  return (
                    ((r && -1 !== r) || (l && -1 !== l)) &&
                      e({ id: r, styleId: l, removes: [{ index: a }] }),
                    s.apply(i, o)
                  );
                }),
              })),
                s.CSSStyleSheet.prototype.replace &&
                  ((a = s.CSSStyleSheet.prototype.replace),
                  (s.CSSStyleSheet.prototype.replace = new Proxy(a, {
                    apply: rt((s, i, o) => {
                      const [a] = o,
                        { id: r, styleId: l } = bt(i, t, n.styleMirror);
                      return (
                        ((r && -1 !== r) || (l && -1 !== l)) &&
                          e({ id: r, styleId: l, replace: a }),
                        s.apply(i, o)
                      );
                    }),
                  }))),
                s.CSSStyleSheet.prototype.replaceSync &&
                  ((r = s.CSSStyleSheet.prototype.replaceSync),
                  (s.CSSStyleSheet.prototype.replaceSync = new Proxy(r, {
                    apply: rt((s, i, o) => {
                      const [a] = o,
                        { id: r, styleId: l } = bt(i, t, n.styleMirror);
                      return (
                        ((r && -1 !== r) || (l && -1 !== l)) &&
                          e({ id: r, styleId: l, replaceSync: a }),
                        s.apply(i, o)
                      );
                    }),
                  })));
              const l = {};
              xt("CSSGroupingRule")
                ? (l.CSSGroupingRule = s.CSSGroupingRule)
                : (xt("CSSMediaRule") && (l.CSSMediaRule = s.CSSMediaRule),
                  xt("CSSConditionRule") &&
                    (l.CSSConditionRule = s.CSSConditionRule),
                  xt("CSSSupportsRule") &&
                    (l.CSSSupportsRule = s.CSSSupportsRule));
              const c = {};
              return (
                Object.entries(l).forEach(([s, i]) => {
                  (c[s] = {
                    insertRule: i.prototype.insertRule,
                    deleteRule: i.prototype.deleteRule,
                  }),
                    (i.prototype.insertRule = new Proxy(c[s].insertRule, {
                      apply: rt((s, i, o) => {
                        const [a, r] = o,
                          { id: l, styleId: c } = bt(
                            i.parentStyleSheet,
                            t,
                            n.styleMirror,
                          );
                        return (
                          ((l && -1 !== l) || (c && -1 !== c)) &&
                            e({
                              id: l,
                              styleId: c,
                              adds: [{ rule: a, index: [...St(i), r || 0] }],
                            }),
                          s.apply(i, o)
                        );
                      }),
                    })),
                    (i.prototype.deleteRule = new Proxy(c[s].deleteRule, {
                      apply: rt((s, i, o) => {
                        const [a] = o,
                          { id: r, styleId: l } = bt(
                            i.parentStyleSheet,
                            t,
                            n.styleMirror,
                          );
                        return (
                          ((r && -1 !== r) || (l && -1 !== l)) &&
                            e({
                              id: r,
                              styleId: l,
                              removes: [{ index: [...St(i), a] }],
                            }),
                          s.apply(i, o)
                        );
                      }),
                    }));
                }),
                rt(() => {
                  (s.CSSStyleSheet.prototype.insertRule = i),
                    (s.CSSStyleSheet.prototype.deleteRule = o),
                    a && (s.CSSStyleSheet.prototype.replace = a),
                    r && (s.CSSStyleSheet.prototype.replaceSync = r),
                    Object.entries(l).forEach(([e, t]) => {
                      (t.prototype.insertRule = c[e].insertRule),
                        (t.prototype.deleteRule = c[e].deleteRule);
                    });
                })
              );
            })(e, { win: n }),
            m = yt(e, e.doc),
            d = (function (
              {
                styleDeclarationCb: e,
                mirror: t,
                ignoreCSSAttributes: n,
                stylesheetManager: s,
              },
              { win: i },
            ) {
              const o = i.CSSStyleDeclaration.prototype.setProperty;
              i.CSSStyleDeclaration.prototype.setProperty = new Proxy(o, {
                apply: rt((i, a, r) => {
                  const [l, c, u] = r;
                  if (n.has(l)) return o.apply(a, [l, c, u]);
                  const { id: m, styleId: d } = bt(
                    lt([
                      a,
                      "access",
                      (e) => e.parentRule,
                      "optionalAccess",
                      (e) => e.parentStyleSheet,
                    ]),
                    t,
                    s.styleMirror,
                  );
                  return (
                    ((m && -1 !== m) || (d && -1 !== d)) &&
                      e({
                        id: m,
                        styleId: d,
                        set: { property: l, value: c, priority: u },
                        index: St(a.parentRule),
                      }),
                    i.apply(a, r)
                  );
                }),
              });
              const a = i.CSSStyleDeclaration.prototype.removeProperty;
              return (
                (i.CSSStyleDeclaration.prototype.removeProperty = new Proxy(a, {
                  apply: rt((i, o, r) => {
                    const [l] = r;
                    if (n.has(l)) return a.apply(o, [l]);
                    const { id: c, styleId: u } = bt(
                      lt([
                        o,
                        "access",
                        (e) => e.parentRule,
                        "optionalAccess",
                        (e) => e.parentStyleSheet,
                      ]),
                      t,
                      s.styleMirror,
                    );
                    return (
                      ((c && -1 !== c) || (u && -1 !== u)) &&
                        e({
                          id: c,
                          styleId: u,
                          remove: { property: l },
                          index: St(o.parentRule),
                        }),
                      i.apply(o, r)
                    );
                  }),
                })),
                rt(() => {
                  (i.CSSStyleDeclaration.prototype.setProperty = o),
                    (i.CSSStyleDeclaration.prototype.removeProperty = a);
                })
              );
            })(e, { win: n }),
            p = e.collectFonts
              ? (function ({ fontCb: e, doc: t }) {
                  const n = t.defaultView;
                  if (!n) return () => {};
                  const s = [],
                    i = new WeakMap(),
                    o = n.FontFace;
                  n.FontFace = function (e, t, n) {
                    const s = new o(e, t, n);
                    return (
                      i.set(s, {
                        family: e,
                        buffer: "string" != typeof t,
                        descriptors: n,
                        fontSource:
                          "string" == typeof t
                            ? t
                            : JSON.stringify(Array.from(new Uint8Array(t))),
                      }),
                      s
                    );
                  };
                  const a = Ce(t.fonts, "add", function (t) {
                    return function (n) {
                      return (
                        setTimeout(
                          rt(() => {
                            const t = i.get(n);
                            t && (e(t), i.delete(n));
                          }),
                          0,
                        ),
                        t.apply(this, [n])
                      );
                    };
                  });
                  return (
                    s.push(() => {
                      n.FontFace = o;
                    }),
                    s.push(a),
                    rt(() => {
                      s.forEach((e) => e());
                    })
                  );
                })(e)
              : () => {},
            h = (function (e) {
              const {
                doc: t,
                mirror: n,
                blockClass: s,
                blockSelector: i,
                unblockSelector: o,
                selectionCb: a,
              } = e;
              let r = !0;
              const l = rt(() => {
                const e = t.getSelection();
                if (
                  !e ||
                  (r && lt([e, "optionalAccess", (e) => e.isCollapsed]))
                )
                  return;
                r = e.isCollapsed || !1;
                const l = [],
                  c = e.rangeCount || 0;
                for (let t = 0; t < c; t++) {
                  const a = e.getRangeAt(t),
                    {
                      startContainer: r,
                      startOffset: c,
                      endContainer: u,
                      endOffset: m,
                    } = a;
                  De(r, s, i, o, !0) ||
                    De(u, s, i, o, !0) ||
                    l.push({
                      start: n.getId(r),
                      startOffset: c,
                      end: n.getId(u),
                      endOffset: m,
                    });
                }
                a({ ranges: l });
              });
              return l(), ve("selectionchange", l);
            })(e),
            g = (function ({ doc: e, customElementCb: t }) {
              const n = e.defaultView;
              return n && n.customElements
                ? Ce(n.customElements, "define", function (e) {
                    return function (n, s, i) {
                      try {
                        t({ define: { name: n } });
                      } catch (e) {}
                      return e.apply(this, [n, s, i]);
                    };
                  })
                : () => {};
            })(e),
            f = [];
          for (const t of e.plugins)
            f.push(t.observer(t.callback, n, t.options));
          return rt(() => {
            ct.forEach((e) => e.reset()),
              s.disconnect(),
              i(),
              o(),
              a(),
              r(),
              l(),
              c(),
              u(),
              m(),
              d(),
              p(),
              h(),
              g(),
              f.forEach((e) => e());
          });
        }
        function vt(e) {
          return void 0 !== window[e];
        }
        function xt(e) {
          return Boolean(
            void 0 !== window[e] &&
              window[e].prototype &&
              "insertRule" in window[e].prototype &&
              "deleteRule" in window[e].prototype,
          );
        }
        class kt {
          constructor(e) {
            (this.generateIdFn = e),
              (this.iframeIdToRemoteIdMap = new WeakMap()),
              (this.iframeRemoteIdToIdMap = new WeakMap());
          }
          getId(e, t, n, s) {
            const i = n || this.getIdToRemoteIdMap(e),
              o = s || this.getRemoteIdToIdMap(e);
            let a = i.get(t);
            return (
              a || ((a = this.generateIdFn()), i.set(t, a), o.set(a, t)), a
            );
          }
          getIds(e, t) {
            const n = this.getIdToRemoteIdMap(e),
              s = this.getRemoteIdToIdMap(e);
            return t.map((t) => this.getId(e, t, n, s));
          }
          getRemoteId(e, t, n) {
            const s = n || this.getRemoteIdToIdMap(e);
            if ("number" != typeof t) return t;
            const i = s.get(t);
            return i || -1;
          }
          getRemoteIds(e, t) {
            const n = this.getRemoteIdToIdMap(e);
            return t.map((t) => this.getRemoteId(e, t, n));
          }
          reset(e) {
            if (!e)
              return (
                (this.iframeIdToRemoteIdMap = new WeakMap()),
                void (this.iframeRemoteIdToIdMap = new WeakMap())
              );
            this.iframeIdToRemoteIdMap.delete(e),
              this.iframeRemoteIdToIdMap.delete(e);
          }
          getIdToRemoteIdMap(e) {
            let t = this.iframeIdToRemoteIdMap.get(e);
            return (
              t || ((t = new Map()), this.iframeIdToRemoteIdMap.set(e, t)), t
            );
          }
          getRemoteIdToIdMap(e) {
            let t = this.iframeRemoteIdToIdMap.get(e);
            return (
              t || ((t = new Map()), this.iframeRemoteIdToIdMap.set(e, t)), t
            );
          }
        }
        function Et(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        class Tt {
          constructor() {
            (this.crossOriginIframeMirror = new kt(Q)),
              (this.crossOriginIframeRootIdMap = new WeakMap());
          }
          addIframe() {}
          addLoadListener() {}
          attachIframe() {}
        }
        class Ct {
          constructor(e) {
            (this.iframes = new WeakMap()),
              (this.crossOriginIframeMap = new WeakMap()),
              (this.crossOriginIframeMirror = new kt(Q)),
              (this.crossOriginIframeRootIdMap = new WeakMap()),
              (this.mutationCb = e.mutationCb),
              (this.wrappedEmit = e.wrappedEmit),
              (this.stylesheetManager = e.stylesheetManager),
              (this.recordCrossOriginIframes = e.recordCrossOriginIframes),
              (this.crossOriginIframeStyleMirror = new kt(
                this.stylesheetManager.styleMirror.generateId.bind(
                  this.stylesheetManager.styleMirror,
                ),
              )),
              (this.mirror = e.mirror),
              this.recordCrossOriginIframes &&
                window.addEventListener(
                  "message",
                  this.handleMessage.bind(this),
                );
          }
          addIframe(e) {
            this.iframes.set(e, !0),
              e.contentWindow &&
                this.crossOriginIframeMap.set(e.contentWindow, e);
          }
          addLoadListener(e) {
            this.loadListener = e;
          }
          attachIframe(e, t) {
            this.mutationCb({
              adds: [{ parentId: this.mirror.getId(e), nextId: null, node: t }],
              removes: [],
              texts: [],
              attributes: [],
              isAttachIframe: !0,
            }),
              Et([
                this,
                "access",
                (e) => e.loadListener,
                "optionalCall",
                (t) => t(e),
              ]),
              e.contentDocument &&
                e.contentDocument.adoptedStyleSheets &&
                e.contentDocument.adoptedStyleSheets.length > 0 &&
                this.stylesheetManager.adoptStyleSheets(
                  e.contentDocument.adoptedStyleSheets,
                  this.mirror.getId(e.contentDocument),
                );
          }
          handleMessage(e) {
            const t = e;
            if ("rrweb" !== t.data.type || t.origin !== t.data.origin) return;
            if (!e.source) return;
            const n = this.crossOriginIframeMap.get(e.source);
            if (!n) return;
            const s = this.transformCrossOriginEvent(n, t.data.event);
            s && this.wrappedEmit(s, t.data.isCheckout);
          }
          transformCrossOriginEvent(e, t) {
            switch (t.type) {
              case qe.FullSnapshot: {
                this.crossOriginIframeMirror.reset(e),
                  this.crossOriginIframeStyleMirror.reset(e),
                  this.replaceIdOnNode(t.data.node, e);
                const n = t.data.node.id;
                return (
                  this.crossOriginIframeRootIdMap.set(e, n),
                  this.patchRootIdOnNode(t.data.node, n),
                  {
                    timestamp: t.timestamp,
                    type: qe.IncrementalSnapshot,
                    data: {
                      source: $e.Mutation,
                      adds: [
                        {
                          parentId: this.mirror.getId(e),
                          nextId: null,
                          node: t.data.node,
                        },
                      ],
                      removes: [],
                      texts: [],
                      attributes: [],
                      isAttachIframe: !0,
                    },
                  }
                );
              }
              case qe.Meta:
              case qe.Load:
              case qe.DomContentLoaded:
                return !1;
              case qe.Plugin:
                return t;
              case qe.Custom:
                return (
                  this.replaceIds(t.data.payload, e, [
                    "id",
                    "parentId",
                    "previousId",
                    "nextId",
                  ]),
                  t
                );
              case qe.IncrementalSnapshot:
                switch (t.data.source) {
                  case $e.Mutation:
                    return (
                      t.data.adds.forEach((t) => {
                        this.replaceIds(t, e, [
                          "parentId",
                          "nextId",
                          "previousId",
                        ]),
                          this.replaceIdOnNode(t.node, e);
                        const n = this.crossOriginIframeRootIdMap.get(e);
                        n && this.patchRootIdOnNode(t.node, n);
                      }),
                      t.data.removes.forEach((t) => {
                        this.replaceIds(t, e, ["parentId", "id"]);
                      }),
                      t.data.attributes.forEach((t) => {
                        this.replaceIds(t, e, ["id"]);
                      }),
                      t.data.texts.forEach((t) => {
                        this.replaceIds(t, e, ["id"]);
                      }),
                      t
                    );
                  case $e.Drag:
                  case $e.TouchMove:
                  case $e.MouseMove:
                    return (
                      t.data.positions.forEach((t) => {
                        this.replaceIds(t, e, ["id"]);
                      }),
                      t
                    );
                  case $e.ViewportResize:
                    return !1;
                  case $e.MediaInteraction:
                  case $e.MouseInteraction:
                  case $e.Scroll:
                  case $e.CanvasMutation:
                  case $e.Input:
                    return this.replaceIds(t.data, e, ["id"]), t;
                  case $e.StyleSheetRule:
                  case $e.StyleDeclaration:
                    return (
                      this.replaceIds(t.data, e, ["id"]),
                      this.replaceStyleIds(t.data, e, ["styleId"]),
                      t
                    );
                  case $e.Font:
                    return t;
                  case $e.Selection:
                    return (
                      t.data.ranges.forEach((t) => {
                        this.replaceIds(t, e, ["start", "end"]);
                      }),
                      t
                    );
                  case $e.AdoptedStyleSheet:
                    return (
                      this.replaceIds(t.data, e, ["id"]),
                      this.replaceStyleIds(t.data, e, ["styleIds"]),
                      Et([
                        t,
                        "access",
                        (e) => e.data,
                        "access",
                        (e) => e.styles,
                        "optionalAccess",
                        (e) => e.forEach,
                        "call",
                        (t) =>
                          t((t) => {
                            this.replaceStyleIds(t, e, ["styleId"]);
                          }),
                      ]),
                      t
                    );
                }
            }
            return !1;
          }
          replace(e, t, n, s) {
            for (const i of s)
              (Array.isArray(t[i]) || "number" == typeof t[i]) &&
                (Array.isArray(t[i])
                  ? (t[i] = e.getIds(n, t[i]))
                  : (t[i] = e.getId(n, t[i])));
            return t;
          }
          replaceIds(e, t, n) {
            return this.replace(this.crossOriginIframeMirror, e, t, n);
          }
          replaceStyleIds(e, t, n) {
            return this.replace(this.crossOriginIframeStyleMirror, e, t, n);
          }
          replaceIdOnNode(e, t) {
            this.replaceIds(e, t, ["id", "rootId"]),
              "childNodes" in e &&
                e.childNodes.forEach((e) => {
                  this.replaceIdOnNode(e, t);
                });
          }
          patchRootIdOnNode(e, t) {
            e.type === B.Document || e.rootId || (e.rootId = t),
              "childNodes" in e &&
                e.childNodes.forEach((e) => {
                  this.patchRootIdOnNode(e, t);
                });
          }
        }
        class wt {
          init() {}
          addShadowRoot() {}
          observeAttachShadow() {}
          reset() {}
        }
        class It {
          constructor(e) {
            (this.shadowDoms = new WeakSet()),
              (this.restoreHandlers = []),
              (this.mutationCb = e.mutationCb),
              (this.scrollCb = e.scrollCb),
              (this.bypassOptions = e.bypassOptions),
              (this.mirror = e.mirror),
              this.init();
          }
          init() {
            this.reset(), this.patchAttachShadow(Element, document);
          }
          addShadowRoot(e, t) {
            if (!F(e)) return;
            if (this.shadowDoms.has(e)) return;
            this.shadowDoms.add(e);
            const n = mt(
              {
                ...this.bypassOptions,
                doc: t,
                mutationCb: this.mutationCb,
                mirror: this.mirror,
                shadowDomManager: this,
              },
              e,
            );
            this.restoreHandlers.push(() => n.disconnect()),
              this.restoreHandlers.push(
                pt({
                  ...this.bypassOptions,
                  scrollCb: this.scrollCb,
                  doc: e,
                  mirror: this.mirror,
                }),
              ),
              setTimeout(() => {
                e.adoptedStyleSheets &&
                  e.adoptedStyleSheets.length > 0 &&
                  this.bypassOptions.stylesheetManager.adoptStyleSheets(
                    e.adoptedStyleSheets,
                    this.mirror.getId(e.host),
                  ),
                  this.restoreHandlers.push(
                    yt(
                      {
                        mirror: this.mirror,
                        stylesheetManager: this.bypassOptions.stylesheetManager,
                      },
                      e,
                    ),
                  );
              }, 0);
          }
          observeAttachShadow(e) {
            e.contentWindow &&
              e.contentDocument &&
              this.patchAttachShadow(
                e.contentWindow.Element,
                e.contentDocument,
              );
          }
          patchAttachShadow(e, t) {
            const n = this;
            this.restoreHandlers.push(
              Ce(e.prototype, "attachShadow", function (e) {
                return function (s) {
                  const i = e.call(this, s);
                  return (
                    this.shadowRoot &&
                      Ge(this) &&
                      n.addShadowRoot(this.shadowRoot, t),
                    i
                  );
                };
              }),
            );
          }
          reset() {
            this.restoreHandlers.forEach((e) => {
              try {
                e();
              } catch (e) {}
            }),
              (this.restoreHandlers = []),
              (this.shadowDoms = new WeakSet());
          }
        }
        class At {
          reset() {}
          freeze() {}
          unfreeze() {}
          lock() {}
          unlock() {}
          snapshot() {}
        }
        class Pt {
          constructor(e) {
            (this.trackedLinkElements = new WeakSet()),
              (this.styleMirror = new Fe()),
              (this.mutationCb = e.mutationCb),
              (this.adoptedStyleSheetCb = e.adoptedStyleSheetCb);
          }
          attachLinkElement(e, t) {
            "_cssText" in t.attributes &&
              this.mutationCb({
                adds: [],
                removes: [],
                texts: [],
                attributes: [{ id: t.id, attributes: t.attributes }],
              }),
              this.trackLinkElement(e);
          }
          trackLinkElement(e) {
            this.trackedLinkElements.has(e) ||
              (this.trackedLinkElements.add(e),
              this.trackStylesheetInLinkElement(e));
          }
          adoptStyleSheets(e, t) {
            if (0 === e.length) return;
            const n = { id: t, styleIds: [] },
              s = [];
            for (const t of e) {
              let e;
              this.styleMirror.has(t)
                ? (e = this.styleMirror.getId(t))
                : ((e = this.styleMirror.add(t)),
                  s.push({
                    styleId: e,
                    rules: Array.from(t.rules || CSSRule, (e, t) => ({
                      rule: j(e),
                      index: t,
                    })),
                  })),
                n.styleIds.push(e);
            }
            s.length > 0 && (n.styles = s), this.adoptedStyleSheetCb(n);
          }
          reset() {
            this.styleMirror.reset(),
              (this.trackedLinkElements = new WeakSet());
          }
          trackStylesheetInLinkElement(e) {}
        }
        class Rt {
          constructor() {
            (this.nodeMap = new WeakMap()),
              (this.loop = !0),
              this.periodicallyClear();
          }
          periodicallyClear() {
            We(() => {
              this.clear(), this.loop && this.periodicallyClear();
            });
          }
          inOtherBuffer(e, t) {
            const n = this.nodeMap.get(e);
            return n && Array.from(n).some((e) => e !== t);
          }
          add(e, t) {
            this.nodeMap.set(e, (this.nodeMap.get(e) || new Set()).add(t));
          }
          clear() {
            this.nodeMap = new WeakMap();
          }
          destroy() {
            this.loop = !1;
          }
        }
        function Dt(e) {
          const t = e;
          return (t.timestamp = Ie()), t;
        }
        let Mt;
        const Ot = new G();
        function Nt(e = {}) {
          const {
            emit: t,
            checkoutEveryNms: n,
            checkoutEveryNth: s,
            blockClass: o = "rr-block",
            blockSelector: a = null,
            unblockSelector: r = null,
            ignoreClass: l = "rr-ignore",
            ignoreSelector: c = null,
            maskAllText: u = !1,
            maskTextClass: m = "rr-mask",
            unmaskTextClass: d = null,
            maskTextSelector: p = null,
            unmaskTextSelector: h = null,
            inlineStylesheet: g = !0,
            maskAllInputs: f,
            maskInputOptions: S,
            slimDOMOptions: b,
            maskAttributeFn: y,
            maskInputFn: _,
            maskTextFn: v,
            packFn: x,
            sampling: k = {},
            dataURLOptions: E = {},
            mousemoveWait: T,
            recordCanvas: C = !1,
            recordCrossOriginIframes: w = !1,
            recordAfter: I = "DOMContentLoaded" === e.recordAfter
              ? e.recordAfter
              : "load",
            userTriggeredOnInput: A = !1,
            collectFonts: P = !1,
            inlineImages: R = !1,
            plugins: D,
            keepIframeSrcFn: M = () => !1,
            ignoreCSSAttributes: O = new Set([]),
            errorHandler: N,
            onMutation: L,
            getCanvasManager: B,
          } = e;
          ot(N);
          const U = !w || window.parent === window;
          let F = !1;
          if (!U)
            try {
              window.parent.document && (F = !1);
            } catch (e) {
              F = !0;
            }
          if (U && !t) throw new Error("emit function is required");
          void 0 !== T && void 0 === k.mousemove && (k.mousemove = T),
            Ot.reset();
          const H =
              !0 === f
                ? {
                    color: !0,
                    date: !0,
                    "datetime-local": !0,
                    email: !0,
                    month: !0,
                    number: !0,
                    range: !0,
                    search: !0,
                    tel: !0,
                    text: !0,
                    time: !0,
                    url: !0,
                    week: !0,
                    textarea: !0,
                    select: !0,
                    radio: !0,
                    checkbox: !0,
                  }
                : void 0 !== S
                  ? S
                  : {},
            j =
              !0 === b || "all" === b
                ? {
                    script: !0,
                    comment: !0,
                    headFavicon: !0,
                    headWhitespace: !0,
                    headMetaSocial: !0,
                    headMetaRobots: !0,
                    headMetaHttpEquiv: !0,
                    headMetaVerification: !0,
                    headMetaAuthorship: "all" === b,
                    headMetaDescKeywords: "all" === b,
                  }
                : b || {};
          let W;
          !(function (e = window) {
            "NodeList" in e &&
              !e.NodeList.prototype.forEach &&
              (e.NodeList.prototype.forEach = Array.prototype.forEach),
              "DOMTokenList" in e &&
                !e.DOMTokenList.prototype.forEach &&
                (e.DOMTokenList.prototype.forEach = Array.prototype.forEach),
              Node.prototype.contains ||
                (Node.prototype.contains = (...e) => {
                  let t = e[0];
                  if (!(0 in e)) throw new TypeError("1 argument is required");
                  do {
                    if (this === t) return !0;
                  } while ((t = t && t.parentNode));
                  return !1;
                });
          })();
          let q = 0;
          const $ = (e) => {
              for (const t of D || [])
                t.eventProcessor && (e = t.eventProcessor(e));
              return x && !F && (e = x(e)), e;
            },
            V = (e, o) => {
              if (
                (!(0, i._optionalChain)([
                  ct,
                  "access",
                  (e) => e[0],
                  "optionalAccess",
                  (e) => e.isFrozen,
                  "call",
                  (e) => e(),
                ]) ||
                  e.type === qe.FullSnapshot ||
                  (e.type === qe.IncrementalSnapshot &&
                    e.data.source === $e.Mutation) ||
                  ct.forEach((e) => e.unfreeze()),
                U)
              )
                (0, i._optionalChain)([t, "optionalCall", (t) => t($(e), o)]);
              else if (F) {
                const t = {
                  type: "rrweb",
                  event: $(e),
                  origin: window.location.origin,
                  isCheckout: o,
                };
                window.parent.postMessage(t, "*");
              }
              if (e.type === qe.FullSnapshot) (W = e), (q = 0);
              else if (e.type === qe.IncrementalSnapshot) {
                if (e.data.source === $e.Mutation && e.data.isAttachIframe)
                  return;
                q++;
                const t = s && q >= s,
                  i = n && e.timestamp - W.timestamp > n;
                (t || i) && te(!0);
              }
            },
            z = (e) => {
              V(
                Dt({
                  type: qe.IncrementalSnapshot,
                  data: { source: $e.Mutation, ...e },
                }),
              );
            },
            Y = (e) =>
              V(
                Dt({
                  type: qe.IncrementalSnapshot,
                  data: { source: $e.Scroll, ...e },
                }),
              ),
            K = (e) =>
              V(
                Dt({
                  type: qe.IncrementalSnapshot,
                  data: { source: $e.CanvasMutation, ...e },
                }),
              ),
            J = new Pt({
              mutationCb: z,
              adoptedStyleSheetCb: (e) =>
                V(
                  Dt({
                    type: qe.IncrementalSnapshot,
                    data: { source: $e.AdoptedStyleSheet, ...e },
                  }),
                ),
            }),
            X =
              "boolean" == typeof __RRWEB_EXCLUDE_IFRAME__ &&
              __RRWEB_EXCLUDE_IFRAME__
                ? new Tt()
                : new Ct({
                    mirror: Ot,
                    mutationCb: z,
                    stylesheetManager: J,
                    recordCrossOriginIframes: w,
                    wrappedEmit: V,
                  });
          for (const e of D || [])
            e.getMirror &&
              e.getMirror({
                nodeMirror: Ot,
                crossOriginIframeMirror: X.crossOriginIframeMirror,
                crossOriginIframeStyleMirror: X.crossOriginIframeStyleMirror,
              });
          const Z = new Rt(),
            Q = (function (e, t) {
              try {
                return e ? e(t) : new At();
              } catch (e) {
                return (
                  console.warn("Unable to initialize CanvasManager"), new At()
                );
              }
            })(B, {
              mirror: Ot,
              win: window,
              mutationCb: (e) =>
                V(
                  Dt({
                    type: qe.IncrementalSnapshot,
                    data: { source: $e.CanvasMutation, ...e },
                  }),
                ),
              recordCanvas: C,
              blockClass: o,
              blockSelector: a,
              unblockSelector: r,
              sampling: k.canvas,
              dataURLOptions: E,
              errorHandler: N,
            }),
            ee =
              "boolean" == typeof __RRWEB_EXCLUDE_SHADOW_DOM__ &&
              __RRWEB_EXCLUDE_SHADOW_DOM__
                ? new wt()
                : new It({
                    mutationCb: z,
                    scrollCb: Y,
                    bypassOptions: {
                      onMutation: L,
                      blockClass: o,
                      blockSelector: a,
                      unblockSelector: r,
                      maskAllText: u,
                      maskTextClass: m,
                      unmaskTextClass: d,
                      maskTextSelector: p,
                      unmaskTextSelector: h,
                      inlineStylesheet: g,
                      maskInputOptions: H,
                      dataURLOptions: E,
                      maskAttributeFn: y,
                      maskTextFn: v,
                      maskInputFn: _,
                      recordCanvas: C,
                      inlineImages: R,
                      sampling: k,
                      slimDOMOptions: j,
                      iframeManager: X,
                      stylesheetManager: J,
                      canvasManager: Q,
                      keepIframeSrcFn: M,
                      processedNodeManager: Z,
                    },
                    mirror: Ot,
                  }),
            te = (e = !1) => {
              V(
                Dt({
                  type: qe.Meta,
                  data: {
                    href: window.location.href,
                    width: Re(),
                    height: Pe(),
                  },
                }),
                e,
              ),
                J.reset(),
                ee.init(),
                ct.forEach((e) => e.lock());
              const t = (function (e, t) {
                const {
                  mirror: n = new G(),
                  blockClass: s = "rr-block",
                  blockSelector: i = null,
                  unblockSelector: o = null,
                  maskAllText: a = !1,
                  maskTextClass: r = "rr-mask",
                  unmaskTextClass: l = null,
                  maskTextSelector: c = null,
                  unmaskTextSelector: u = null,
                  inlineStylesheet: m = !0,
                  inlineImages: d = !1,
                  recordCanvas: p = !1,
                  maskAllInputs: h = !1,
                  maskAttributeFn: g,
                  maskTextFn: f,
                  maskInputFn: S,
                  slimDOM: b = !1,
                  dataURLOptions: y,
                  preserveWhiteSpace: _,
                  onSerialize: v,
                  onIframeLoad: x,
                  iframeLoadTimeout: k,
                  onStylesheetLoad: E,
                  stylesheetLoadTimeout: T,
                  keepIframeSrcFn: C = () => !1,
                } = t || {};
                return ye(e, {
                  doc: e,
                  mirror: n,
                  blockClass: s,
                  blockSelector: i,
                  unblockSelector: o,
                  maskAllText: a,
                  maskTextClass: r,
                  unmaskTextClass: l,
                  maskTextSelector: c,
                  unmaskTextSelector: u,
                  skipChild: !1,
                  inlineStylesheet: m,
                  maskInputOptions:
                    !0 === h
                      ? {
                          color: !0,
                          date: !0,
                          "datetime-local": !0,
                          email: !0,
                          month: !0,
                          number: !0,
                          range: !0,
                          search: !0,
                          tel: !0,
                          text: !0,
                          time: !0,
                          url: !0,
                          week: !0,
                          textarea: !0,
                          select: !0,
                        }
                      : !1 === h
                        ? {}
                        : h,
                  maskAttributeFn: g,
                  maskTextFn: f,
                  maskInputFn: S,
                  slimDOMOptions:
                    !0 === b || "all" === b
                      ? {
                          script: !0,
                          comment: !0,
                          headFavicon: !0,
                          headWhitespace: !0,
                          headMetaDescKeywords: "all" === b,
                          headMetaSocial: !0,
                          headMetaRobots: !0,
                          headMetaHttpEquiv: !0,
                          headMetaAuthorship: !0,
                          headMetaVerification: !0,
                        }
                      : !1 === b
                        ? {}
                        : b,
                  dataURLOptions: y,
                  inlineImages: d,
                  recordCanvas: p,
                  preserveWhiteSpace: _,
                  onSerialize: v,
                  onIframeLoad: x,
                  iframeLoadTimeout: k,
                  onStylesheetLoad: E,
                  stylesheetLoadTimeout: T,
                  keepIframeSrcFn: C,
                  newlyAddedElement: !1,
                });
              })(document, {
                mirror: Ot,
                blockClass: o,
                blockSelector: a,
                unblockSelector: r,
                maskAllText: u,
                maskTextClass: m,
                unmaskTextClass: d,
                maskTextSelector: p,
                unmaskTextSelector: h,
                inlineStylesheet: g,
                maskAllInputs: H,
                maskAttributeFn: y,
                maskInputFn: _,
                maskTextFn: v,
                slimDOM: j,
                dataURLOptions: E,
                recordCanvas: C,
                inlineImages: R,
                onSerialize: (e) => {
                  Le(e, Ot) && X.addIframe(e),
                    Be(e, Ot) && J.trackLinkElement(e),
                    Ue(e) && ee.addShadowRoot(e.shadowRoot, document);
                },
                onIframeLoad: (e, t) => {
                  X.attachIframe(e, t), ee.observeAttachShadow(e);
                },
                onStylesheetLoad: (e, t) => {
                  J.attachLinkElement(e, t);
                },
                keepIframeSrcFn: M,
              });
              if (!t) return console.warn("Failed to snapshot the document");
              V(
                Dt({
                  type: qe.FullSnapshot,
                  data: { node: t, initialOffset: Ae(window) },
                }),
              ),
                ct.forEach((e) => e.unlock()),
                document.adoptedStyleSheets &&
                  document.adoptedStyleSheets.length > 0 &&
                  J.adoptStyleSheets(
                    document.adoptedStyleSheets,
                    Ot.getId(document),
                  );
            };
          Mt = te;
          try {
            const e = [],
              t = (e) =>
                rt(_t)(
                  {
                    onMutation: L,
                    mutationCb: z,
                    mousemoveCb: (e, t) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: t, positions: e },
                        }),
                      ),
                    mouseInteractionCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.MouseInteraction, ...e },
                        }),
                      ),
                    scrollCb: Y,
                    viewportResizeCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.ViewportResize, ...e },
                        }),
                      ),
                    inputCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.Input, ...e },
                        }),
                      ),
                    mediaInteractionCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.MediaInteraction, ...e },
                        }),
                      ),
                    styleSheetRuleCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.StyleSheetRule, ...e },
                        }),
                      ),
                    styleDeclarationCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.StyleDeclaration, ...e },
                        }),
                      ),
                    canvasMutationCb: K,
                    fontCb: (e) =>
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.Font, ...e },
                        }),
                      ),
                    selectionCb: (e) => {
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.Selection, ...e },
                        }),
                      );
                    },
                    customElementCb: (e) => {
                      V(
                        Dt({
                          type: qe.IncrementalSnapshot,
                          data: { source: $e.CustomElement, ...e },
                        }),
                      );
                    },
                    blockClass: o,
                    ignoreClass: l,
                    ignoreSelector: c,
                    maskAllText: u,
                    maskTextClass: m,
                    unmaskTextClass: d,
                    maskTextSelector: p,
                    unmaskTextSelector: h,
                    maskInputOptions: H,
                    inlineStylesheet: g,
                    sampling: k,
                    recordCanvas: C,
                    inlineImages: R,
                    userTriggeredOnInput: A,
                    collectFonts: P,
                    doc: e,
                    maskAttributeFn: y,
                    maskInputFn: _,
                    maskTextFn: v,
                    keepIframeSrcFn: M,
                    blockSelector: a,
                    unblockSelector: r,
                    slimDOMOptions: j,
                    dataURLOptions: E,
                    mirror: Ot,
                    iframeManager: X,
                    stylesheetManager: J,
                    shadowDomManager: ee,
                    processedNodeManager: Z,
                    canvasManager: Q,
                    ignoreCSSAttributes: O,
                    plugins:
                      (0, i._optionalChain)([
                        D,
                        "optionalAccess",
                        (e) => e.filter,
                        "call",
                        (e) => e((e) => e.observer),
                        "optionalAccess",
                        (e) => e.map,
                        "call",
                        (e) =>
                          e((e) => ({
                            observer: e.observer,
                            options: e.options,
                            callback: (t) =>
                              V(
                                Dt({
                                  type: qe.Plugin,
                                  data: { plugin: e.name, payload: t },
                                }),
                              ),
                          })),
                      ]) || [],
                  },
                  {},
                );
            X.addLoadListener((n) => {
              try {
                e.push(t(n.contentDocument));
              } catch (e) {
                console.warn(e);
              }
            });
            const n = () => {
              te(), e.push(t(document));
            };
            return (
              "interactive" === document.readyState ||
              "complete" === document.readyState
                ? n()
                : (e.push(
                    ve("DOMContentLoaded", () => {
                      V(Dt({ type: qe.DomContentLoaded, data: {} })),
                        "DOMContentLoaded" === I && n();
                    }),
                  ),
                  e.push(
                    ve(
                      "load",
                      () => {
                        V(Dt({ type: qe.Load, data: {} })), "load" === I && n();
                      },
                      window,
                    ),
                  )),
              () => {
                e.forEach((e) => e()), Z.destroy(), (Mt = void 0), at();
              }
            );
          } catch (e) {
            console.warn(e);
          }
        }
        (Nt.mirror = Ot),
          (Nt.takeFullSnapshot = function (e) {
            if (!Mt)
              throw new Error(
                "please take full snapshot after start recording",
              );
            Mt(e);
          });
        const Lt = 3;
        function Bt(e) {
          return e > 9999999999 ? e : 1e3 * e;
        }
        function Ut(e) {
          return e > 9999999999 ? e / 1e3 : e;
        }
        function Ft(e, t) {
          "sentry.transaction" !== t.category &&
            (["ui.click", "ui.input"].includes(t.category)
              ? e.triggerUserActivity()
              : e.checkAndHandleExpiredSession(),
            e.addUpdate(
              () => (
                e.throttledAddEvent({
                  type: qe.Custom,
                  timestamp: 1e3 * (t.timestamp || 0),
                  data: {
                    tag: "breadcrumb",
                    payload: (0, p.normalize)(t, 10, 1e3),
                  },
                }),
                "console" === t.category
              ),
            ));
        }
        const Ht = "button,a";
        function jt(e) {
          return e.closest(Ht) || e;
        }
        function Gt(e) {
          const t = Wt(e);
          return t && t instanceof Element ? jt(t) : t;
        }
        function Wt(e) {
          return (function (e) {
            return "object" == typeof e && !!e && "target" in e;
          })(e)
            ? e.target
            : e;
        }
        let qt;
        function $t(e) {
          return (
            qt ||
              ((qt = []),
              (0, h.fill)(I, "open", function (e) {
                return function (...t) {
                  if (qt)
                    try {
                      qt.forEach((e) => e());
                    } catch (e) {}
                  return e.apply(I, t);
                };
              })),
            qt.push(e),
            () => {
              const t = qt ? qt.indexOf(e) : -1;
              t > -1 && qt.splice(t, 1);
            }
          );
        }
        class Vt {
          constructor(e, t, n = Ft) {
            (this._lastMutation = 0),
              (this._lastScroll = 0),
              (this._clicks = []),
              (this._timeout = t.timeout / 1e3),
              (this._threshold = t.threshold / 1e3),
              (this._scollTimeout = t.scrollTimeout / 1e3),
              (this._replay = e),
              (this._ignoreSelector = t.ignoreSelector),
              (this._addBreadcrumbEvent = n);
          }
          addListeners() {
            const e = $t(() => {
              this._lastMutation = Yt();
            });
            this._teardown = () => {
              e(),
                (this._clicks = []),
                (this._lastMutation = 0),
                (this._lastScroll = 0);
            };
          }
          removeListeners() {
            this._teardown && this._teardown(),
              this._checkClickTimeout && clearTimeout(this._checkClickTimeout);
          }
          handleClick(e, t) {
            if (
              (function (e, t) {
                if (!zt.includes(e.tagName)) return !0;
                if (
                  "INPUT" === e.tagName &&
                  !["submit", "button"].includes(e.getAttribute("type") || "")
                )
                  return !0;
                if (
                  "A" === e.tagName &&
                  (e.hasAttribute("download") ||
                    (e.hasAttribute("target") &&
                      "_self" !== e.getAttribute("target")))
                )
                  return !0;
                if (t && e.matches(t)) return !0;
                return !1;
              })(t, this._ignoreSelector) ||
              !(function (e) {
                return !(
                  !e.data ||
                  "number" != typeof e.data.nodeId ||
                  !e.timestamp
                );
              })(e)
            )
              return;
            const n = {
              timestamp: Ut(e.timestamp),
              clickBreadcrumb: e,
              clickCount: 0,
              node: t,
            };
            this._clicks.some(
              (e) =>
                e.node === n.node && Math.abs(e.timestamp - n.timestamp) < 1,
            ) ||
              (this._clicks.push(n),
              1 === this._clicks.length && this._scheduleCheckClicks());
          }
          registerMutation(e = Date.now()) {
            this._lastMutation = Ut(e);
          }
          registerScroll(e = Date.now()) {
            this._lastScroll = Ut(e);
          }
          registerClick(e) {
            const t = jt(e);
            this._handleMultiClick(t);
          }
          _handleMultiClick(e) {
            this._getClicks(e).forEach((e) => {
              e.clickCount++;
            });
          }
          _getClicks(e) {
            return this._clicks.filter((t) => t.node === e);
          }
          _checkClicks() {
            const e = [],
              t = Yt();
            this._clicks.forEach((n) => {
              !n.mutationAfter &&
                this._lastMutation &&
                (n.mutationAfter =
                  n.timestamp <= this._lastMutation
                    ? this._lastMutation - n.timestamp
                    : void 0),
                !n.scrollAfter &&
                  this._lastScroll &&
                  (n.scrollAfter =
                    n.timestamp <= this._lastScroll
                      ? this._lastScroll - n.timestamp
                      : void 0),
                n.timestamp + this._timeout <= t && e.push(n);
            });
            for (const t of e) {
              const e = this._clicks.indexOf(t);
              e > -1 &&
                (this._generateBreadcrumbs(t), this._clicks.splice(e, 1));
            }
            this._clicks.length && this._scheduleCheckClicks();
          }
          _generateBreadcrumbs(e) {
            const t = this._replay,
              n = e.scrollAfter && e.scrollAfter <= this._scollTimeout,
              s = e.mutationAfter && e.mutationAfter <= this._threshold,
              i = !n && !s,
              { clickCount: o, clickBreadcrumb: a } = e;
            if (i) {
              const n =
                  1e3 *
                  Math.min(e.mutationAfter || this._timeout, this._timeout),
                s = n < 1e3 * this._timeout ? "mutation" : "timeout",
                i = {
                  type: "default",
                  message: a.message,
                  timestamp: a.timestamp,
                  category: "ui.slowClickDetected",
                  data: {
                    ...a.data,
                    url: I.location.href,
                    route: t.getCurrentRoute(),
                    timeAfterClickMs: n,
                    endReason: s,
                    clickCount: o || 1,
                  },
                };
              this._addBreadcrumbEvent(t, i);
            } else if (o > 1) {
              const e = {
                type: "default",
                message: a.message,
                timestamp: a.timestamp,
                category: "ui.multiClick",
                data: {
                  ...a.data,
                  url: I.location.href,
                  route: t.getCurrentRoute(),
                  clickCount: o,
                  metric: !0,
                },
              };
              this._addBreadcrumbEvent(t, e);
            }
          }
          _scheduleCheckClicks() {
            this._checkClickTimeout && clearTimeout(this._checkClickTimeout),
              (this._checkClickTimeout = setTimeout(
                () => this._checkClicks(),
                1e3,
              ));
          }
        }
        const zt = ["A", "BUTTON", "INPUT"];
        function Yt() {
          return Date.now() / 1e3;
        }
        function Kt(e, t) {
          try {
            if (
              !(function (e) {
                return e.type === Lt;
              })(t)
            )
              return;
            const { source: n } = t.data;
            if (
              (n === $e.Mutation && e.registerMutation(t.timestamp),
              n === $e.Scroll && e.registerScroll(t.timestamp),
              (function (e) {
                return e.data.source === $e.MouseInteraction;
              })(t))
            ) {
              const { type: n, id: s } = t.data,
                i = Nt.mirror.getNode(s);
              i instanceof HTMLElement && n === Ve.Click && e.registerClick(i);
            }
          } catch (e) {}
        }
        function Jt(e) {
          return { timestamp: Date.now() / 1e3, type: "default", ...e };
        }
        var Xt;
        !(function (e) {
          (e[(e.Document = 0)] = "Document"),
            (e[(e.DocumentType = 1)] = "DocumentType"),
            (e[(e.Element = 2)] = "Element"),
            (e[(e.Text = 3)] = "Text"),
            (e[(e.CDATA = 4)] = "CDATA"),
            (e[(e.Comment = 5)] = "Comment");
        })(Xt || (Xt = {}));
        const Zt = new Set([
          "id",
          "class",
          "aria-label",
          "role",
          "name",
          "alt",
          "title",
          "data-test-id",
          "data-testid",
          "disabled",
          "aria-disabled",
          "data-sentry-component",
        ]);
        function Qt(e) {
          const t = {};
          for (const n in e)
            if (Zt.has(n)) {
              let s = n;
              ("data-testid" !== n && "data-test-id" !== n) || (s = "testId"),
                (t[s] = e[n]);
            }
          return t;
        }
        const en = (e) => (t) => {
          if (!e.isEnabled()) return;
          const n = (function (e) {
            const { target: t, message: n } = (function (e) {
              const t = "click" === e.name;
              let n,
                s = null;
              try {
                (s = t ? Gt(e.event) : Wt(e.event)),
                  (n =
                    (0, g.htmlTreeAsString)(s, { maxStringLength: 200 }) ||
                    "<unknown>");
              } catch (e) {
                n = "<unknown>";
              }
              return { target: s, message: n };
            })(e);
            return Jt({ category: `ui.${e.name}`, ...tn(t, n) });
          })(t);
          if (!n) return;
          const s = "click" === t.name,
            i = s ? t.event : void 0;
          var o, a, r;
          !(s && e.clickDetector && i && i.target) ||
            i.altKey ||
            i.metaKey ||
            i.ctrlKey ||
            i.shiftKey ||
            ((o = e.clickDetector),
            (a = n),
            (r = Gt(t.event)),
            o.handleClick(a, r)),
            Ft(e, n);
        };
        function tn(e, t) {
          const n = Nt.mirror.getId(e),
            s = n && Nt.mirror.getNode(n),
            i = s && Nt.mirror.getMeta(s),
            o =
              i &&
              (function (e) {
                return e.type === Xt.Element;
              })(i)
                ? i
                : null;
          return {
            message: t,
            data: o
              ? {
                  nodeId: n,
                  node: {
                    id: n,
                    tagName: o.tagName,
                    textContent: Array.from(o.childNodes)
                      .map((e) => e.type === Xt.Text && e.textContent)
                      .filter(Boolean)
                      .map((e) => e.trim())
                      .join(""),
                    attributes: Qt(o.attributes),
                  },
                }
              : {},
          };
        }
        function nn(e, t) {
          if (!e.isEnabled()) return;
          e.updateUserActivity();
          const n = (function (e) {
            const {
              metaKey: t,
              shiftKey: n,
              ctrlKey: s,
              altKey: i,
              key: o,
              target: a,
            } = e;
            if (
              !a ||
              (function (e) {
                return (
                  "INPUT" === e.tagName ||
                  "TEXTAREA" === e.tagName ||
                  e.isContentEditable
                );
              })(a) ||
              !o
            )
              return null;
            const r = t || s || i,
              l = 1 === o.length;
            if (!r && l) return null;
            const c =
                (0, g.htmlTreeAsString)(a, { maxStringLength: 200 }) ||
                "<unknown>",
              u = tn(a, c);
            return Jt({
              category: "ui.keyDown",
              message: c,
              data: {
                ...u.data,
                metaKey: t,
                shiftKey: n,
                ctrlKey: s,
                altKey: i,
                key: o,
              },
            });
          })(t);
          n && Ft(e, n);
        }
        const sn = {
          resource: function (e) {
            const {
              entryType: t,
              initiatorType: n,
              name: s,
              responseEnd: i,
              startTime: o,
              decodedBodySize: a,
              encodedBodySize: r,
              responseStatus: l,
              transferSize: c,
            } = e;
            if (["fetch", "xmlhttprequest"].includes(n)) return null;
            return {
              type: `${t}.${n}`,
              start: an(o),
              end: an(i),
              name: s,
              data: {
                size: c,
                statusCode: l,
                decodedBodySize: a,
                encodedBodySize: r,
              },
            };
          },
          paint: function (e) {
            const { duration: t, entryType: n, name: s, startTime: i } = e,
              o = an(i);
            return { type: n, name: s, start: o, end: o + t, data: void 0 };
          },
          navigation: function (e) {
            const {
              entryType: t,
              name: n,
              decodedBodySize: s,
              duration: i,
              domComplete: o,
              encodedBodySize: a,
              domContentLoadedEventStart: r,
              domContentLoadedEventEnd: l,
              domInteractive: c,
              loadEventStart: u,
              loadEventEnd: m,
              redirectCount: d,
              startTime: p,
              transferSize: h,
              type: g,
            } = e;
            if (0 === i) return null;
            return {
              type: `${t}.${g}`,
              start: an(p),
              end: an(o),
              name: n,
              data: {
                size: h,
                decodedBodySize: s,
                encodedBodySize: a,
                duration: i,
                domInteractive: c,
                domContentLoadedEventStart: r,
                domContentLoadedEventEnd: l,
                loadEventStart: u,
                loadEventEnd: m,
                domComplete: o,
                redirectCount: d,
              },
            };
          },
        };
        function on(e) {
          return sn[e.entryType] ? sn[e.entryType](e) : null;
        }
        function an(e) {
          return (
            ((f.browserPerformanceTimeOrigin || I.performance.timeOrigin) + e) /
            1e3
          );
        }
        function rn(e) {
          function t(t) {
            e.performanceEntries.includes(t) || e.performanceEntries.push(t);
          }
          function n({ entries: e }) {
            e.forEach(t);
          }
          const s = [];
          return (
            ["navigation", "paint", "resource"].forEach((e) => {
              s.push((0, w.addPerformanceInstrumentationHandler)(e, n));
            }),
            s.push(
              (0, w.addLcpInstrumentationHandler)(({ metric: t }) => {
                e.replayPerformanceEntries.push(
                  (function (e) {
                    const t = e.entries,
                      n = t[t.length - 1],
                      s = n ? n.element : void 0,
                      i = e.value,
                      o = an(i);
                    return {
                      type: "largest-contentful-paint",
                      name: "largest-contentful-paint",
                      start: o,
                      end: o,
                      data: {
                        value: i,
                        size: i,
                        nodeId: s ? Nt.mirror.getId(s) : void 0,
                      },
                    };
                  })(t),
                );
              }),
            ),
            () => {
              s.forEach((e) => e());
            }
          );
        }
        const ln = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__,
          cn =
            'var t=Uint8Array,n=Uint16Array,r=Int32Array,e=new t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),a=new t([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),s=function(t,e){for(var i=new n(31),a=0;a<31;++a)i[a]=e+=1<<t[a-1];var s=new r(i[30]);for(a=1;a<30;++a)for(var o=i[a];o<i[a+1];++o)s[o]=o-i[a]<<5|a;return{b:i,r:s}},o=s(e,2),f=o.b,h=o.r;f[28]=258,h[258]=28;for(var l=s(i,0).r,u=new n(32768),c=0;c<32768;++c){var v=(43690&c)>>1|(21845&c)<<1;v=(61680&(v=(52428&v)>>2|(13107&v)<<2))>>4|(3855&v)<<4,u[c]=((65280&v)>>8|(255&v)<<8)>>1}var d=function(t,r,e){for(var i=t.length,a=0,s=new n(r);a<i;++a)t[a]&&++s[t[a]-1];var o,f=new n(r);for(a=1;a<r;++a)f[a]=f[a-1]+s[a-1]<<1;if(e){o=new n(1<<r);var h=15-r;for(a=0;a<i;++a)if(t[a])for(var l=a<<4|t[a],c=r-t[a],v=f[t[a]-1]++<<c,d=v|(1<<c)-1;v<=d;++v)o[u[v]>>h]=l}else for(o=new n(i),a=0;a<i;++a)t[a]&&(o[a]=u[f[t[a]-1]++]>>15-t[a]);return o},g=new t(288);for(c=0;c<144;++c)g[c]=8;for(c=144;c<256;++c)g[c]=9;for(c=256;c<280;++c)g[c]=7;for(c=280;c<288;++c)g[c]=8;var w=new t(32);for(c=0;c<32;++c)w[c]=5;var p=d(g,9,0),y=d(w,5,0),m=function(t){return(t+7)/8|0},b=function(n,r,e){return(null==r||r<0)&&(r=0),(null==e||e>n.length)&&(e=n.length),new t(n.subarray(r,e))},M=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],E=function(t,n,r){var e=new Error(n||M[t]);if(e.code=t,Error.captureStackTrace&&Error.captureStackTrace(e,E),!r)throw e;return e},z=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8},A=function(t,n,r){r<<=7&n;var e=n/8|0;t[e]|=r,t[e+1]|=r>>8,t[e+2]|=r>>16},_=function(r,e){for(var i=[],a=0;a<r.length;++a)r[a]&&i.push({s:a,f:r[a]});var s=i.length,o=i.slice();if(!s)return{t:F,l:0};if(1==s){var f=new t(i[0].s+1);return f[i[0].s]=1,{t:f,l:1}}i.sort((function(t,n){return t.f-n.f})),i.push({s:-1,f:25001});var h=i[0],l=i[1],u=0,c=1,v=2;for(i[0]={s:-1,f:h.f+l.f,l:h,r:l};c!=s-1;)h=i[i[u].f<i[v].f?u++:v++],l=i[u!=c&&i[u].f<i[v].f?u++:v++],i[c++]={s:-1,f:h.f+l.f,l:h,r:l};var d=o[0].s;for(a=1;a<s;++a)o[a].s>d&&(d=o[a].s);var g=new n(d+1),w=x(i[c-1],g,0);if(w>e){a=0;var p=0,y=w-e,m=1<<y;for(o.sort((function(t,n){return g[n.s]-g[t.s]||t.f-n.f}));a<s;++a){var b=o[a].s;if(!(g[b]>e))break;p+=m-(1<<w-g[b]),g[b]=e}for(p>>=y;p>0;){var M=o[a].s;g[M]<e?p-=1<<e-g[M]++-1:++a}for(;a>=0&&p;--a){var E=o[a].s;g[E]==e&&(--g[E],++p)}w=e}return{t:new t(g),l:w}},x=function(t,n,r){return-1==t.s?Math.max(x(t.l,n,r+1),x(t.r,n,r+1)):n[t.s]=r},D=function(t){for(var r=t.length;r&&!t[--r];);for(var e=new n(++r),i=0,a=t[0],s=1,o=function(t){e[i++]=t},f=1;f<=r;++f)if(t[f]==a&&f!=r)++s;else{if(!a&&s>2){for(;s>138;s-=138)o(32754);s>2&&(o(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(o(a),--s;s>6;s-=6)o(8304);s>2&&(o(s-3<<5|8208),s=0)}for(;s--;)o(a);s=1,a=t[f]}return{c:e.subarray(0,i),n:r}},T=function(t,n){for(var r=0,e=0;e<n.length;++e)r+=t[e]*n[e];return r},k=function(t,n,r){var e=r.length,i=m(n+2);t[i]=255&e,t[i+1]=e>>8,t[i+2]=255^t[i],t[i+3]=255^t[i+1];for(var a=0;a<e;++a)t[i+a+4]=r[a];return 8*(i+4+e)},C=function(t,r,s,o,f,h,l,u,c,v,m){z(r,m++,s),++f[256];for(var b=_(f,15),M=b.t,E=b.l,x=_(h,15),C=x.t,U=x.l,F=D(M),I=F.c,S=F.n,L=D(C),O=L.c,j=L.n,q=new n(19),B=0;B<I.length;++B)++q[31&I[B]];for(B=0;B<O.length;++B)++q[31&O[B]];for(var G=_(q,7),H=G.t,J=G.l,K=19;K>4&&!H[a[K-1]];--K);var N,P,Q,R,V=v+5<<3,W=T(f,g)+T(h,w)+l,X=T(f,M)+T(h,C)+l+14+3*K+T(q,H)+2*q[16]+3*q[17]+7*q[18];if(c>=0&&V<=W&&V<=X)return k(r,m,t.subarray(c,c+v));if(z(r,m,1+(X<W)),m+=2,X<W){N=d(M,E,0),P=M,Q=d(C,U,0),R=C;var Y=d(H,J,0);z(r,m,S-257),z(r,m+5,j-1),z(r,m+10,K-4),m+=14;for(B=0;B<K;++B)z(r,m+3*B,H[a[B]]);m+=3*K;for(var Z=[I,O],$=0;$<2;++$){var tt=Z[$];for(B=0;B<tt.length;++B){var nt=31&tt[B];z(r,m,Y[nt]),m+=H[nt],nt>15&&(z(r,m,tt[B]>>5&127),m+=tt[B]>>12)}}}else N=p,P=g,Q=y,R=w;for(B=0;B<u;++B){var rt=o[B];if(rt>255){A(r,m,N[(nt=rt>>18&31)+257]),m+=P[nt+257],nt>7&&(z(r,m,rt>>23&31),m+=e[nt]);var et=31&rt;A(r,m,Q[et]),m+=R[et],et>3&&(A(r,m,rt>>5&8191),m+=i[et])}else A(r,m,N[rt]),m+=P[rt]}return A(r,m,N[256]),m+P[256]},U=new r([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),F=new t(0),I=function(){for(var t=new Int32Array(256),n=0;n<256;++n){for(var r=n,e=9;--e;)r=(1&r&&-306674912)^r>>>1;t[n]=r}return t}(),S=function(){var t=1,n=0;return{p:function(r){for(var e=t,i=n,a=0|r.length,s=0;s!=a;){for(var o=Math.min(s+2655,a);s<o;++s)i+=e+=r[s];e=(65535&e)+15*(e>>16),i=(65535&i)+15*(i>>16)}t=e,n=i},d:function(){return(255&(t%=65521))<<24|(65280&t)<<8|(255&(n%=65521))<<8|n>>8}}},L=function(a,s,o,f,u){if(!u&&(u={l:1},s.dictionary)){var c=s.dictionary.subarray(-32768),v=new t(c.length+a.length);v.set(c),v.set(a,c.length),a=v,u.w=c.length}return function(a,s,o,f,u,c){var v=c.z||a.length,d=new t(f+v+5*(1+Math.ceil(v/7e3))+u),g=d.subarray(f,d.length-u),w=c.l,p=7&(c.r||0);if(s){p&&(g[0]=c.r>>3);for(var y=U[s-1],M=y>>13,E=8191&y,z=(1<<o)-1,A=c.p||new n(32768),_=c.h||new n(z+1),x=Math.ceil(o/3),D=2*x,T=function(t){return(a[t]^a[t+1]<<x^a[t+2]<<D)&z},F=new r(25e3),I=new n(288),S=new n(32),L=0,O=0,j=c.i||0,q=0,B=c.w||0,G=0;j+2<v;++j){var H=T(j),J=32767&j,K=_[H];if(A[J]=K,_[H]=J,B<=j){var N=v-j;if((L>7e3||q>24576)&&(N>423||!w)){p=C(a,g,0,F,I,S,O,q,G,j-G,p),q=L=O=0,G=j;for(var P=0;P<286;++P)I[P]=0;for(P=0;P<30;++P)S[P]=0}var Q=2,R=0,V=E,W=J-K&32767;if(N>2&&H==T(j-W))for(var X=Math.min(M,N)-1,Y=Math.min(32767,j),Z=Math.min(258,N);W<=Y&&--V&&J!=K;){if(a[j+Q]==a[j+Q-W]){for(var $=0;$<Z&&a[j+$]==a[j+$-W];++$);if($>Q){if(Q=$,R=W,$>X)break;var tt=Math.min(W,$-2),nt=0;for(P=0;P<tt;++P){var rt=j-W+P&32767,et=rt-A[rt]&32767;et>nt&&(nt=et,K=rt)}}}W+=(J=K)-(K=A[J])&32767}if(R){F[q++]=268435456|h[Q]<<18|l[R];var it=31&h[Q],at=31&l[R];O+=e[it]+i[at],++I[257+it],++S[at],B=j+Q,++L}else F[q++]=a[j],++I[a[j]]}}for(j=Math.max(j,B);j<v;++j)F[q++]=a[j],++I[a[j]];p=C(a,g,w,F,I,S,O,q,G,j-G,p),w||(c.r=7&p|g[p/8|0]<<3,p-=7,c.h=_,c.p=A,c.i=j,c.w=B)}else{for(j=c.w||0;j<v+w;j+=65535){var st=j+65535;st>=v&&(g[p/8|0]=w,st=v),p=k(g,p+1,a.subarray(j,st))}c.i=v}return b(d,0,f+m(p)+u)}(a,null==s.level?6:s.level,null==s.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(a.length)))):12+s.mem,o,f,u)},O=function(t,n,r){for(;r;++n)t[n]=r,r>>>=8},j=function(){function n(n,r){if("function"==typeof n&&(r=n,n={}),this.ondata=r,this.o=n||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new t(98304),this.o.dictionary){var e=this.o.dictionary.subarray(-32768);this.b.set(e,32768-e.length),this.s.i=32768-e.length}}return n.prototype.p=function(t,n){this.ondata(L(t,this.o,0,0,this.s),n)},n.prototype.push=function(n,r){this.ondata||E(5),this.s.l&&E(4);var e=n.length+this.s.z;if(e>this.b.length){if(e>2*this.b.length-32768){var i=new t(-32768&e);i.set(this.b.subarray(0,this.s.z)),this.b=i}var a=this.b.length-this.s.z;a&&(this.b.set(n.subarray(0,a),this.s.z),this.s.z=this.b.length,this.p(this.b,!1)),this.b.set(this.b.subarray(-32768)),this.b.set(n.subarray(a),32768),this.s.z=n.length-a+32768,this.s.i=32766,this.s.w=32768}else this.b.set(n,this.s.z),this.s.z+=n.length;this.s.l=1&r,(this.s.z>this.s.w+8191||r)&&(this.p(this.b,r||!1),this.s.w=this.s.i,this.s.i-=2)},n}();function q(t,n){n||(n={});var r=function(){var t=-1;return{p:function(n){for(var r=t,e=0;e<n.length;++e)r=I[255&r^n[e]]^r>>>8;t=r},d:function(){return~t}}}(),e=t.length;r.p(t);var i,a=L(t,n,10+((i=n).filename?i.filename.length+1:0),8),s=a.length;return function(t,n){var r=n.filename;if(t[0]=31,t[1]=139,t[2]=8,t[8]=n.level<2?4:9==n.level?2:0,t[9]=3,0!=n.mtime&&O(t,4,Math.floor(new Date(n.mtime||Date.now())/1e3)),r){t[3]=8;for(var e=0;e<=r.length;++e)t[e+10]=r.charCodeAt(e)}}(a,n),O(a,s-8,r.d()),O(a,s-4,e),a}var B=function(){function t(t,n){this.c=S(),this.v=1,j.call(this,t,n)}return t.prototype.push=function(t,n){this.c.p(t),j.prototype.push.call(this,t,n)},t.prototype.p=function(t,n){var r=L(t,this.o,this.v&&(this.o.dictionary?6:2),n&&4,this.s);this.v&&(function(t,n){var r=n.level,e=0==r?0:r<6?1:9==r?3:2;if(t[0]=120,t[1]=e<<6|(n.dictionary&&32),t[1]|=31-(t[0]<<8|t[1])%31,n.dictionary){var i=S();i.p(n.dictionary),O(t,2,i.d())}}(r,this.o),this.v=0),n&&O(r,r.length-4,this.c.d()),this.ondata(r,n)},t}(),G="undefined"!=typeof TextEncoder&&new TextEncoder,H="undefined"!=typeof TextDecoder&&new TextDecoder;try{H.decode(F,{stream:!0})}catch(t){}var J=function(){function t(t){this.ondata=t}return t.prototype.push=function(t,n){this.ondata||E(5),this.d&&E(4),this.ondata(K(t),this.d=n||!1)},t}();function K(n,r){if(r){for(var e=new t(n.length),i=0;i<n.length;++i)e[i]=n.charCodeAt(i);return e}if(G)return G.encode(n);var a=n.length,s=new t(n.length+(n.length>>1)),o=0,f=function(t){s[o++]=t};for(i=0;i<a;++i){if(o+5>s.length){var h=new t(o+8+(a-i<<1));h.set(s),s=h}var l=n.charCodeAt(i);l<128||r?f(l):l<2048?(f(192|l>>6),f(128|63&l)):l>55295&&l<57344?(f(240|(l=65536+(1047552&l)|1023&n.charCodeAt(++i))>>18),f(128|l>>12&63),f(128|l>>6&63),f(128|63&l)):(f(224|l>>12),f(128|l>>6&63),f(128|63&l))}return b(s,0,o)}const N=new class{constructor(){this._init()}clear(){this._init()}addEvent(t){if(!t)throw new Error("Adding invalid event");const n=this._hasEvents?",":"";this.stream.push(n+t),this._hasEvents=!0}finish(){this.stream.push("]",!0);const t=function(t){let n=0;for(let r=0,e=t.length;r<e;r++)n+=t[r].length;const r=new Uint8Array(n);for(let n=0,e=0,i=t.length;n<i;n++){const i=t[n];r.set(i,e),e+=i.length}return r}(this._deflatedData);return this._init(),t}_init(){this._hasEvents=!1,this._deflatedData=[],this.deflate=new B,this.deflate.ondata=(t,n)=>{this._deflatedData.push(t)},this.stream=new J(((t,n)=>{this.deflate.push(t,n)})),this.stream.push("[")}},P={clear:()=>{N.clear()},addEvent:t=>N.addEvent(t),finish:()=>N.finish(),compress:t=>function(t){return q(K(t))}(t)};addEventListener("message",(function(t){const n=t.data.method,r=t.data.id,e=t.data.arg;if(n in P&&"function"==typeof P[n])try{const t=P[n](e);postMessage({id:r,method:n,success:!0,response:t})}catch(t){postMessage({id:r,method:n,success:!1,response:t.message}),console.error(t)}})),postMessage({id:void 0,method:"init",success:!0,response:void 0});';
        function un(e, t) {
          ln && (S.logger.info(e), t && dn(e));
        }
        function mn(e, t) {
          ln &&
            (S.logger.info(e),
            t &&
              setTimeout(() => {
                dn(e);
              }, 0));
        }
        function dn(e) {
          (0, o.addBreadcrumb)(
            {
              category: "console",
              data: { logger: "replay" },
              level: "info",
              message: e,
            },
            { level: "info" },
          );
        }
        class pn extends Error {
          constructor() {
            super("Event buffer exceeded maximum size of 20000000.");
          }
        }
        class hn {
          constructor() {
            (this.events = []), (this._totalSize = 0), (this.hasCheckout = !1);
          }
          get hasEvents() {
            return this.events.length > 0;
          }
          get type() {
            return "sync";
          }
          destroy() {
            this.events = [];
          }
          async addEvent(e) {
            const t = JSON.stringify(e).length;
            if (((this._totalSize += t), this._totalSize > O)) throw new pn();
            this.events.push(e);
          }
          finish() {
            return new Promise((e) => {
              const t = this.events;
              this.clear(), e(JSON.stringify(t));
            });
          }
          clear() {
            (this.events = []), (this._totalSize = 0), (this.hasCheckout = !1);
          }
          getEarliestTimestamp() {
            const e = this.events.map((e) => e.timestamp).sort()[0];
            return e ? Bt(e) : null;
          }
        }
        class gn {
          constructor(e) {
            (this._worker = e), (this._id = 0);
          }
          ensureReady() {
            return (
              this._ensureReadyPromise ||
                (this._ensureReadyPromise = new Promise((e, t) => {
                  this._worker.addEventListener(
                    "message",
                    ({ data: n }) => {
                      n.success ? e() : t();
                    },
                    { once: !0 },
                  ),
                    this._worker.addEventListener(
                      "error",
                      (e) => {
                        t(e);
                      },
                      { once: !0 },
                    );
                })),
              this._ensureReadyPromise
            );
          }
          destroy() {
            un("[Replay] Destroying compression worker"),
              this._worker.terminate();
          }
          postMessage(e, t) {
            const n = this._getAndIncrementId();
            return new Promise((s, i) => {
              const o = ({ data: t }) => {
                const a = t;
                if (a.method === e && a.id === n) {
                  if (
                    (this._worker.removeEventListener("message", o), !a.success)
                  )
                    return (
                      ln && S.logger.error("[Replay]", a.response),
                      void i(new Error("Error in compression worker"))
                    );
                  s(a.response);
                }
              };
              this._worker.addEventListener("message", o),
                this._worker.postMessage({ id: n, method: e, arg: t });
            });
          }
          _getAndIncrementId() {
            return this._id++;
          }
        }
        class fn {
          constructor(e) {
            (this._worker = new gn(e)),
              (this._earliestTimestamp = null),
              (this._totalSize = 0),
              (this.hasCheckout = !1);
          }
          get hasEvents() {
            return !!this._earliestTimestamp;
          }
          get type() {
            return "worker";
          }
          ensureReady() {
            return this._worker.ensureReady();
          }
          destroy() {
            this._worker.destroy();
          }
          addEvent(e) {
            const t = Bt(e.timestamp);
            (!this._earliestTimestamp || t < this._earliestTimestamp) &&
              (this._earliestTimestamp = t);
            const n = JSON.stringify(e);
            return (
              (this._totalSize += n.length),
              this._totalSize > O
                ? Promise.reject(new pn())
                : this._sendEventToWorker(n)
            );
          }
          finish() {
            return this._finishRequest();
          }
          clear() {
            (this._earliestTimestamp = null),
              (this._totalSize = 0),
              (this.hasCheckout = !1),
              this._worker.postMessage("clear").then(null, (e) => {
                ln &&
                  S.logger.warn(
                    '[Replay] Sending "clear" message to worker failed',
                    e,
                  );
              });
          }
          getEarliestTimestamp() {
            return this._earliestTimestamp;
          }
          _sendEventToWorker(e) {
            return this._worker.postMessage("addEvent", e);
          }
          async _finishRequest() {
            const e = await this._worker.postMessage("finish");
            return (this._earliestTimestamp = null), (this._totalSize = 0), e;
          }
        }
        class Sn {
          constructor(e) {
            (this._fallback = new hn()),
              (this._compression = new fn(e)),
              (this._used = this._fallback),
              (this._ensureWorkerIsLoadedPromise =
                this._ensureWorkerIsLoaded());
          }
          get type() {
            return this._used.type;
          }
          get hasEvents() {
            return this._used.hasEvents;
          }
          get hasCheckout() {
            return this._used.hasCheckout;
          }
          set hasCheckout(e) {
            this._used.hasCheckout = e;
          }
          destroy() {
            this._fallback.destroy(), this._compression.destroy();
          }
          clear() {
            return this._used.clear();
          }
          getEarliestTimestamp() {
            return this._used.getEarliestTimestamp();
          }
          addEvent(e) {
            return this._used.addEvent(e);
          }
          async finish() {
            return await this.ensureWorkerIsLoaded(), this._used.finish();
          }
          ensureWorkerIsLoaded() {
            return this._ensureWorkerIsLoadedPromise;
          }
          async _ensureWorkerIsLoaded() {
            try {
              await this._compression.ensureReady();
            } catch (e) {
              return void un(
                "[Replay] Failed to load the compression worker, falling back to simple buffer",
              );
            }
            await this._switchToCompressionWorker();
          }
          async _switchToCompressionWorker() {
            const { events: e, hasCheckout: t } = this._fallback,
              n = [];
            for (const t of e) n.push(this._compression.addEvent(t));
            (this._compression.hasCheckout = t),
              (this._used = this._compression);
            try {
              await Promise.all(n);
            } catch (e) {
              ln &&
                S.logger.warn(
                  "[Replay] Failed to add events when switching buffers.",
                  e,
                );
            }
          }
        }
        function bn({ useCompression: e, workerUrl: t }) {
          if (e && window.Worker) {
            const e = (function (e) {
              try {
                const t =
                  e ||
                  (function () {
                    if (
                      "undefined" == typeof __SENTRY_EXCLUDE_REPLAY_WORKER__ ||
                      !__SENTRY_EXCLUDE_REPLAY_WORKER__
                    )
                      return (function () {
                        const e = new Blob([cn]);
                        return URL.createObjectURL(e);
                      })();
                    return "";
                  })();
                if (!t) return;
                un(
                  "[Replay] Using compression worker" + (e ? ` from ${e}` : ""),
                );
                const n = new Worker(t);
                return new Sn(n);
              } catch (e) {
                un("[Replay] Failed to create compression worker");
              }
            })(t);
            if (e) return e;
          }
          return un("[Replay] Using simple buffer"), new hn();
        }
        function yn() {
          try {
            return "sessionStorage" in I && !!I.sessionStorage;
          } catch (e) {
            return !1;
          }
        }
        function _n(e) {
          !(function () {
            if (!yn()) return;
            try {
              I.sessionStorage.removeItem(A);
            } catch (e) {}
          })(),
            (e.session = void 0);
        }
        function vn(e) {
          return void 0 !== e && Math.random() < e;
        }
        function xn(e) {
          const t = Date.now();
          return {
            id: e.id || (0, b.uuid4)(),
            started: e.started || t,
            lastActivity: e.lastActivity || t,
            segmentId: e.segmentId || 0,
            sampled: e.sampled,
            previousSessionId: e.previousSessionId,
          };
        }
        function kn(e) {
          if (yn())
            try {
              I.sessionStorage.setItem(A, JSON.stringify(e));
            } catch (e) {}
        }
        function En(
          { sessionSampleRate: e, allowBuffering: t, stickySession: n = !1 },
          { previousSessionId: s } = {},
        ) {
          const i = (function (e, t) {
              return vn(e) ? "session" : !!t && "buffer";
            })(e, t),
            o = xn({ sampled: i, previousSessionId: s });
          return n && kn(o), o;
        }
        function Tn(e, t, n = +new Date()) {
          return null === e || void 0 === t || t < 0 || (0 !== t && e + t <= n);
        }
        function Cn(
          e,
          {
            maxReplayDuration: t,
            sessionIdleExpire: n,
            targetTime: s = Date.now(),
          },
        ) {
          return Tn(e.started, t, s) || Tn(e.lastActivity, n, s);
        }
        function wn(e, { sessionIdleExpire: t, maxReplayDuration: n }) {
          return (
            !!Cn(e, { sessionIdleExpire: t, maxReplayDuration: n }) &&
            ("buffer" !== e.sampled || 0 !== e.segmentId)
          );
        }
        function In(
          {
            traceInternals: e,
            sessionIdleExpire: t,
            maxReplayDuration: n,
            previousSessionId: s,
          },
          i,
        ) {
          const o =
            i.stickySession &&
            (function (e) {
              if (!yn()) return null;
              try {
                const t = I.sessionStorage.getItem(A);
                if (!t) return null;
                const n = JSON.parse(t);
                return mn("[Replay] Loading existing session", e), xn(n);
              } catch (e) {
                return null;
              }
            })(e);
          return o
            ? wn(o, { sessionIdleExpire: t, maxReplayDuration: n })
              ? (mn(
                  "[Replay] Session in sessionStorage is expired, creating new one...",
                ),
                En(i, { previousSessionId: o.id }))
              : o
            : (mn("[Replay] Creating new session", e),
              En(i, { previousSessionId: s }));
        }
        function An(e, t, n) {
          return !!Rn(e, t) && (Pn(e, t, n), !0);
        }
        async function Pn(e, t, n) {
          if (!e.eventBuffer) return null;
          try {
            n && "buffer" === e.recordingMode && e.eventBuffer.clear(),
              n && (e.eventBuffer.hasCheckout = !0);
            const s = (function (e, t) {
              try {
                if (
                  "function" == typeof t &&
                  (function (e) {
                    return e.type === qe.Custom;
                  })(e)
                )
                  return t(e);
              } catch (e) {
                return (
                  ln &&
                    S.logger.error(
                      "[Replay] An error occured in the `beforeAddRecordingEvent` callback, skipping the event...",
                      e,
                    ),
                  null
                );
              }
              return e;
            })(t, e.getOptions().beforeAddRecordingEvent);
            if (!s) return;
            return await e.eventBuffer.addEvent(s);
          } catch (t) {
            const n =
              t && t instanceof pn ? "addEventSizeExceeded" : "addEvent";
            ln && S.logger.error(t), await e.stop({ reason: n });
            const s = (0, o.getClient)();
            s && s.recordDroppedEvent("internal_sdk_error", "replay");
          }
        }
        function Rn(e, t) {
          if (!e.eventBuffer || e.isPaused() || !e.isEnabled()) return !1;
          const n = Bt(t.timestamp);
          return (
            !(n + e.timeouts.sessionIdlePause < Date.now()) &&
            (!(
              n >
              e.getContext().initialTimestamp + e.getOptions().maxReplayDuration
            ) ||
              (un(
                `[Replay] Skipping event with timestamp ${n} because it is after maxReplayDuration`,
                e.getOptions()._experiments.traceInternals,
              ),
              !1))
          );
        }
        function Dn(e) {
          return !e.type;
        }
        function Mn(e) {
          return "transaction" === e.type;
        }
        function On(e) {
          return "feedback" === e.type;
        }
        function Nn(e) {
          const t = (function () {
            const e = (0, o.getClient)();
            if (!e) return !1;
            const t = e.getTransport();
            if (!t) return !1;
            return t.send.__sentry__baseTransport__ || !1;
          })();
          return (n, s) => {
            if (!e.isEnabled() || (!Dn(n) && !Mn(n))) return;
            const i = s && s.statusCode;
            (t && (!i || i < 200 || i >= 300)) ||
              (Mn(n)
                ? (function (e, t) {
                    const n = e.getContext();
                    t.contexts &&
                      t.contexts.trace &&
                      t.contexts.trace.trace_id &&
                      n.traceIds.size < 100 &&
                      n.traceIds.add(t.contexts.trace.trace_id);
                  })(e, n)
                : (function (e, t) {
                    const n = e.getContext();
                    t.event_id &&
                      n.errorIds.size < 100 &&
                      n.errorIds.add(t.event_id);
                    if (
                      "buffer" !== e.recordingMode ||
                      !t.tags ||
                      !t.tags.replayId
                    )
                      return;
                    const { beforeErrorSampling: s } = e.getOptions();
                    if ("function" == typeof s && !s(t)) return;
                    setTimeout(() => {
                      e.sendBufferedReplayOrFlush();
                    });
                  })(e, n));
          };
        }
        function Ln(e) {
          return (t) => {
            e.isEnabled() &&
              Dn(t) &&
              (function (e, t) {
                const n =
                  t.exception &&
                  t.exception.values &&
                  t.exception.values[0].value;
                if ("string" != typeof n) return;
                if (
                  n.match(
                    /reactjs\.org\/docs\/error-decoder\.html\?invariant=(418|419|422|423|425)/,
                  ) ||
                  n.match(
                    /(does not match server-rendered HTML|Hydration failed because)/i,
                  )
                ) {
                  Ft(e, Jt({ category: "replay.hydrate-error" }));
                }
              })(e, t);
          };
        }
        function Bn(e, t = !1) {
          const n = t ? Nn(e) : void 0;
          return Object.assign(
            (t, s) => {
              if (!e.isEnabled()) return t;
              if (
                (function (e) {
                  return "replay_event" === e.type;
                })(t)
              )
                return delete t.breadcrumbs, t;
              if (!Dn(t) && !Mn(t) && !On(t)) return t;
              if (!e.checkAndHandleExpiredSession()) return t;
              if (On(t))
                return (
                  e.flush(),
                  (t.contexts.feedback.replay_id = e.getSessionId()),
                  (function (e, t) {
                    e.triggerUserActivity(),
                      e.addUpdate(
                        () =>
                          !t.timestamp ||
                          (e.throttledAddEvent({
                            type: qe.Custom,
                            timestamp: 1e3 * t.timestamp,
                            data: {
                              tag: "breadcrumb",
                              payload: {
                                timestamp: t.timestamp,
                                type: "default",
                                category: "sentry.feedback",
                                data: { feedbackId: t.event_id },
                              },
                            },
                          }),
                          !1),
                      );
                  })(e, t),
                  t
                );
              if (
                (function (e, t) {
                  return !(
                    e.type ||
                    !e.exception ||
                    !e.exception.values ||
                    !e.exception.values.length ||
                    !t.originalException ||
                    !t.originalException.__rrweb__
                  );
                })(t, s) &&
                !e.getOptions()._experiments.captureExceptions
              )
                return (
                  ln &&
                    S.logger.log(
                      "[Replay] Ignoring error from rrweb internals",
                      t,
                    ),
                  null
                );
              const i = (function (e, t) {
                return (
                  "buffer" === e.recordingMode &&
                  t.message !== R &&
                  !(!t.exception || t.type) &&
                  vn(e.getOptions().errorSampleRate)
                );
              })(e, t);
              return (
                (i || "session" === e.recordingMode) &&
                  (t.tags = { ...t.tags, replayId: e.getSessionId() }),
                n && n(t, { statusCode: 200 }),
                t
              );
            },
            { id: "Replay" },
          );
        }
        function Un(e, t) {
          return t.map(({ type: t, start: n, end: s, name: i, data: o }) => {
            const a = e.throttledAddEvent({
              type: qe.Custom,
              timestamp: n,
              data: {
                tag: "performanceSpan",
                payload: {
                  op: t,
                  description: i,
                  startTimestamp: n,
                  endTimestamp: s,
                  data: o,
                },
              },
            });
            return "string" == typeof a ? Promise.resolve(null) : a;
          });
        }
        function Fn(e) {
          return (t) => {
            if (!e.isEnabled()) return;
            const n = (function (e) {
              const { from: t, to: n } = e,
                s = Date.now() / 1e3;
              return {
                type: "navigation.push",
                start: s,
                end: s,
                name: n,
                data: { previous: t },
              };
            })(t);
            null !== n &&
              (e.getContext().urls.push(n.name),
              e.triggerUserActivity(),
              e.addUpdate(() => (Un(e, [n]), !1)));
          };
        }
        function Hn(e, t) {
          e.isEnabled() &&
            null !== t &&
            ((function (e, t) {
              return (
                (!ln || !e.getOptions()._experiments.traceInternals) &&
                (0, a.isSentryRequestUrl)(t, (0, o.getClient)())
              );
            })(e, t.name) ||
              e.addUpdate(() => (Un(e, [t]), !0)));
        }
        function jn(e) {
          return (t) => {
            if (!e.isEnabled()) return;
            const n = (function (e) {
              const { startTimestamp: t, endTimestamp: n, xhr: s } = e,
                i = s[y.SENTRY_XHR_DATA_KEY];
              if (!t || !n || !i) return null;
              const { method: o, url: a, status_code: r } = i;
              return void 0 === a
                ? null
                : {
                    type: "resource.xhr",
                    name: a,
                    start: t / 1e3,
                    end: n / 1e3,
                    data: { method: o, statusCode: r },
                  };
            })(t);
            Hn(e, n);
          };
        }
        function Gn(e, t) {
          if (e)
            try {
              if ("string" == typeof e) return t.encode(e).length;
              if (e instanceof URLSearchParams)
                return t.encode(e.toString()).length;
              if (e instanceof FormData) {
                const n = Jn(e);
                return t.encode(n).length;
              }
              if (e instanceof Blob) return e.size;
              if (e instanceof ArrayBuffer) return e.byteLength;
            } catch (e) {}
        }
        function Wn(e) {
          if (!e) return;
          const t = parseInt(e, 10);
          return isNaN(t) ? void 0 : t;
        }
        function qn(e) {
          try {
            if ("string" == typeof e) return [e];
            if (e instanceof URLSearchParams) return [e.toString()];
            if (e instanceof FormData) return [Jn(e)];
            if (!e) return [void 0];
          } catch (t) {
            return (
              ln && S.logger.warn("[Replay] Failed to serialize body", e),
              [void 0, "BODY_PARSE_ERROR"]
            );
          }
          return (
            ln &&
              S.logger.info(
                "[Replay] Skipping network body because of body type",
                e,
              ),
            [void 0, "UNPARSEABLE_BODY_TYPE"]
          );
        }
        function $n(e, t) {
          if (!e)
            return { headers: {}, size: void 0, _meta: { warnings: [t] } };
          const n = { ...e._meta },
            s = n.warnings || [];
          return (n.warnings = [...s, t]), (e._meta = n), e;
        }
        function Vn(e, t) {
          if (!t) return null;
          const {
            startTimestamp: n,
            endTimestamp: s,
            url: i,
            method: o,
            statusCode: a,
            request: r,
            response: l,
          } = t;
          return {
            type: e,
            start: n / 1e3,
            end: s / 1e3,
            name: i,
            data: (0, h.dropUndefinedKeys)({
              method: o,
              statusCode: a,
              request: r,
              response: l,
            }),
          };
        }
        function zn(e) {
          return { headers: {}, size: e, _meta: { warnings: ["URL_SKIPPED"] } };
        }
        function Yn(e, t, n) {
          if (!t && 0 === Object.keys(e).length) return;
          if (!t) return { headers: e };
          if (!n) return { headers: e, size: t };
          const s = { headers: e, size: t },
            { body: i, warnings: o } = (function (e) {
              if (!e || "string" != typeof e) return { body: e };
              const t = e.length > D,
                n = (function (e) {
                  const t = e[0],
                    n = e[e.length - 1];
                  return ("[" === t && "]" === n) || ("{" === t && "}" === n);
                })(e);
              if (t) {
                const t = e.slice(0, D);
                return n
                  ? { body: t, warnings: ["MAYBE_JSON_TRUNCATED"] }
                  : { body: `${t}…`, warnings: ["TEXT_TRUNCATED"] };
              }
              if (n)
                try {
                  return { body: JSON.parse(e) };
                } catch (e) {}
              return { body: e };
            })(n);
          return (
            (s.body = i), o && o.length > 0 && (s._meta = { warnings: o }), s
          );
        }
        function Kn(e, t) {
          return Object.keys(e).reduce((n, s) => {
            const i = s.toLowerCase();
            return t.includes(i) && e[s] && (n[i] = e[s]), n;
          }, {});
        }
        function Jn(e) {
          return new URLSearchParams(e).toString();
        }
        function Xn(e, t) {
          const n = (function (e, t = I.document.baseURI) {
            if (
              e.startsWith("http://") ||
              e.startsWith("https://") ||
              e.startsWith(I.location.origin)
            )
              return e;
            const n = new URL(e, t);
            if (n.origin !== new URL(t).origin) return e;
            const s = n.href;
            if (!e.endsWith("/") && s.endsWith("/")) return s.slice(0, -1);
            return s;
          })(e);
          return (0, _.stringMatchesSomePattern)(n, t);
        }
        async function Zn(e, t, n) {
          try {
            const s = await (async function (e, t, n) {
                const s = Date.now(),
                  { startTimestamp: i = s, endTimestamp: o = s } = t,
                  {
                    url: a,
                    method: r,
                    status_code: l = 0,
                    request_body_size: c,
                    response_body_size: u,
                  } = e.data,
                  m =
                    Xn(a, n.networkDetailAllowUrls) &&
                    !Xn(a, n.networkDetailDenyUrls),
                  d = m
                    ? (function (
                        { networkCaptureBodies: e, networkRequestHeaders: t },
                        n,
                        s,
                      ) {
                        const i = n
                          ? (function (e, t) {
                              if (1 === e.length && "string" != typeof e[0])
                                return ts(e[0], t);
                              if (2 === e.length) return ts(e[1], t);
                              return {};
                            })(n, t)
                          : {};
                        if (!e) return Yn(i, s, void 0);
                        const o = Qn(n),
                          [a, r] = qn(o),
                          l = Yn(i, s, a);
                        if (r) return $n(l, r);
                        return l;
                      })(n, t.input, c)
                    : zn(c),
                  p = await (async function (
                    e,
                    {
                      networkCaptureBodies: t,
                      textEncoder: n,
                      networkResponseHeaders: s,
                    },
                    i,
                    o,
                  ) {
                    if (!e && void 0 !== o) return zn(o);
                    const a = i ? es(i.headers, s) : {};
                    if (!i || (!t && void 0 !== o)) return Yn(a, o, void 0);
                    const [r, l] = await (async function (e) {
                        const t = (function (e) {
                          try {
                            return e.clone();
                          } catch (e) {
                            ln &&
                              S.logger.warn(
                                "[Replay] Failed to clone response body",
                                e,
                              );
                          }
                        })(e);
                        if (!t) return [void 0, "BODY_PARSE_ERROR"];
                        try {
                          const e = await (function (e) {
                            return new Promise((t, n) => {
                              const s = setTimeout(
                                () =>
                                  n(
                                    new Error(
                                      "Timeout while trying to read response body",
                                    ),
                                  ),
                                500,
                              );
                              (async function (e) {
                                return await e.text();
                              })(e)
                                .then(
                                  (e) => t(e),
                                  (e) => n(e),
                                )
                                .finally(() => clearTimeout(s));
                            });
                          })(t);
                          return [e];
                        } catch (e) {
                          return (
                            ln &&
                              S.logger.warn(
                                "[Replay] Failed to get text body from response",
                                e,
                              ),
                            [void 0, "BODY_PARSE_ERROR"]
                          );
                        }
                      })(i),
                      c = (function (
                        e,
                        {
                          networkCaptureBodies: t,
                          textEncoder: n,
                          responseBodySize: s,
                          captureDetails: i,
                          headers: o,
                        },
                      ) {
                        try {
                          const a =
                            e && e.length && void 0 === s ? Gn(e, n) : s;
                          return i ? Yn(o, a, t ? e : void 0) : zn(a);
                        } catch (e) {
                          return (
                            ln &&
                              S.logger.warn(
                                "[Replay] Failed to serialize response body",
                                e,
                              ),
                            Yn(o, s, void 0)
                          );
                        }
                      })(r, {
                        networkCaptureBodies: t,
                        textEncoder: n,
                        responseBodySize: o,
                        captureDetails: e,
                        headers: a,
                      });
                    if (l) return $n(c, l);
                    return c;
                  })(m, n, t.response, u);
                return {
                  startTimestamp: i,
                  endTimestamp: o,
                  url: a,
                  method: r,
                  statusCode: l,
                  request: d,
                  response: p,
                };
              })(e, t, n),
              i = Vn("resource.fetch", s);
            Hn(n.replay, i);
          } catch (e) {
            ln &&
              S.logger.error("[Replay] Failed to capture fetch breadcrumb", e);
          }
        }
        function Qn(e = []) {
          if (2 === e.length && "object" == typeof e[1]) return e[1].body;
        }
        function es(e, t) {
          const n = {};
          return (
            t.forEach((t) => {
              e.get(t) && (n[t] = e.get(t));
            }),
            n
          );
        }
        function ts(e, t) {
          if (!e) return {};
          const n = e.headers;
          return n
            ? n instanceof Headers
              ? es(n, t)
              : Array.isArray(n)
                ? {}
                : Kn(n, t)
            : {};
        }
        async function ns(e, t, n) {
          try {
            const s = (function (e, t, n) {
                const s = Date.now(),
                  {
                    startTimestamp: i = s,
                    endTimestamp: o = s,
                    input: a,
                    xhr: r,
                  } = t,
                  {
                    url: l,
                    method: c,
                    status_code: u = 0,
                    request_body_size: m,
                    response_body_size: d,
                  } = e.data;
                if (!l) return null;
                if (
                  !r ||
                  !Xn(l, n.networkDetailAllowUrls) ||
                  Xn(l, n.networkDetailDenyUrls)
                ) {
                  return {
                    startTimestamp: i,
                    endTimestamp: o,
                    url: l,
                    method: c,
                    statusCode: u,
                    request: zn(m),
                    response: zn(d),
                  };
                }
                const p = r[y.SENTRY_XHR_DATA_KEY],
                  h = p ? Kn(p.request_headers, n.networkRequestHeaders) : {},
                  g = Kn(
                    (function (e) {
                      const t = e.getAllResponseHeaders();
                      if (!t) return {};
                      return t.split("\r\n").reduce((e, t) => {
                        const [n, s] = t.split(": ");
                        return (e[n.toLowerCase()] = s), e;
                      }, {});
                    })(r),
                    n.networkResponseHeaders,
                  ),
                  [f, b] = n.networkCaptureBodies ? qn(a) : [void 0],
                  [_, v] = n.networkCaptureBodies
                    ? (function (e) {
                        const t = [];
                        try {
                          return [e.responseText];
                        } catch (e) {
                          t.push(e);
                        }
                        try {
                          return (function (e, t) {
                            try {
                              if ("string" == typeof e) return [e];
                              if (e instanceof Document)
                                return [e.body.outerHTML];
                              if ("json" === t && e && "object" == typeof e)
                                return [JSON.stringify(e)];
                              if (!e) return [void 0];
                            } catch (t) {
                              return (
                                ln &&
                                  S.logger.warn(
                                    "[Replay] Failed to serialize body",
                                    e,
                                  ),
                                [void 0, "BODY_PARSE_ERROR"]
                              );
                            }
                            return (
                              ln &&
                                S.logger.info(
                                  "[Replay] Skipping network body because of body type",
                                  e,
                                ),
                              [void 0, "UNPARSEABLE_BODY_TYPE"]
                            );
                          })(e.response, e.responseType);
                        } catch (e) {
                          t.push(e);
                        }
                        return (
                          ln &&
                            S.logger.warn(
                              "[Replay] Failed to get xhr response body",
                              ...t,
                            ),
                          [void 0]
                        );
                      })(r)
                    : [void 0],
                  x = Yn(h, m, f),
                  k = Yn(g, d, _);
                return {
                  startTimestamp: i,
                  endTimestamp: o,
                  url: l,
                  method: c,
                  statusCode: u,
                  request: b ? $n(x, b) : x,
                  response: v ? $n(k, v) : k,
                };
              })(e, t, n),
              i = Vn("resource.xhr", s);
            Hn(n.replay, i);
          } catch (e) {
            ln &&
              S.logger.error("[Replay] Failed to capture xhr breadcrumb", e);
          }
        }
        function ss(e, t, n) {
          const { xhr: s, input: i } = t;
          if (!s) return;
          const o = Gn(i, n.textEncoder),
            a = s.getResponseHeader("content-length")
              ? Wn(s.getResponseHeader("content-length"))
              : (function (e, t, n) {
                  try {
                    return Gn(
                      "json" === t && e && "object" == typeof e
                        ? JSON.stringify(e)
                        : e,
                      n,
                    );
                  } catch (e) {
                    return;
                  }
                })(s.response, s.responseType, n.textEncoder);
          void 0 !== o && (e.data.request_body_size = o),
            void 0 !== a && (e.data.response_body_size = a);
        }
        function is(e) {
          const t = (0, o.getClient)();
          try {
            const n = new TextEncoder(),
              {
                networkDetailAllowUrls: s,
                networkDetailDenyUrls: i,
                networkCaptureBodies: o,
                networkRequestHeaders: a,
                networkResponseHeaders: r,
              } = e.getOptions(),
              l = {
                replay: e,
                textEncoder: n,
                networkDetailAllowUrls: s,
                networkDetailDenyUrls: i,
                networkCaptureBodies: o,
                networkRequestHeaders: a,
                networkResponseHeaders: r,
              };
            t && t.on
              ? t.on("beforeAddBreadcrumb", (e, t) =>
                  (function (e, t, n) {
                    if (!t.data) return;
                    try {
                      (function (e) {
                        return "xhr" === e.category;
                      })(t) &&
                        (function (e) {
                          return e && e.xhr;
                        })(n) &&
                        (ss(t, n, e), ns(t, n, e)),
                        (function (e) {
                          return "fetch" === e.category;
                        })(t) &&
                          (function (e) {
                            return e && e.response;
                          })(n) &&
                          (!(function (e, t, n) {
                            const { input: s, response: i } = t,
                              o = Gn(s ? Qn(s) : void 0, n.textEncoder),
                              a = i
                                ? Wn(i.headers.get("content-length"))
                                : void 0;
                            void 0 !== o && (e.data.request_body_size = o),
                              void 0 !== a && (e.data.response_body_size = a);
                          })(t, n, e),
                          Zn(t, n, e));
                    } catch (e) {
                      ln &&
                        S.logger.warn(
                          "Error when enriching network breadcrumb",
                        );
                    }
                  })(l, e, t),
                )
              : ((0, v.addFetchInstrumentationHandler)(
                  (function (e) {
                    return (t) => {
                      if (!e.isEnabled()) return;
                      const n = (function (e) {
                        const {
                          startTimestamp: t,
                          endTimestamp: n,
                          fetchData: s,
                          response: i,
                        } = e;
                        if (!n) return null;
                        const { method: o, url: a } = s;
                        return {
                          type: "resource.fetch",
                          start: t / 1e3,
                          end: n / 1e3,
                          name: a,
                          data: {
                            method: o,
                            statusCode: i ? i.status : void 0,
                          },
                        };
                      })(t);
                      Hn(e, n);
                    };
                  })(e),
                ),
                (0, y.addXhrInstrumentationHandler)(jn(e)));
          } catch (e) {}
        }
        let os = null;
        const as = (e) => (t) => {
          if (!e.isEnabled()) return;
          const n = (function (e) {
            const t = e.getLastBreadcrumb && e.getLastBreadcrumb();
            if (os === t || !t) return null;
            if (
              ((os = t),
              !(function (e) {
                return !!e.category;
              })(t) ||
                ["fetch", "xhr", "sentry.event", "sentry.transaction"].includes(
                  t.category,
                ) ||
                t.category.startsWith("ui."))
            )
              return null;
            if ("console" === t.category)
              return (function (e) {
                const t = e.data && e.data.arguments;
                if (!Array.isArray(t) || 0 === t.length) return Jt(e);
                let n = !1;
                const s = t.map((e) => {
                  if (!e) return e;
                  if ("string" == typeof e)
                    return e.length > M ? ((n = !0), `${e.slice(0, M)}…`) : e;
                  if ("object" == typeof e)
                    try {
                      const t = (0, p.normalize)(e, 7);
                      return JSON.stringify(t).length > M
                        ? ((n = !0),
                          `${JSON.stringify(t, null, 2).slice(0, M)}…`)
                        : t;
                    } catch (e) {}
                  return e;
                });
                return Jt({
                  ...e,
                  data: {
                    ...e.data,
                    arguments: s,
                    ...(n
                      ? { _meta: { warnings: ["CONSOLE_ARG_TRUNCATED"] } }
                      : {}),
                  },
                });
              })(t);
            return Jt(t);
          })(t);
          n && Ft(e, n);
        };
        function rs(e) {
          return !(!e || !e.on);
        }
        function ls(e) {
          const {
              jsHeapSizeLimit: t,
              totalJSHeapSize: n,
              usedJSHeapSize: s,
            } = e,
            i = Date.now() / 1e3;
          return {
            type: "memory",
            name: "memory",
            start: i,
            end: i,
            data: {
              memory: {
                jsHeapSizeLimit: t,
                totalJSHeapSize: n,
                usedJSHeapSize: s,
              },
            },
          };
        }
        function cs(e) {
          let t = !1;
          return (n, s) => {
            if (!e.checkAndHandleExpiredSession())
              return void (
                ln &&
                S.logger.warn(
                  "[Replay] Received replay event after session expired.",
                )
              );
            const i = s || !t;
            (t = !0),
              e.clickDetector && Kt(e.clickDetector, n),
              e.addUpdate(() => {
                if (
                  ("buffer" === e.recordingMode && i && e.setInitialState(),
                  !An(e, n, i))
                )
                  return !0;
                if (!i) return !1;
                if (
                  ((function (e, t) {
                    if (!t || !e.session || 0 !== e.session.segmentId) return;
                    An(
                      e,
                      (function (e) {
                        const t = e.getOptions();
                        return {
                          type: qe.Custom,
                          timestamp: Date.now(),
                          data: {
                            tag: "options",
                            payload: {
                              shouldRecordCanvas: e.isRecordingCanvas(),
                              sessionSampleRate: t.sessionSampleRate,
                              errorSampleRate: t.errorSampleRate,
                              useCompressionOption: t.useCompression,
                              blockAllMedia: t.blockAllMedia,
                              maskAllText: t.maskAllText,
                              maskAllInputs: t.maskAllInputs,
                              useCompression:
                                !!e.eventBuffer &&
                                "worker" === e.eventBuffer.type,
                              networkDetailHasUrls:
                                t.networkDetailAllowUrls.length > 0,
                              networkCaptureBodies: t.networkCaptureBodies,
                              networkRequestHasHeaders:
                                t.networkRequestHeaders.length > 0,
                              networkResponseHasHeaders:
                                t.networkResponseHeaders.length > 0,
                            },
                          },
                        };
                      })(e),
                      !1,
                    );
                  })(e, i),
                  e.session && e.session.previousSessionId)
                )
                  return !0;
                if (
                  "buffer" === e.recordingMode &&
                  e.session &&
                  e.eventBuffer
                ) {
                  const t = e.eventBuffer.getEarliestTimestamp();
                  t &&
                    (un(
                      `[Replay] Updating session start time to earliest event in buffer to ${new Date(t)}`,
                      e.getOptions()._experiments.traceInternals,
                    ),
                    (e.session.started = t),
                    e.getOptions().stickySession && kn(e.session));
                }
                return "session" === e.recordingMode && e.flush(), !0;
              });
          };
        }
        async function us({
          recordingData: e,
          replayId: t,
          segmentId: n,
          eventContext: s,
          timestamp: i,
          session: a,
        }) {
          const r = (function ({ recordingData: e, headers: t }) {
              let n;
              const s = `${JSON.stringify(t)}\n`;
              if ("string" == typeof e) n = `${s}${e}`;
              else {
                const t = new TextEncoder().encode(s);
                (n = new Uint8Array(t.length + e.length)),
                  n.set(t),
                  n.set(e, t.length);
              }
              return n;
            })({ recordingData: e, headers: { segment_id: n } }),
            { urls: u, errorIds: m, traceIds: d, initialTimestamp: p } = s,
            h = (0, o.getClient)(),
            g = (0, o.getCurrentScope)(),
            f = h && h.getTransport(),
            S = h && h.getDsn();
          if (!(h && f && S && a.sampled)) return;
          const b = {
              type: P,
              replay_start_timestamp: p / 1e3,
              timestamp: i / 1e3,
              error_ids: m,
              trace_ids: d,
              urls: u,
              replay_id: t,
              segment_id: n,
              replay_type: a.sampled,
            },
            y = await (async function ({
              client: e,
              scope: t,
              replayId: n,
              event: s,
            }) {
              const i = {
                event_id: n,
                integrations:
                  "object" != typeof e._integrations ||
                  null === e._integrations ||
                  Array.isArray(e._integrations)
                    ? void 0
                    : Object.keys(e._integrations),
              };
              e.emit && e.emit("preprocessEvent", s, i);
              const o = await (0, l.prepareEvent)(
                e.getOptions(),
                s,
                i,
                t,
                e,
                (0, c.getIsolationScope)(),
              );
              if (!o) return null;
              o.platform = o.platform || "javascript";
              const a = e.getSdkMetadata && e.getSdkMetadata(),
                { name: r, version: u } = (a && a.sdk) || {};
              return (
                (o.sdk = {
                  ...o.sdk,
                  name: r || "sentry.javascript.unknown",
                  version: u || "0.0.0",
                }),
                o
              );
            })({ scope: g, client: h, replayId: t, event: b });
          if (!y)
            return (
              h.recordDroppedEvent("event_processor", "replay", b),
              void un(
                "An event processor returned `null`, will not send event.",
              )
            );
          delete y.sdkProcessingMetadata;
          const _ = (function (e, t, n, s) {
            return (0, E.createEnvelope)(
              (0, E.createEventEnvelopeHeaders)(
                e,
                (0, E.getSdkMetadataForEnvelopeHeader)(e),
                s,
                n,
              ),
              [
                [{ type: "replay_event" }, e],
                [
                  {
                    type: "replay_recording",
                    length:
                      "string" == typeof t
                        ? new TextEncoder().encode(t).length
                        : t.length,
                  },
                  t,
                ],
              ],
            );
          })(y, r, S, h.getOptions().tunnel);
          let v;
          try {
            v = await f.send(_);
          } catch (e) {
            const t = new Error(R);
            try {
              t.cause = e;
            } catch (e) {}
            throw t;
          }
          if (!v) return v;
          if (
            "number" == typeof v.statusCode &&
            (v.statusCode < 200 || v.statusCode >= 300)
          )
            throw new ms(v.statusCode);
          const x = (0, T.updateRateLimits)({}, v);
          if ((0, T.isRateLimited)(x, "replay")) throw new ds(x);
          return v;
        }
        class ms extends Error {
          constructor(e) {
            super(`Transport returned status code ${e}`);
          }
        }
        class ds extends Error {
          constructor(e) {
            super("Rate limit hit"), (this.rateLimits = e);
          }
        }
        async function ps(e, t = { count: 0, interval: 5e3 }) {
          const { recordingData: n, options: s } = e;
          if (n.length)
            try {
              return await us(e), !0;
            } catch (n) {
              if (n instanceof ms || n instanceof ds) throw n;
              if (
                ((0, o.setContext)("Replays", { _retryCount: t.count }),
                ln &&
                  s._experiments &&
                  s._experiments.captureExceptions &&
                  (0, o.captureException)(n),
                t.count >= 3)
              ) {
                const e = new Error(`${R} - max retries exceeded`);
                try {
                  e.cause = n;
                } catch (e) {}
                throw e;
              }
              return (
                (t.interval *= ++t.count),
                new Promise((n, s) => {
                  setTimeout(async () => {
                    try {
                      await ps(e, t), n(!0);
                    } catch (e) {
                      s(e);
                    }
                  }, t.interval);
                })
              );
            }
        }
        const hs = "__THROTTLED";
        function gs(e, t, n) {
          const s = new Map();
          let i = !1;
          return (...o) => {
            const a = Math.floor(Date.now() / 1e3);
            if (
              (((e) => {
                const t = e - n;
                s.forEach((e, n) => {
                  n < t && s.delete(n);
                });
              })(a),
              [...s.values()].reduce((e, t) => e + t, 0) >= t)
            ) {
              const e = i;
              return (i = !0), e ? "__SKIPPED" : hs;
            }
            i = !1;
            const r = s.get(a) || 0;
            return s.set(a, r + 1), e(...o);
          };
        }
        class fs {
          constructor({ options: e, recordingOptions: t }) {
            fs.prototype.__init.call(this),
              fs.prototype.__init2.call(this),
              fs.prototype.__init3.call(this),
              fs.prototype.__init4.call(this),
              fs.prototype.__init5.call(this),
              fs.prototype.__init6.call(this),
              (this.eventBuffer = null),
              (this.performanceEntries = []),
              (this.replayPerformanceEntries = []),
              (this.recordingMode = "session"),
              (this.timeouts = {
                sessionIdlePause: 3e5,
                sessionIdleExpire: 9e5,
              }),
              (this._lastActivity = Date.now()),
              (this._isEnabled = !1),
              (this._isPaused = !1),
              (this._hasInitializedCoreListeners = !1),
              (this._context = {
                errorIds: new Set(),
                traceIds: new Set(),
                urls: [],
                initialTimestamp: Date.now(),
                initialUrl: "",
              }),
              (this._recordingOptions = t),
              (this._options = e),
              (this._debouncedFlush = (function (e, t, n) {
                let s, i, o;
                const a = n && n.maxWait ? Math.max(n.maxWait, t) : 0;
                function r() {
                  return l(), (s = e()), s;
                }
                function l() {
                  void 0 !== i && clearTimeout(i),
                    void 0 !== o && clearTimeout(o),
                    (i = o = void 0);
                }
                function c() {
                  return (
                    i && clearTimeout(i),
                    (i = setTimeout(r, t)),
                    a && void 0 === o && (o = setTimeout(r, a)),
                    s
                  );
                }
                return (
                  (c.cancel = l),
                  (c.flush = function () {
                    return void 0 !== i || void 0 !== o ? r() : s;
                  }),
                  c
                );
              })(() => this._flush(), this._options.flushMinDelay, {
                maxWait: this._options.flushMaxDelay,
              })),
              (this._throttledAddEvent = gs(
                (e, t) =>
                  (function (e, t, n) {
                    return Rn(e, t) ? Pn(e, t, n) : Promise.resolve(null);
                  })(this, e, t),
                300,
                5,
              ));
            const { slowClickTimeout: n, slowClickIgnoreSelectors: s } =
                this.getOptions(),
              i = n
                ? {
                    threshold: Math.min(3e3, n),
                    timeout: n,
                    scrollTimeout: 300,
                    ignoreSelector: s ? s.join(",") : "",
                  }
                : void 0;
            i && (this.clickDetector = new Vt(this, i));
          }
          getContext() {
            return this._context;
          }
          isEnabled() {
            return this._isEnabled;
          }
          isPaused() {
            return this._isPaused;
          }
          isRecordingCanvas() {
            return Boolean(this._canvas);
          }
          getOptions() {
            return this._options;
          }
          initializeSampling(e) {
            const { errorSampleRate: t, sessionSampleRate: n } = this._options;
            (t <= 0 && n <= 0) ||
              (this._initializeSessionForSampling(e),
              this.session
                ? !1 !== this.session.sampled &&
                  ((this.recordingMode =
                    "buffer" === this.session.sampled &&
                    0 === this.session.segmentId
                      ? "buffer"
                      : "session"),
                  mn(
                    `[Replay] Starting replay in ${this.recordingMode} mode`,
                    this._options._experiments.traceInternals,
                  ),
                  this._initializeRecording())
                : this._handleException(
                    new Error("Unable to initialize and create session"),
                  ));
          }
          start() {
            if (this._isEnabled && "session" === this.recordingMode)
              throw new Error("Replay recording is already in progress");
            if (this._isEnabled && "buffer" === this.recordingMode)
              throw new Error(
                "Replay buffering is in progress, call `flush()` to save the replay",
              );
            mn(
              "[Replay] Starting replay in session mode",
              this._options._experiments.traceInternals,
            );
            const e = In(
              {
                maxReplayDuration: this._options.maxReplayDuration,
                sessionIdleExpire: this.timeouts.sessionIdleExpire,
                traceInternals: this._options._experiments.traceInternals,
              },
              {
                stickySession: this._options.stickySession,
                sessionSampleRate: 1,
                allowBuffering: !1,
              },
            );
            (this.session = e), this._initializeRecording();
          }
          startBuffering() {
            if (this._isEnabled)
              throw new Error("Replay recording is already in progress");
            mn(
              "[Replay] Starting replay in buffer mode",
              this._options._experiments.traceInternals,
            );
            const e = In(
              {
                sessionIdleExpire: this.timeouts.sessionIdleExpire,
                maxReplayDuration: this._options.maxReplayDuration,
                traceInternals: this._options._experiments.traceInternals,
              },
              {
                stickySession: this._options.stickySession,
                sessionSampleRate: 0,
                allowBuffering: !0,
              },
            );
            (this.session = e),
              (this.recordingMode = "buffer"),
              this._initializeRecording();
          }
          startRecording() {
            try {
              const e = this._canvas;
              this._stopRecording = Nt({
                ...this._recordingOptions,
                ...("buffer" === this.recordingMode && {
                  checkoutEveryNms: 6e4,
                }),
                emit: cs(this),
                onMutation: this._onMutationHandler,
                ...(e
                  ? {
                      recordCanvas: e.recordCanvas,
                      getCanvasManager: e.getCanvasManager,
                      sampling: e.sampling,
                      dataURLOptions: e.dataURLOptions,
                    }
                  : {}),
              });
            } catch (e) {
              this._handleException(e);
            }
          }
          stopRecording() {
            try {
              return (
                this._stopRecording &&
                  (this._stopRecording(), (this._stopRecording = void 0)),
                !0
              );
            } catch (e) {
              return this._handleException(e), !1;
            }
          }
          async stop({ forceFlush: e = !1, reason: t } = {}) {
            if (this._isEnabled) {
              this._isEnabled = !1;
              try {
                un(
                  "[Replay] Stopping Replay" + (t ? ` triggered by ${t}` : ""),
                  this._options._experiments.traceInternals,
                ),
                  this._removeListeners(),
                  this.stopRecording(),
                  this._debouncedFlush.cancel(),
                  e && (await this._flush({ force: !0 })),
                  this.eventBuffer && this.eventBuffer.destroy(),
                  (this.eventBuffer = null),
                  _n(this);
              } catch (e) {
                this._handleException(e);
              }
            }
          }
          pause() {
            this._isPaused ||
              ((this._isPaused = !0),
              this.stopRecording(),
              un(
                "[Replay] Pausing replay",
                this._options._experiments.traceInternals,
              ));
          }
          resume() {
            this._isPaused &&
              this._checkSession() &&
              ((this._isPaused = !1),
              this.startRecording(),
              un(
                "[Replay] Resuming replay",
                this._options._experiments.traceInternals,
              ));
          }
          async sendBufferedReplayOrFlush({ continueRecording: e = !0 } = {}) {
            if ("session" === this.recordingMode) return this.flushImmediate();
            const t = Date.now();
            un(
              "[Replay] Converting buffer to session",
              this._options._experiments.traceInternals,
            ),
              await this.flushImmediate();
            const n = this.stopRecording();
            e &&
              n &&
              "session" !== this.recordingMode &&
              ((this.recordingMode = "session"),
              this.session &&
                (this._updateUserActivity(t),
                this._updateSessionActivity(t),
                this._maybeSaveSession()),
              this.startRecording());
          }
          addUpdate(e) {
            const t = e();
            "buffer" !== this.recordingMode &&
              !0 !== t &&
              this._debouncedFlush();
          }
          triggerUserActivity() {
            if ((this._updateUserActivity(), this._stopRecording))
              this.checkAndHandleExpiredSession(),
                this._updateSessionActivity();
            else {
              if (!this._checkSession()) return;
              this.resume();
            }
          }
          updateUserActivity() {
            this._updateUserActivity(), this._updateSessionActivity();
          }
          conditionalFlush() {
            return "buffer" === this.recordingMode
              ? Promise.resolve()
              : this.flushImmediate();
          }
          flush() {
            return this._debouncedFlush();
          }
          flushImmediate() {
            return this._debouncedFlush(), this._debouncedFlush.flush();
          }
          cancelFlush() {
            this._debouncedFlush.cancel();
          }
          getSessionId() {
            return this.session && this.session.id;
          }
          checkAndHandleExpiredSession() {
            if (
              !(
                this._lastActivity &&
                Tn(this._lastActivity, this.timeouts.sessionIdlePause) &&
                this.session &&
                "session" === this.session.sampled
              )
            )
              return !!this._checkSession();
            this.pause();
          }
          setInitialState() {
            const e = `${I.location.pathname}${I.location.hash}${I.location.search}`,
              t = `${I.location.origin}${e}`;
            (this.performanceEntries = []),
              (this.replayPerformanceEntries = []),
              this._clearContext(),
              (this._context.initialUrl = t),
              (this._context.initialTimestamp = Date.now()),
              this._context.urls.push(t);
          }
          throttledAddEvent(e, t) {
            const n = this._throttledAddEvent(e, t);
            if (n === hs) {
              const e = Jt({ category: "replay.throttled" });
              this.addUpdate(
                () =>
                  !An(this, {
                    type: 5,
                    timestamp: e.timestamp || 0,
                    data: { tag: "breadcrumb", payload: e, metric: !0 },
                  }),
              );
            }
            return n;
          }
          getCurrentRoute() {
            const e =
                this.lastTransaction ||
                (0, o.getCurrentScope)().getTransaction(),
              t = ((e && (0, u.spanToJSON)(e).data) || {})[
                m.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE
              ];
            if (e && t && ["route", "custom"].includes(t))
              return (0, u.spanToJSON)(e).description;
          }
          _initializeRecording() {
            this.setInitialState(),
              this._updateSessionActivity(),
              (this.eventBuffer = bn({
                useCompression: this._options.useCompression,
                workerUrl: this._options.workerUrl,
              })),
              this._removeListeners(),
              this._addListeners(),
              (this._isEnabled = !0),
              (this._isPaused = !1),
              this.startRecording();
          }
          _handleException(e) {
            ln && S.logger.error("[Replay]", e),
              ln &&
                this._options._experiments &&
                this._options._experiments.captureExceptions &&
                (0, o.captureException)(e);
          }
          _initializeSessionForSampling(e) {
            const t = this._options.errorSampleRate > 0,
              n = In(
                {
                  sessionIdleExpire: this.timeouts.sessionIdleExpire,
                  maxReplayDuration: this._options.maxReplayDuration,
                  traceInternals: this._options._experiments.traceInternals,
                  previousSessionId: e,
                },
                {
                  stickySession: this._options.stickySession,
                  sessionSampleRate: this._options.sessionSampleRate,
                  allowBuffering: t,
                },
              );
            this.session = n;
          }
          _checkSession() {
            if (!this.session) return !1;
            const e = this.session;
            return (
              !wn(e, {
                sessionIdleExpire: this.timeouts.sessionIdleExpire,
                maxReplayDuration: this._options.maxReplayDuration,
              }) || (this._refreshSession(e), !1)
            );
          }
          async _refreshSession(e) {
            this._isEnabled &&
              (await this.stop({ reason: "refresh session" }),
              this.initializeSampling(e.id));
          }
          _addListeners() {
            try {
              I.document.addEventListener(
                "visibilitychange",
                this._handleVisibilityChange,
              ),
                I.addEventListener("blur", this._handleWindowBlur),
                I.addEventListener("focus", this._handleWindowFocus),
                I.addEventListener("keydown", this._handleKeyboardEvent),
                this.clickDetector && this.clickDetector.addListeners(),
                this._hasInitializedCoreListeners ||
                  (!(function (e) {
                    const t = (0, o.getCurrentScope)(),
                      n = (0, o.getClient)();
                    t.addScopeListener(as(e)),
                      (0, x.addClickKeypressInstrumentationHandler)(en(e)),
                      (0, k.addHistoryInstrumentationHandler)(Fn(e)),
                      is(e);
                    const s = Bn(e, !rs(n));
                    n && n.addEventProcessor
                      ? n.addEventProcessor(s)
                      : (0, r.addEventProcessor)(s),
                      rs(n) &&
                        (n.on("beforeSendEvent", Ln(e)),
                        n.on("afterSendEvent", Nn(e)),
                        n.on("createDsc", (t) => {
                          const n = e.getSessionId();
                          n &&
                            e.isEnabled() &&
                            "session" === e.recordingMode &&
                            e.checkAndHandleExpiredSession() &&
                            (t.replay_id = n);
                        }),
                        n.on("startTransaction", (t) => {
                          e.lastTransaction = t;
                        }),
                        n.on("finishTransaction", (t) => {
                          e.lastTransaction = t;
                        }),
                        n.on("beforeSendFeedback", (t, n) => {
                          const s = e.getSessionId();
                          n &&
                            n.includeReplay &&
                            e.isEnabled() &&
                            s &&
                            (e.flush(),
                            t.contexts &&
                              t.contexts.feedback &&
                              (t.contexts.feedback.replay_id = s));
                        }));
                  })(this),
                  (this._hasInitializedCoreListeners = !0));
            } catch (e) {
              this._handleException(e);
            }
            this._performanceCleanupCallback = rn(this);
          }
          _removeListeners() {
            try {
              I.document.removeEventListener(
                "visibilitychange",
                this._handleVisibilityChange,
              ),
                I.removeEventListener("blur", this._handleWindowBlur),
                I.removeEventListener("focus", this._handleWindowFocus),
                I.removeEventListener("keydown", this._handleKeyboardEvent),
                this.clickDetector && this.clickDetector.removeListeners(),
                this._performanceCleanupCallback &&
                  this._performanceCleanupCallback();
            } catch (e) {
              this._handleException(e);
            }
          }
          __init() {
            this._handleVisibilityChange = () => {
              "visible" === I.document.visibilityState
                ? this._doChangeToForegroundTasks()
                : this._doChangeToBackgroundTasks();
            };
          }
          __init2() {
            this._handleWindowBlur = () => {
              const e = Jt({ category: "ui.blur" });
              this._doChangeToBackgroundTasks(e);
            };
          }
          __init3() {
            this._handleWindowFocus = () => {
              const e = Jt({ category: "ui.focus" });
              this._doChangeToForegroundTasks(e);
            };
          }
          __init4() {
            this._handleKeyboardEvent = (e) => {
              nn(this, e);
            };
          }
          _doChangeToBackgroundTasks(e) {
            if (!this.session) return;
            Cn(this.session, {
              maxReplayDuration: this._options.maxReplayDuration,
              sessionIdleExpire: this.timeouts.sessionIdleExpire,
            }) ||
              (e && this._createCustomBreadcrumb(e), this.conditionalFlush());
          }
          _doChangeToForegroundTasks(e) {
            if (!this.session) return;
            this.checkAndHandleExpiredSession()
              ? e && this._createCustomBreadcrumb(e)
              : un(
                  "[Replay] Document has become active, but session has expired",
                );
          }
          _updateUserActivity(e = Date.now()) {
            this._lastActivity = e;
          }
          _updateSessionActivity(e = Date.now()) {
            this.session &&
              ((this.session.lastActivity = e), this._maybeSaveSession());
          }
          _createCustomBreadcrumb(e) {
            this.addUpdate(() => {
              this.throttledAddEvent({
                type: qe.Custom,
                timestamp: e.timestamp || 0,
                data: { tag: "breadcrumb", payload: e },
              });
            });
          }
          _addPerformanceEntries() {
            const e = ((t = this.performanceEntries),
            t.map(on).filter(Boolean)).concat(this.replayPerformanceEntries);
            var t;
            return (
              (this.performanceEntries = []),
              (this.replayPerformanceEntries = []),
              Promise.all(Un(this, e))
            );
          }
          _clearContext() {
            this._context.errorIds.clear(),
              this._context.traceIds.clear(),
              (this._context.urls = []);
          }
          _updateInitialTimestampFromEventBuffer() {
            const { session: e, eventBuffer: t } = this;
            if (!e || !t) return;
            if (e.segmentId) return;
            const n = t.getEarliestTimestamp();
            n &&
              n < this._context.initialTimestamp &&
              (this._context.initialTimestamp = n);
          }
          _popEventContext() {
            const e = {
              initialTimestamp: this._context.initialTimestamp,
              initialUrl: this._context.initialUrl,
              errorIds: Array.from(this._context.errorIds),
              traceIds: Array.from(this._context.traceIds),
              urls: this._context.urls,
            };
            return this._clearContext(), e;
          }
          async _runFlush() {
            const e = this.getSessionId();
            if (this.session && this.eventBuffer && e) {
              if (
                (await this._addPerformanceEntries(),
                this.eventBuffer &&
                  this.eventBuffer.hasEvents &&
                  (await (async function (e) {
                    try {
                      return Promise.all(Un(e, [ls(I.performance.memory)]));
                    } catch (e) {
                      return [];
                    }
                  })(this),
                  this.eventBuffer && e === this.getSessionId()))
              )
                try {
                  this._updateInitialTimestampFromEventBuffer();
                  const t = Date.now();
                  if (
                    t - this._context.initialTimestamp >
                    this._options.maxReplayDuration + 3e4
                  )
                    throw new Error("Session is too long, not sending replay");
                  const n = this._popEventContext(),
                    s = this.session.segmentId++;
                  this._maybeSaveSession();
                  const i = await this.eventBuffer.finish();
                  await ps({
                    replayId: e,
                    recordingData: i,
                    segmentId: s,
                    eventContext: n,
                    session: this.session,
                    options: this.getOptions(),
                    timestamp: t,
                  });
                } catch (e) {
                  this._handleException(e), this.stop({ reason: "sendReplay" });
                  const t = (0, o.getClient)();
                  t && t.recordDroppedEvent("send_error", "replay");
                }
            } else
              ln &&
                S.logger.error(
                  "[Replay] No session or eventBuffer found to flush.",
                );
          }
          __init5() {
            this._flush = async ({ force: e = !1 } = {}) => {
              if (!this._isEnabled && !e) return;
              if (!this.checkAndHandleExpiredSession())
                return void (
                  ln &&
                  S.logger.error(
                    "[Replay] Attempting to finish replay event after session expired.",
                  )
                );
              if (!this.session) return;
              const t = this.session.started,
                n = Date.now() - t;
              this._debouncedFlush.cancel();
              const s = n < this._options.minReplayDuration,
                i = n > this._options.maxReplayDuration + 5e3;
              if (s || i)
                return (
                  un(
                    `[Replay] Session duration (${Math.floor(n / 1e3)}s) is too ${s ? "short" : "long"}, not sending replay.`,
                    this._options._experiments.traceInternals,
                  ),
                  void (s && this._debouncedFlush())
                );
              const o = this.eventBuffer;
              if (
                (o &&
                  0 === this.session.segmentId &&
                  !o.hasCheckout &&
                  un(
                    "[Replay] Flushing initial segment without checkout.",
                    this._options._experiments.traceInternals,
                  ),
                !this._flushLock)
              )
                return (
                  (this._flushLock = this._runFlush()),
                  await this._flushLock,
                  void (this._flushLock = void 0)
                );
              try {
                await this._flushLock;
              } catch (e) {
                ln && S.logger.error(e);
              } finally {
                this._debouncedFlush();
              }
            };
          }
          _maybeSaveSession() {
            this.session && this._options.stickySession && kn(this.session);
          }
          __init6() {
            this._onMutationHandler = (e) => {
              const t = e.length,
                n = this._options.mutationLimit,
                s = n && t > n;
              if (t > this._options.mutationBreadcrumbLimit || s) {
                const e = Jt({
                  category: "replay.mutations",
                  data: { count: t, limit: s },
                });
                this._createCustomBreadcrumb(e);
              }
              return (
                !s ||
                (this.stop({
                  reason: "mutationLimit",
                  forceFlush: "session" === this.recordingMode,
                }),
                !1)
              );
            };
          }
        }
        function Ss(e, t, n, s) {
          const i = [...e, ...("string" == typeof s ? s.split(",") : []), ...t];
          return (
            void 0 !== n &&
              ("string" == typeof n && i.push(`.${n}`),
              (0, S.consoleSandbox)(() => {
                console.warn(
                  "[Replay] You are using a deprecated configuration item for privacy. Read the documentation on how to use the new privacy configuration.",
                );
              })),
            i.join(",")
          );
        }
        const bs =
            'img,image,svg,video,object,picture,embed,map,audio,link[rel="icon"],link[rel="apple-touch-icon"]',
          ys = ["content-length", "content-type", "accept"];
        let _s = !1;
        const vs = (e) => new xs(e);
        class xs {
          static __initStatic() {
            this.id = "Replay";
          }
          constructor({
            flushMinDelay: e = 5e3,
            flushMaxDelay: t = 5500,
            minReplayDuration: n = 4999,
            maxReplayDuration: s = 36e5,
            stickySession: i = !0,
            useCompression: o = !0,
            workerUrl: a,
            _experiments: r = {},
            sessionSampleRate: l,
            errorSampleRate: c,
            maskAllText: u = !0,
            maskAllInputs: m = !0,
            blockAllMedia: d = !0,
            mutationBreadcrumbLimit: p = 750,
            mutationLimit: h = 1e4,
            slowClickTimeout: g = 7e3,
            slowClickIgnoreSelectors: f = [],
            networkDetailAllowUrls: S = [],
            networkDetailDenyUrls: b = [],
            networkCaptureBodies: y = !0,
            networkRequestHeaders: _ = [],
            networkResponseHeaders: v = [],
            mask: x = [],
            maskAttributes: k = ["title", "placeholder"],
            unmask: E = [],
            block: T = [],
            unblock: w = [],
            ignore: I = [],
            maskFn: A,
            beforeAddRecordingEvent: P,
            beforeErrorSampling: R,
            blockClass: D,
            blockSelector: M,
            maskInputOptions: O,
            maskTextClass: L,
            maskTextSelector: B,
            ignoreClass: U,
          } = {}) {
            this.name = xs.id;
            const F = (function ({
              mask: e,
              unmask: t,
              block: n,
              unblock: s,
              ignore: i,
              blockClass: o,
              blockSelector: a,
              maskTextClass: r,
              maskTextSelector: l,
              ignoreClass: c,
            }) {
              const u = {
                maskTextSelector: Ss(
                  e,
                  [".sentry-mask", "[data-sentry-mask]"],
                  r,
                  l,
                ),
                unmaskTextSelector: Ss(t, [
                  ".sentry-unmask",
                  "[data-sentry-unmask]",
                ]),
                blockSelector: Ss(
                  n,
                  [".sentry-block", "[data-sentry-block]", 'base[href="/"]'],
                  o,
                  a,
                ),
                unblockSelector: Ss(s, [
                  ".sentry-unblock",
                  "[data-sentry-unblock]",
                ]),
                ignoreSelector: Ss(
                  i,
                  [
                    ".sentry-ignore",
                    "[data-sentry-ignore]",
                    'input[type="file"]',
                  ],
                  c,
                ),
              };
              return (
                o instanceof RegExp && (u.blockClass = o),
                r instanceof RegExp && (u.maskTextClass = r),
                u
              );
            })({
              mask: x,
              unmask: E,
              block: T,
              unblock: w,
              ignore: I,
              blockClass: D,
              blockSelector: M,
              maskTextClass: L,
              maskTextSelector: B,
              ignoreClass: U,
            });
            if (
              ((this._recordingOptions = {
                maskAllInputs: m,
                maskAllText: u,
                maskInputOptions: { ...(O || {}), password: !0 },
                maskTextFn: A,
                maskInputFn: A,
                maskAttributeFn: (e, t, n) =>
                  (function ({
                    el: e,
                    key: t,
                    maskAttributes: n,
                    maskAllText: s,
                    privacyOptions: i,
                    value: o,
                  }) {
                    return s
                      ? i.unmaskTextSelector && e.matches(i.unmaskTextSelector)
                        ? o
                        : n.includes(t) ||
                            ("value" === t &&
                              "INPUT" === e.tagName &&
                              ["submit", "button"].includes(
                                e.getAttribute("type") || "",
                              ))
                          ? o.replace(/[\S]/g, "*")
                          : o
                      : o;
                  })({
                    maskAttributes: k,
                    maskAllText: u,
                    privacyOptions: F,
                    key: e,
                    value: t,
                    el: n,
                  }),
                ...F,
                slimDOMOptions: "all",
                inlineStylesheet: !0,
                inlineImages: !1,
                collectFonts: !0,
                errorHandler: (e) => {
                  try {
                    e.__rrweb__ = !0;
                  } catch (e) {}
                },
              }),
              (this._initialOptions = {
                flushMinDelay: e,
                flushMaxDelay: t,
                minReplayDuration: Math.min(n, 15e3),
                maxReplayDuration: Math.min(s, N),
                stickySession: i,
                sessionSampleRate: l,
                errorSampleRate: c,
                useCompression: o,
                workerUrl: a,
                blockAllMedia: d,
                maskAllInputs: m,
                maskAllText: u,
                mutationBreadcrumbLimit: p,
                mutationLimit: h,
                slowClickTimeout: g,
                slowClickIgnoreSelectors: f,
                networkDetailAllowUrls: S,
                networkDetailDenyUrls: b,
                networkCaptureBodies: y,
                networkRequestHeaders: ks(_),
                networkResponseHeaders: ks(v),
                beforeAddRecordingEvent: P,
                beforeErrorSampling: R,
                _experiments: r,
              }),
              "number" == typeof l &&
                (console.warn(
                  `[Replay] You are passing \`sessionSampleRate\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \`replaysSessionSampleRate\` directly in the SDK init options, e.g.:\nSentry.init({ replaysSessionSampleRate: ${l} })`,
                ),
                (this._initialOptions.sessionSampleRate = l)),
              "number" == typeof c &&
                (console.warn(
                  `[Replay] You are passing \`errorSampleRate\` to the Replay integration.\nThis option is deprecated and will be removed soon.\nInstead, configure \`replaysOnErrorSampleRate\` directly in the SDK init options, e.g.:\nSentry.init({ replaysOnErrorSampleRate: ${c} })`,
                ),
                (this._initialOptions.errorSampleRate = c)),
              this._initialOptions.blockAllMedia &&
                (this._recordingOptions.blockSelector = this._recordingOptions
                  .blockSelector
                  ? `${this._recordingOptions.blockSelector},${bs}`
                  : bs),
              this._isInitialized && (0, C.isBrowser)())
            )
              throw new Error(
                "Multiple Sentry Session Replay instances are not supported",
              );
            this._isInitialized = !0;
          }
          get _isInitialized() {
            return _s;
          }
          set _isInitialized(e) {
            _s = e;
          }
          setupOnce() {
            (0, C.isBrowser)() &&
              (this._setup(), setTimeout(() => this._initialize()));
          }
          start() {
            this._replay && this._replay.start();
          }
          startBuffering() {
            this._replay && this._replay.startBuffering();
          }
          stop() {
            return this._replay
              ? this._replay.stop({
                  forceFlush: "session" === this._replay.recordingMode,
                })
              : Promise.resolve();
          }
          flush(e) {
            return this._replay && this._replay.isEnabled()
              ? this._replay.sendBufferedReplayOrFlush(e)
              : Promise.resolve();
          }
          getReplayId() {
            if (this._replay && this._replay.isEnabled())
              return this._replay.getSessionId();
          }
          _initialize() {
            this._replay &&
              (this._maybeLoadFromReplayCanvasIntegration(),
              this._replay.initializeSampling());
          }
          _setup() {
            const e = (function (e) {
              const t = (0, o.getClient)(),
                n = t && t.getOptions(),
                s = {
                  sessionSampleRate: 0,
                  errorSampleRate: 0,
                  ...(0, h.dropUndefinedKeys)(e),
                };
              if (!n)
                return (
                  (0, S.consoleSandbox)(() => {
                    console.warn("SDK client is not available.");
                  }),
                  s
                );
              null == e.sessionSampleRate &&
                null == e.errorSampleRate &&
                null == n.replaysSessionSampleRate &&
                null == n.replaysOnErrorSampleRate &&
                (0, S.consoleSandbox)(() => {
                  console.warn(
                    "Replay is disabled because neither `replaysSessionSampleRate` nor `replaysOnErrorSampleRate` are set.",
                  );
                });
              "number" == typeof n.replaysSessionSampleRate &&
                (s.sessionSampleRate = n.replaysSessionSampleRate);
              "number" == typeof n.replaysOnErrorSampleRate &&
                (s.errorSampleRate = n.replaysOnErrorSampleRate);
              return s;
            })(this._initialOptions);
            this._replay = new fs({
              options: e,
              recordingOptions: this._recordingOptions,
            });
          }
          _maybeLoadFromReplayCanvasIntegration() {
            try {
              const e = (0, o.getClient)().getIntegrationByName("ReplayCanvas");
              if (!e) return;
              this._replay._canvas = e.getOptions();
            } catch (e) {}
          }
        }
        function ks(e) {
          return [...ys, ...e.map((e) => e.toLowerCase())];
        }
        function Es() {
          const e = (0, o.getClient)();
          return (
            e && e.getIntegrationByName && e.getIntegrationByName("Replay")
          );
        }
        xs.__initStatic();
      },
      (e, t, n) => {
        "use strict";
        function s(e, t) {
          return null != e ? e : t();
        }
        n.r(t), n.d(t, { _nullishCoalesce: () => s });
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          let t,
            n = e[0],
            s = 1;
          for (; s < e.length; ) {
            const i = e[s],
              o = e[s + 1];
            if (
              ((s += 2),
              ("optionalAccess" === i || "optionalCall" === i) && null == n)
            )
              return;
            "access" === i || "optionalAccess" === i
              ? ((t = n), (n = o(n)))
              : ("call" !== i && "optionalCall" !== i) ||
                ((n = o((...e) => n.call(t, ...e))), (t = void 0));
          }
          return n;
        }
        n.r(t), n.d(t, { _optionalChain: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addClsInstrumentationHandler: () => g,
            addFidInstrumentationHandler: () => S,
            addLcpInstrumentationHandler: () => f,
            addPerformanceInstrumentationHandler: () => b,
          });
        var s = n(7),
          i = n(32),
          o = n(107),
          a = n(108),
          r = n(117),
          l = n(119),
          c = n(114);
        const u = {},
          m = {};
        let d, p, h;
        function g(e, t = !1) {
          return k("cls", e, _, d, t);
        }
        function f(e, t = !1) {
          return k("lcp", e, x, h, t);
        }
        function S(e) {
          return k("fid", e, v, p);
        }
        function b(e, t) {
          return (
            E(e, t),
            m[e] ||
              (!(function (e) {
                const t = {};
                "event" === e && (t.durationThreshold = 0);
                (0, c.observe)(
                  e,
                  (t) => {
                    y(e, { entries: t });
                  },
                  t,
                );
              })(e),
              (m[e] = !0)),
            T(e, t)
          );
        }
        function y(e, t) {
          const n = u[e];
          if (n && n.length)
            for (const a of n)
              try {
                a(t);
              } catch (t) {
                o.DEBUG_BUILD &&
                  s.logger.error(
                    `Error while triggering instrumentation handler.\nType: ${e}\nName: ${(0, i.getFunctionName)(a)}\nError:`,
                    t,
                  );
              }
        }
        function _() {
          return (0, a.onCLS)((e) => {
            y("cls", { metric: e }), (d = e);
          });
        }
        function v() {
          return (0, r.onFID)((e) => {
            y("fid", { metric: e }), (p = e);
          });
        }
        function x() {
          return (0, l.onLCP)((e) => {
            y("lcp", { metric: e }), (h = e);
          });
        }
        function k(e, t, n, s, i = !1) {
          let o;
          return (
            E(e, t),
            m[e] || ((o = n()), (m[e] = !0)),
            s && t({ metric: s }),
            T(e, t, i ? o : void 0)
          );
        }
        function E(e, t) {
          (u[e] = u[e] || []), u[e].push(t);
        }
        function T(e, t, n) {
          return () => {
            n && n();
            const s = u[e];
            if (!s) return;
            const i = s.indexOf(t);
            -1 !== i && s.splice(i, 1);
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { DEBUG_BUILD: () => s });
        const s = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { onCLS: () => r });
        var s = n(115),
          i = n(109),
          o = n(114),
          a = n(116);
        const r = (e) => {
          const t = (0, i.initMetric)("CLS", 0);
          let n,
            r = 0,
            l = [];
          const c = (e) => {
              e.forEach((e) => {
                if (!e.hadRecentInput) {
                  const s = l[0],
                    i = l[l.length - 1];
                  r &&
                  0 !== l.length &&
                  e.startTime - i.startTime < 1e3 &&
                  e.startTime - s.startTime < 5e3
                    ? ((r += e.value), l.push(e))
                    : ((r = e.value), (l = [e])),
                    r > t.value && ((t.value = r), (t.entries = l), n && n());
                }
              });
            },
            u = (0, o.observe)("layout-shift", c);
          if (u) {
            n = (0, s.bindReporter)(e, t);
            const i = () => {
              c(u.takeRecords()), n(!0);
            };
            return (0, a.onHidden)(i), i;
          }
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { initMetric: () => r });
        var s = n(111),
          i = n(113),
          o = n(112),
          a = n(110);
        const r = (e, t) => {
          const n = (0, a.getNavigationEntry)();
          let r = "navigate";
          return (
            n &&
              (r =
                s.WINDOW.document.prerendering ||
                (0, o.getActivationStart)() > 0
                  ? "prerender"
                  : n.type.replace(/_/g, "-")),
            {
              name: e,
              value: void 0 === t ? -1 : t,
              rating: "good",
              delta: 0,
              entries: [],
              id: (0, i.generateUniqueID)(),
              navigationType: r,
            }
          );
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { getNavigationEntry: () => i });
        var s = n(111);
        const i = () =>
          s.WINDOW.__WEB_VITALS_POLYFILL__
            ? s.WINDOW.performance &&
              ((performance.getEntriesByType &&
                performance.getEntriesByType("navigation")[0]) ||
                (() => {
                  const e = s.WINDOW.performance.timing,
                    t = s.WINDOW.performance.navigation.type,
                    n = {
                      entryType: "navigation",
                      startTime: 0,
                      type:
                        2 == t
                          ? "back_forward"
                          : 1 === t
                            ? "reload"
                            : "navigate",
                    };
                  for (const t in e)
                    "navigationStart" !== t &&
                      "toJSON" !== t &&
                      (n[t] = Math.max(e[t] - e.navigationStart, 0));
                  return n;
                })())
            : s.WINDOW.performance &&
              performance.getEntriesByType &&
              performance.getEntriesByType("navigation")[0];
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { WINDOW: () => s });
        const s = n(8).GLOBAL_OBJ;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { getActivationStart: () => i });
        var s = n(110);
        const i = () => {
          const e = (0, s.getNavigationEntry)();
          return (e && e.activationStart) || 0;
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { generateUniqueID: () => s });
        const s = () =>
          `v3-${Date.now()}-${Math.floor(8999999999999 * Math.random()) + 1e12}`;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { observe: () => s });
        const s = (e, t, n) => {
          try {
            if (PerformanceObserver.supportedEntryTypes.includes(e)) {
              const s = new PerformanceObserver((e) => {
                t(e.getEntries());
              });
              return (
                s.observe(Object.assign({ type: e, buffered: !0 }, n || {})), s
              );
            }
          } catch (e) {}
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { bindReporter: () => s });
        const s = (e, t, n) => {
          let s, i;
          return (o) => {
            t.value >= 0 &&
              (o || n) &&
              ((i = t.value - (s || 0)),
              (i || void 0 === s) && ((s = t.value), (t.delta = i), e(t)));
          };
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { onHidden: () => i });
        var s = n(111);
        const i = (e, t) => {
          const n = (i) => {
            ("pagehide" !== i.type &&
              "hidden" !== s.WINDOW.document.visibilityState) ||
              (e(i),
              t &&
                (removeEventListener("visibilitychange", n, !0),
                removeEventListener("pagehide", n, !0)));
          };
          addEventListener("visibilitychange", n, !0),
            addEventListener("pagehide", n, !0);
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { onFID: () => l });
        var s = n(115),
          i = n(118),
          o = n(109),
          a = n(114),
          r = n(116);
        const l = (e) => {
          const t = (0, i.getVisibilityWatcher)(),
            n = (0, o.initMetric)("FID");
          let l;
          const c = (e) => {
              e.startTime < t.firstHiddenTime &&
                ((n.value = e.processingStart - e.startTime),
                n.entries.push(e),
                l(!0));
            },
            u = (e) => {
              e.forEach(c);
            },
            m = (0, a.observe)("first-input", u);
          (l = (0, s.bindReporter)(e, n)),
            m &&
              (0, r.onHidden)(() => {
                u(m.takeRecords()), m.disconnect();
              }, !0);
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { getVisibilityWatcher: () => a });
        var s = n(111),
          i = n(116);
        let o = -1;
        const a = () => (
          o < 0 &&
            ((o =
              "hidden" !== s.WINDOW.document.visibilityState ||
              s.WINDOW.document.prerendering
                ? 1 / 0
                : 0),
            (0, i.onHidden)(({ timeStamp: e }) => {
              o = e;
            }, !0)),
          {
            get firstHiddenTime() {
              return o;
            },
          }
        );
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { onLCP: () => u });
        var s = n(115),
          i = n(112),
          o = n(118),
          a = n(109),
          r = n(114),
          l = n(116);
        const c = {},
          u = (e) => {
            const t = (0, o.getVisibilityWatcher)(),
              n = (0, a.initMetric)("LCP");
            let u;
            const m = (e) => {
                const s = e[e.length - 1];
                if (s) {
                  const e = Math.max(
                    s.startTime - (0, i.getActivationStart)(),
                    0,
                  );
                  e < t.firstHiddenTime &&
                    ((n.value = e), (n.entries = [s]), u());
                }
              },
              d = (0, r.observe)("largest-contentful-paint", m);
            if (d) {
              u = (0, s.bindReporter)(e, n);
              const t = () => {
                c[n.id] ||
                  (m(d.takeRecords()), d.disconnect(), (c[n.id] = !0), u(!0));
              };
              return (
                ["keydown", "click"].forEach((e) => {
                  addEventListener(e, t, { once: !0, capture: !0 });
                }),
                (0, l.onHidden)(t, !0),
                t
              );
            }
          };
      },
      (e, t, n) => {
        "use strict";
        function s(e, t) {
          const n =
              t &&
              (function (e) {
                return void 0 !== e.getClient;
              })(t)
                ? t.getClient()
                : t,
            s = n && n.getDsn(),
            o = n && n.getOptions().tunnel;
          return (
            (function (e, t) {
              return !!t && e.includes(t.host);
            })(e, s) ||
            (function (e, t) {
              if (!t) return !1;
              return i(e) === i(t);
            })(e, o)
          );
        }
        function i(e) {
          return "/" === e[e.length - 1] ? e.slice(0, -1) : e;
        }
        n.r(t), n.d(t, { isSentryRequestUrl: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { isBrowser: () => o });
        var s = n(122),
          i = n(8);
        function o() {
          return (
            "undefined" != typeof window &&
            (!(0, s.isNodeEnv)() ||
              (void 0 !== i.GLOBAL_OBJ.process &&
                "renderer" === i.GLOBAL_OBJ.process.type))
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            dynamicRequire: () => o,
            isNodeEnv: () => i,
            loadModule: () => a,
          });
        var s = n(77);
        function i() {
          return (
            !(0, s.isBrowserBundle)() &&
            "[object process]" ===
              Object.prototype.toString.call(
                "undefined" != typeof process ? process : 0,
              )
          );
        }
        function o(e, t) {
          return e.require(t);
        }
        function a(t) {
          let n;
          try {
            n = o(e, t);
          } catch (e) {}
          try {
            const { cwd: s } = o(e, "process");
            n = o(e, `${s()}/node_modules/${t}`);
          } catch (e) {}
          return n;
        }
        e = n.hmd(e);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { ReplayCanvas: () => M, replayCanvasIntegration: () => D });
        var s,
          i = n(105),
          o = n(34);
        function a(e, t, n = 1 / 0, s = 0) {
          return e
            ? e.nodeType !== e.ELEMENT_NODE || s > n
              ? -1
              : t(e)
                ? s
                : a(e.parentNode, t, n, s + 1)
            : -1;
        }
        function r(e, t) {
          return (n) => {
            const s = n;
            if (null === s) return !1;
            try {
              if (e)
                if ("string" == typeof e) {
                  if (s.matches(`.${e}`)) return !0;
                } else if (
                  (function (e, t) {
                    for (let n = e.classList.length; n--; ) {
                      const s = e.classList[n];
                      if (t.test(s)) return !0;
                    }
                    return !1;
                  })(s, e)
                )
                  return !0;
              return !(!t || !s.matches(t));
            } catch (e) {
              return !1;
            }
          };
        }
        !(function (e) {
          (e[(e.Document = 0)] = "Document"),
            (e[(e.DocumentType = 1)] = "DocumentType"),
            (e[(e.Element = 2)] = "Element"),
            (e[(e.Text = 3)] = "Text"),
            (e[(e.CDATA = 4)] = "CDATA"),
            (e[(e.Comment = 5)] = "Comment");
        })(s || (s = {}));
        const l =
          "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
        let c,
          u = {
            map: {},
            getId: () => (console.error(l), -1),
            getNode: () => (console.error(l), null),
            removeNodeFromMap() {
              console.error(l);
            },
            has: () => (console.error(l), !1),
            reset() {
              console.error(l);
            },
          };
        function m(e, t, n, s, i = window) {
          const o = i.Object.getOwnPropertyDescriptor(e, t);
          return (
            i.Object.defineProperty(
              e,
              t,
              s
                ? n
                : {
                    set(e) {
                      setTimeout(() => {
                        n.set.call(this, e);
                      }, 0),
                        o && o.set && o.set.call(this, e);
                    },
                  },
            ),
            () => m(e, t, o || {}, !0)
          );
        }
        function d(e, t, n) {
          try {
            if (!(t in e)) return () => {};
            const s = e[t],
              i = n(s);
            return (
              "function" == typeof i &&
                ((i.prototype = i.prototype || {}),
                Object.defineProperties(i, {
                  __rrweb_original__: { enumerable: !1, value: s },
                })),
              (e[t] = i),
              () => {
                e[t] = s;
              }
            );
          } catch (e) {
            return () => {};
          }
        }
        function p(e, t, n, s, i) {
          if (!e) return !1;
          const o = e.nodeType === e.ELEMENT_NODE ? e : e.parentElement;
          if (!o) return !1;
          const l = r(t, n);
          if (!i) {
            const e = s && o.matches(s);
            return l(o) && !e;
          }
          const c = a(o, l);
          let u = -1;
          return (
            !(c < 0) &&
            (s && (u = a(o, r(null, s))), (c > -1 && u < 0) || c < u)
          );
        }
        function h(...e) {
          return (function () {
            if (c) return c;
            const e = window.document;
            let t = window.requestAnimationFrame;
            if (e && "function" == typeof e.createElement)
              try {
                const n = e.createElement("iframe");
                (n.hidden = !0), e.head.appendChild(n);
                const s = n.contentWindow;
                s && s.requestAnimationFrame && (t = s.requestAnimationFrame),
                  e.head.removeChild(n);
              } catch (e) {}
            return (c = t.bind(window));
          })()(...e);
        }
        "undefined" != typeof window &&
          window.Proxy &&
          window.Reflect &&
          (u = new Proxy(u, {
            get: (e, t, n) => (
              "map" === t && console.error(l), Reflect.get(e, t, n)
            ),
          })),
          /[1-9][0-9]{12}/.test(Date.now().toString());
        var g = ((e) => (
          (e[(e["2D"] = 0)] = "2D"),
          (e[(e.WebGL = 1)] = "WebGL"),
          (e[(e.WebGL2 = 2)] = "WebGL2"),
          e
        ))(g || {});
        let f;
        function S(e) {
          f = e;
        }
        const b = (e) => {
          if (!f) return e;
          return (...t) => {
            try {
              return e(...t);
            } catch (e) {
              if (f && !0 === f(e)) return () => {};
              throw e;
            }
          };
        };
        for (
          var y =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            _ = "undefined" == typeof Uint8Array ? [] : new Uint8Array(256),
            v = 0;
          v < 64;
          v++
        )
          _[y.charCodeAt(v)] = v;
        const x = new Map();
        const k = (e, t, n) => {
          if (!e || (!C(e, t) && "object" != typeof e)) return;
          const s = (function (e, t) {
            let n = x.get(e);
            return (
              n || ((n = new Map()), x.set(e, n)),
              n.has(t) || n.set(t, []),
              n.get(t)
            );
          })(n, e.constructor.name);
          let i = s.indexOf(e);
          return -1 === i && ((i = s.length), s.push(e)), i;
        };
        function E(e, t, n) {
          if (e instanceof Array) return e.map((e) => E(e, t, n));
          if (null === e) return e;
          if (
            e instanceof Float32Array ||
            e instanceof Float64Array ||
            e instanceof Int32Array ||
            e instanceof Uint32Array ||
            e instanceof Uint8Array ||
            e instanceof Uint16Array ||
            e instanceof Int16Array ||
            e instanceof Int8Array ||
            e instanceof Uint8ClampedArray
          ) {
            return { rr_type: e.constructor.name, args: [Object.values(e)] };
          }
          if (e instanceof ArrayBuffer) {
            const t = e.constructor.name,
              n = (function (e) {
                var t,
                  n = new Uint8Array(e),
                  s = n.length,
                  i = "";
                for (t = 0; t < s; t += 3)
                  (i += y[n[t] >> 2]),
                    (i += y[((3 & n[t]) << 4) | (n[t + 1] >> 4)]),
                    (i += y[((15 & n[t + 1]) << 2) | (n[t + 2] >> 6)]),
                    (i += y[63 & n[t + 2]]);
                return (
                  s % 3 == 2
                    ? (i = i.substring(0, i.length - 1) + "=")
                    : s % 3 == 1 && (i = i.substring(0, i.length - 2) + "=="),
                  i
                );
              })(e);
            return { rr_type: t, base64: n };
          }
          if (e instanceof DataView) {
            return {
              rr_type: e.constructor.name,
              args: [E(e.buffer, t, n), e.byteOffset, e.byteLength],
            };
          }
          if (e instanceof HTMLImageElement) {
            const t = e.constructor.name,
              { src: n } = e;
            return { rr_type: t, src: n };
          }
          if (e instanceof HTMLCanvasElement) {
            return { rr_type: "HTMLImageElement", src: e.toDataURL() };
          }
          if (e instanceof ImageData) {
            return {
              rr_type: e.constructor.name,
              args: [E(e.data, t, n), e.width, e.height],
            };
          }
          if (C(e, t) || "object" == typeof e) {
            return { rr_type: e.constructor.name, index: k(e, t, n) };
          }
          return e;
        }
        const T = (e, t, n) => e.map((e) => E(e, t, n)),
          C = (e, t) => {
            const n = [
              "WebGLActiveInfo",
              "WebGLBuffer",
              "WebGLFramebuffer",
              "WebGLProgram",
              "WebGLRenderbuffer",
              "WebGLShader",
              "WebGLShaderPrecisionFormat",
              "WebGLTexture",
              "WebGLUniformLocation",
              "WebGLVertexArrayObject",
              "WebGLVertexArrayObjectOES",
            ].filter((e) => "function" == typeof t[e]);
            return Boolean(n.find((n) => e instanceof t[n]));
          };
        function w(e, t, n, s, i) {
          const o = [];
          try {
            const a = d(
              e.HTMLCanvasElement.prototype,
              "getContext",
              function (e) {
                return function (o, ...a) {
                  if (!p(this, t, n, s, !0)) {
                    const e = (function (e) {
                      return "experimental-webgl" === e ? "webgl" : e;
                    })(o);
                    if (
                      ("__context" in this || (this.__context = e),
                      i && ["webgl", "webgl2"].includes(e))
                    )
                      if (a[0] && "object" == typeof a[0]) {
                        const e = a[0];
                        e.preserveDrawingBuffer ||
                          (e.preserveDrawingBuffer = !0);
                      } else a.splice(0, 1, { preserveDrawingBuffer: !0 });
                  }
                  return e.apply(this, [o, ...a]);
                };
              },
            );
            o.push(a);
          } catch (e) {
            console.error(
              "failed to patch HTMLCanvasElement.prototype.getContext",
            );
          }
          return () => {
            o.forEach((e) => e());
          };
        }
        function I(e, t, n, s, i, o, a, r) {
          const l = [],
            c = Object.getOwnPropertyNames(e);
          for (const a of c)
            if (
              ![
                "isContextLost",
                "canvas",
                "drawingBufferWidth",
                "drawingBufferHeight",
              ].includes(a)
            )
              try {
                if ("function" != typeof e[a]) continue;
                const c = d(e, a, function (e) {
                  return function (...l) {
                    const c = e.apply(this, l);
                    if (
                      (k(c, r, this),
                      "tagName" in this.canvas && !p(this.canvas, s, i, o, !0))
                    ) {
                      const e = T(l, r, this),
                        s = { type: t, property: a, args: e };
                      n(this.canvas, s);
                    }
                    return c;
                  };
                });
                l.push(c);
              } catch (s) {
                const i = m(e, a, {
                  set(e) {
                    n(this.canvas, {
                      type: t,
                      property: a,
                      args: [e],
                      setter: !0,
                    });
                  },
                });
                l.push(i);
              }
          return l;
        }
        class A {
          reset() {
            this.pendingCanvasMutations.clear(),
              this.resetObservers && this.resetObservers();
          }
          freeze() {
            this.frozen = !0;
          }
          unfreeze() {
            this.frozen = !1;
          }
          lock() {
            this.locked = !0;
          }
          unlock() {
            this.locked = !1;
          }
          constructor(e) {
            (this.pendingCanvasMutations = new Map()),
              (this.rafStamps = { latestId: 0, invokeId: null }),
              (this.frozen = !1),
              (this.locked = !1),
              (this.processMutation = (e, t) => {
                (!(
                  this.rafStamps.invokeId &&
                  this.rafStamps.latestId !== this.rafStamps.invokeId
                ) &&
                  this.rafStamps.invokeId) ||
                  (this.rafStamps.invokeId = this.rafStamps.latestId),
                  this.pendingCanvasMutations.has(e) ||
                    this.pendingCanvasMutations.set(e, []),
                  this.pendingCanvasMutations.get(e).push(t);
              });
            const {
              sampling: t = "all",
              win: n,
              blockClass: s,
              blockSelector: i,
              unblockSelector: o,
              recordCanvas: a,
              dataURLOptions: r,
              errorHandler: l,
            } = e;
            (this.mutationCb = e.mutationCb),
              (this.mirror = e.mirror),
              (this.options = e),
              l && S(l),
              e.enableManualSnapshot ||
                b(() => {
                  a &&
                    "all" === t &&
                    this.initCanvasMutationObserver(n, s, i, o),
                    a &&
                      "number" == typeof t &&
                      this.initCanvasFPSObserver(t, n, s, i, o, {
                        dataURLOptions: r,
                      });
                })();
          }
          initCanvasFPSObserver(e, t, n, s, i, o) {
            const a = w(t, n, s, i, !0),
              r = this.takeSnapshot(!1, e, t, n, s, i, o.dataURLOptions);
            this.resetObservers = () => {
              a(), cancelAnimationFrame(r);
            };
          }
          initCanvasMutationObserver(e, t, n, s) {
            this.startRAFTimestamping(),
              this.startPendingCanvasMutationFlusher();
            const i = w(e, t, n, s, !1),
              o = (function (e, t, n, s, i) {
                const o = [],
                  a = Object.getOwnPropertyNames(
                    t.CanvasRenderingContext2D.prototype,
                  );
                for (const r of a)
                  try {
                    if (
                      "function" !=
                      typeof t.CanvasRenderingContext2D.prototype[r]
                    )
                      continue;
                    const a = d(
                      t.CanvasRenderingContext2D.prototype,
                      r,
                      function (o) {
                        return function (...a) {
                          return (
                            p(this.canvas, n, s, i, !0) ||
                              setTimeout(() => {
                                const n = T(a, t, this);
                                e(this.canvas, {
                                  type: g["2D"],
                                  property: r,
                                  args: n,
                                });
                              }, 0),
                            o.apply(this, a)
                          );
                        };
                      },
                    );
                    o.push(a);
                  } catch (n) {
                    const s = m(t.CanvasRenderingContext2D.prototype, r, {
                      set(t) {
                        e(this.canvas, {
                          type: g["2D"],
                          property: r,
                          args: [t],
                          setter: !0,
                        });
                      },
                    });
                    o.push(s);
                  }
                return () => {
                  o.forEach((e) => e());
                };
              })(this.processMutation.bind(this), e, t, n, s),
              a = (function (e, t, n, s, i, o) {
                const a = [];
                return (
                  a.push(
                    ...I(
                      t.WebGLRenderingContext.prototype,
                      g.WebGL,
                      e,
                      n,
                      s,
                      i,
                      0,
                      t,
                    ),
                  ),
                  void 0 !== t.WebGL2RenderingContext &&
                    a.push(
                      ...I(
                        t.WebGL2RenderingContext.prototype,
                        g.WebGL2,
                        e,
                        n,
                        s,
                        i,
                        0,
                        t,
                      ),
                    ),
                  () => {
                    a.forEach((e) => e());
                  }
                );
              })(this.processMutation.bind(this), e, t, n, s, this.mirror);
            this.resetObservers = () => {
              i(), o(), a();
            };
          }
          snapshot(e) {
            const { options: t } = this,
              n = this.takeSnapshot(
                !0,
                "all" === t.sampling ? 2 : t.sampling || 2,
                t.win,
                t.blockClass,
                t.blockSelector,
                t.unblockSelector,
                t.dataURLOptions,
                e,
              );
            this.resetObservers = () => {
              cancelAnimationFrame(n);
            };
          }
          takeSnapshot(e, t, n, s, o, a, r, l) {
            const c = new Map(),
              u = new Worker(
                (function () {
                  const e = new Blob([
                    'for(var t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",e="undefined"==typeof Uint8Array?[]:new Uint8Array(256),n=0;n<64;n++)e[t.charCodeAt(n)]=n;var a=function(e){var n,a=new Uint8Array(e),s=a.length,r="";for(n=0;n<s;n+=3)r+=t[a[n]>>2],r+=t[(3&a[n])<<4|a[n+1]>>4],r+=t[(15&a[n+1])<<2|a[n+2]>>6],r+=t[63&a[n+2]];return s%3==2?r=r.substring(0,r.length-1)+"=":s%3==1&&(r=r.substring(0,r.length-2)+"=="),r};const s=new Map,r=new Map;const i=self;i.onmessage=async function(t){if(!("OffscreenCanvas"in globalThis))return i.postMessage({id:t.data.id});{const{id:e,bitmap:n,width:o,height:f,dataURLOptions:c}=t.data,g=async function(t,e,n){const s=t+"-"+e;if("OffscreenCanvas"in globalThis){if(r.has(s))return r.get(s);const i=new OffscreenCanvas(t,e);i.getContext("2d");const o=await i.convertToBlob(n),f=await o.arrayBuffer(),c=a(f);return r.set(s,c),c}return""}(o,f,c),d=new OffscreenCanvas(o,f);d.getContext("2d").drawImage(n,0,0),n.close();const u=await d.convertToBlob(c),h=u.type,w=await u.arrayBuffer(),l=a(w);if(!s.has(e)&&await g===l)return s.set(e,l),i.postMessage({id:e});if(s.get(e)===l)return i.postMessage({id:e});i.postMessage({id:e,type:h,base64:l,width:o,height:f}),s.set(e,l)}};',
                  ]);
                  return URL.createObjectURL(e);
                })(),
              );
            u.onmessage = (e) => {
              const t = e.data,
                { id: n } = t;
              if ((c.set(n, !1), !("base64" in t))) return;
              const { base64: s, type: i, width: o, height: a } = t;
              this.mutationCb({
                id: n,
                type: g["2D"],
                commands: [
                  { property: "clearRect", args: [0, 0, o, a] },
                  {
                    property: "drawImage",
                    args: [
                      {
                        rr_type: "ImageBitmap",
                        args: [
                          {
                            rr_type: "Blob",
                            data: [{ rr_type: "ArrayBuffer", base64: s }],
                            type: i,
                          },
                        ],
                      },
                      0,
                      0,
                    ],
                  },
                ],
              });
            };
            const m = 1e3 / t;
            let d,
              f = 0;
            const S = (t) => {
              (f && t - f < m) ||
                ((f = t),
                ((e) => {
                  if (e) return [e];
                  const t = [];
                  return (
                    n.document.querySelectorAll("canvas").forEach((e) => {
                      p(e, s, o, a, !0) || t.push(e);
                    }),
                    t
                  );
                })(l).forEach((t) => {
                  const n = this.mirror.getId(t);
                  if (!c.get(n)) {
                    if (
                      (c.set(n, !0),
                      !e && ["webgl", "webgl2"].includes(t.__context))
                    ) {
                      const e = t.getContext(t.__context);
                      !1 ===
                        (0, i._optionalChain)([
                          e,
                          "optionalAccess",
                          (e) => e.getContextAttributes,
                          "call",
                          (e) => e(),
                          "optionalAccess",
                          (e) => e.preserveDrawingBuffer,
                        ]) && e.clear(e.COLOR_BUFFER_BIT);
                    }
                    createImageBitmap(t)
                      .then((e) => {
                        u.postMessage(
                          {
                            id: n,
                            bitmap: e,
                            width: t.width,
                            height: t.height,
                            dataURLOptions: r,
                          },
                          [e],
                        );
                      })
                      .catch((e) => {
                        b(() => {
                          throw e;
                        })();
                      });
                  }
                })),
                (d = h(S));
            };
            return (d = h(S)), d;
          }
          startPendingCanvasMutationFlusher() {
            h(() => this.flushPendingCanvasMutations());
          }
          startRAFTimestamping() {
            const e = (t) => {
              (this.rafStamps.latestId = t), h(e);
            };
            h(e);
          }
          flushPendingCanvasMutations() {
            this.pendingCanvasMutations.forEach((e, t) => {
              const n = this.mirror.getId(t);
              this.flushPendingCanvasMutationFor(t, n);
            }),
              h(() => this.flushPendingCanvasMutations());
          }
          flushPendingCanvasMutationFor(e, t) {
            if (this.frozen || this.locked) return;
            const n = this.pendingCanvasMutations.get(e);
            if (!n || -1 === t) return;
            const s = n.map((e) => {
                const { type: t, ...n } = e;
                return n;
              }),
              { type: i } = n[0];
            this.mutationCb({ id: t, type: i, commands: s }),
              this.pendingCanvasMutations.delete(e);
          }
        }
        const P = {
            low: {
              sampling: { canvas: 1 },
              dataURLOptions: { type: "image/webp", quality: 0.25 },
            },
            medium: {
              sampling: { canvas: 2 },
              dataURLOptions: { type: "image/webp", quality: 0.4 },
            },
            high: {
              sampling: { canvas: 4 },
              dataURLOptions: { type: "image/webp", quality: 0.5 },
            },
          },
          R = "ReplayCanvas",
          D = (0, o.defineIntegration)((e = {}) => {
            const t = {
              quality: e.quality || "medium",
              enableManualSnapshot: e.enableManualSnapshot,
            };
            let n;
            const s = new Promise((e) => (n = e));
            return {
              name: R,
              setupOnce() {},
              getOptions() {
                const { quality: e, enableManualSnapshot: s } = t;
                return {
                  enableManualSnapshot: s,
                  recordCanvas: !0,
                  getCanvasManager: (e) => {
                    const t = new A({ ...e, enableManualSnapshot: s });
                    return n(t), t;
                  },
                  ...(P[e || "medium"] || P.medium),
                };
              },
              async snapshot(e) {
                (await s).snapshot(e);
              },
            };
          }),
          M = (0, o.convertIntegrationFnToClass)(R, D);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            Feedback: () => q,
            feedbackIntegration: () => W,
            sendFeedback: () => v,
          });
        var s = n(8),
          i = n(10),
          o = n(7),
          a = n(121),
          r = n(29),
          l = n(13),
          c = n(12),
          u = n(43);
        const m = s.GLOBAL_OBJ,
          d = "#ffffff",
          p = "inherit",
          h = "rgba(108, 95, 199, 1)",
          g = {
            fontFamily: "system-ui, 'Helvetica Neue', Arial, sans-serif",
            fontSize: "14px",
            background: d,
            backgroundHover: "#f6f6f7",
            foreground: "#2b2233",
            border: "1.5px solid rgba(41, 35, 47, 0.13)",
            borderRadius: "12px",
            boxShadow: "0px 4px 24px 0px rgba(43, 34, 51, 0.12)",
            success: "#268d75",
            error: "#df3338",
            submitBackground: "rgba(88, 74, 192, 1)",
            submitBackgroundHover: h,
            submitBorder: h,
            submitOutlineFocus: "#29232f",
            submitForeground: d,
            submitForegroundHover: d,
            cancelBackground: "transparent",
            cancelBackgroundHover: "var(--background-hover)",
            cancelBorder: "var(--border)",
            cancelOutlineFocus: "var(--input-outline-focus)",
            cancelForeground: "var(--foreground)",
            cancelForegroundHover: "var(--foreground)",
            inputBackground: p,
            inputForeground: p,
            inputBorder: "var(--border)",
            inputOutlineFocus: h,
            formBorderRadius: "20px",
            formContentBorderRadius: "6px",
          },
          f = g,
          S = {
            ...g,
            background: "#29232f",
            backgroundHover: "#352f3b",
            foreground: "#ebe6ef",
            border: "1.5px solid rgba(235, 230, 239, 0.15)",
            success: "#2da98c",
            error: "#f55459",
          },
          b = "widget",
          y = "api";
        async function _(
          { feedback: { message: e, email: t, name: n, source: s, url: i } },
          { includeReplay: o = !0 } = {},
        ) {
          const a = (0, c.getClient)(),
            m = a && a.getTransport(),
            d = a && a.getDsn();
          if (!a || !m || !d) return;
          const p = {
            contexts: {
              feedback: {
                contact_email: t,
                name: n,
                message: e,
                url: i,
                source: s,
              },
            },
            type: "feedback",
          };
          return (0, c.withScope)(async (e) => {
            e.clearBreadcrumbs(),
              [y, b].includes(String(s)) && e.setLevel("info");
            const t = await (async function ({
              client: e,
              scope: t,
              event: n,
            }) {
              const s = {};
              e.emit && e.emit("preprocessEvent", n, s);
              const i = await (0, r.prepareEvent)(
                e.getOptions(),
                n,
                s,
                t,
                e,
                (0, l.getIsolationScope)(),
              );
              return null === i
                ? (e.recordDroppedEvent("event_processor", "feedback", n), null)
                : ((i.platform = i.platform || "javascript"), i);
            })({ scope: e, client: a, event: p });
            if (!t) return;
            a.emit &&
              a.emit("beforeSendFeedback", t, { includeReplay: Boolean(o) });
            const n = (0, u.createEventEnvelope)(
              t,
              d,
              a.getOptions()._metadata,
              a.getOptions().tunnel,
            );
            let i;
            try {
              i = await m.send(n);
            } catch (e) {
              const t = new Error("Unable to send Feedback");
              try {
                t.cause = e;
              } catch (e) {}
              throw t;
            }
            if (i) {
              if (
                "number" == typeof i.statusCode &&
                (i.statusCode < 200 || i.statusCode >= 300)
              )
                throw new Error("Unable to send Feedback");
              return i;
            }
          });
        }
        function v(
          {
            name: e,
            email: t,
            message: n,
            source: s = y,
            url: o = (0, i.getLocationHref)(),
          },
          a = {},
        ) {
          if (!n)
            throw new Error("Unable to submit feedback with empty message");
          return _(
            { feedback: { name: e, email: t, message: n, url: o, source: s } },
            a,
          );
        }
        const x = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__;
        function k(e, t) {
          return {
            ...e,
            ...t,
            themeDark: { ...e.themeDark, ...t.themeDark },
            themeLight: { ...e.themeLight, ...t.themeLight },
          };
        }
        function E(e) {
          return `\n  --background: ${e.background};\n  --background-hover: ${e.backgroundHover};\n  --foreground: ${e.foreground};\n  --error: ${e.error};\n  --success: ${e.success};\n  --border: ${e.border};\n  --border-radius: ${e.borderRadius};\n  --box-shadow: ${e.boxShadow};\n\n  --submit-background: ${e.submitBackground};\n  --submit-background-hover: ${e.submitBackgroundHover};\n  --submit-border: ${e.submitBorder};\n  --submit-outline-focus: ${e.submitOutlineFocus};\n  --submit-foreground: ${e.submitForeground};\n  --submit-foreground-hover: ${e.submitForegroundHover};\n\n  --cancel-background: ${e.cancelBackground};\n  --cancel-background-hover: ${e.cancelBackgroundHover};\n  --cancel-border: ${e.cancelBorder};\n  --cancel-outline-focus: ${e.cancelOutlineFocus};\n  --cancel-foreground: ${e.cancelForeground};\n  --cancel-foreground-hover: ${e.cancelForegroundHover};\n\n  --input-background: ${e.inputBackground};\n  --input-foreground: ${e.inputForeground};\n  --input-border: ${e.inputBorder};\n  --input-outline-focus: ${e.inputOutlineFocus};\n\n  --form-border-radius: ${e.formBorderRadius};\n  --form-content-border-radius: ${e.formContentBorderRadius};\n  `;
        }
        function T({ id: e, colorScheme: t, themeDark: n, themeLight: s }) {
          try {
            const i = m.document,
              o = i.createElement("div");
            o.id = e;
            const a = o.attachShadow({ mode: "open" });
            return (
              a.appendChild(
                (function (e, t, n) {
                  const s = e.createElement("style");
                  return (
                    (s.textContent = `\n:host {\n  --bottom: 1rem;\n  --right: 1rem;\n  --top: auto;\n  --left: auto;\n  --z-index: 100000;\n  --font-family: ${n.light.fontFamily};\n  --font-size: ${n.light.fontSize};\n\n  position: fixed;\n  left: var(--left);\n  right: var(--right);\n  bottom: var(--bottom);\n  top: var(--top);\n  z-index: var(--z-index);\n\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n\n  ${E("dark" === t ? n.dark : n.light)}\n}\n\n${"system" === t ? `\n@media (prefers-color-scheme: dark) {\n  :host {\n    ${E(n.dark)}\n  }\n}` : ""}\n}`),
                    s
                  );
                })(i, t, { dark: n, light: s }),
              ),
              a.appendChild(
                (function (e) {
                  const t = e.createElement("style");
                  return (
                    (t.textContent =
                      "\n.dialog {\n  line-height: 25px;\n  background-color: rgba(0, 0, 0, 0.05);\n  border: none;\n  position: fixed;\n  inset: 0;\n  z-index: 10000;\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out;\n}\n\n.dialog:not([open]) {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.dialog:not([open]) .dialog__content {\n  transform: translate(0, -16px) scale(0.98);\n}\n\n.dialog__content {\n  position: fixed;\n  left: var(--left);\n  right: var(--right);\n  bottom: var(--bottom);\n  top: var(--top);\n\n  border: var(--border);\n  border-radius: var(--form-border-radius);\n  background-color: var(--background);\n  color: var(--foreground);\n\n  width: 320px;\n  max-width: 100%;\n  max-height: calc(100% - 2rem);\n  display: flex;\n  flex-direction: column;\n  box-shadow: var(--box-shadow);\n  transition: transform 0.2s ease-in-out;\n  transform: translate(0, 0) scale(1);\n}\n\n.dialog__header {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  font-size: 20px;\n  font-weight: 600;\n  padding: 24px 24px 0 24px;\n  margin: 0;\n  margin-bottom: 16px;\n}\n\n.brand-link {\n  display: inline-flex;\n}\n\n.error {\n  color: var(--error);\n  margin-bottom: 16px;\n}\n\n.form {\n  display: grid;\n  overflow: auto;\n  flex-direction: column;\n  gap: 16px;\n  padding: 0 24px 24px;\n}\n\n.form__error-container {\n  color: var(--error);\n}\n\n.form__error-container--hidden {\n  display: none;\n}\n\n.form__label {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  margin: 0px;\n}\n\n.form__label__text {\n  display: grid;\n  gap: 4px;\n  align-items: center;\n  grid-auto-flow: column;\n  grid-auto-columns: max-content;\n}\n\n.form__label__text--required {\n  font-size: 0.85em;\n}\n\n.form__input {\n  font-family: inherit;\n  line-height: inherit;\n  background-color: var(--input-background);\n  box-sizing: border-box;\n  border: var(--input-border);\n  border-radius: var(--form-content-border-radius);\n  color: var(--input-foreground);\n  font-size: 14px;\n  font-weight: 500;\n  padding: 6px 12px;\n}\n\n.form__input:focus-visible {\n  outline: 1px auto var(--input-outline-focus);\n}\n\n.form__input--textarea {\n  font-family: inherit;\n  resize: vertical;\n}\n\n.btn-group {\n  display: grid;\n  gap: 8px;\n  margin-top: 8px;\n}\n\n.btn {\n  line-height: inherit;\n  border: var(--cancel-border);\n  border-radius: var(--form-content-border-radius);\n  cursor: pointer;\n  font-size: 14px;\n  font-weight: 600;\n  padding: 6px 16px;\n}\n.btn[disabled] {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.btn--primary {\n  background-color: var(--submit-background);\n  border-color: var(--submit-border);\n  color: var(--submit-foreground);\n}\n.btn--primary:hover {\n  background-color: var(--submit-background-hover);\n  color: var(--submit-foreground-hover);\n}\n.btn--primary:focus-visible {\n  outline: 1px auto var(--submit-outline-focus);\n}\n\n.btn--default {\n  background-color: var(--cancel-background);\n  color: var(--cancel-foreground);\n  font-weight: 500;\n}\n.btn--default:hover {\n  background-color: var(--cancel-background-hover);\n  color: var(--cancel-foreground-hover);\n}\n.btn--default:focus-visible {\n  outline: 1px auto var(--cancel-outline-focus);\n}\n\n.success-message {\n  background-color: var(--background);\n  border: var(--border);\n  border-radius: var(--border-radius);\n  box-shadow: var(--box-shadow);\n  font-weight: 600;\n  color: var(--success);\n  padding: 12px 24px;\n  line-height: 25px;\n  display: grid;\n  align-items: center;\n  grid-auto-flow: column;\n  gap: 6px;\n  cursor: default;\n}\n\n.success-icon path {\n  fill: var(--success);\n}\n"),
                    t
                  );
                })(i),
              ),
              { shadow: a, host: o }
            );
          } catch (e) {
            throw (
              (o.logger.warn(
                "[Feedback] Browser does not support shadow DOM API",
              ),
              new Error("Browser does not support shadow DOM API."))
            );
          }
        }
        async function C(e, t, n) {
          if (!e) return;
          e.hideError();
          try {
            return await v({ ...t, source: b }, n);
          } catch (t) {
            x && o.logger.error(t),
              e &&
                e.showError(
                  "There was a problem submitting feedback, please wait and try again.",
                );
          }
        }
        function w(e, t) {
          return (
            Object.entries(t).forEach(([t, n]) => {
              e.setAttributeNS(null, t, n);
            }),
            e
          );
        }
        const I = 20,
          A = "http://www.w3.org/2000/svg";
        function P(e, t, ...n) {
          const s = m.document.createElement(e);
          t &&
            Object.entries(t).forEach(([e, t]) => {
              "className" === e && "string" == typeof t
                ? s.setAttribute("class", t)
                : "boolean" == typeof t && t
                  ? s.setAttribute(e, "")
                  : "string" == typeof t
                    ? s.setAttribute(e, t)
                    : e.startsWith("on") &&
                      "function" == typeof t &&
                      s.addEventListener(e.substring(2).toLowerCase(), t);
            });
          for (const e of n) R(s, e);
          return s;
        }
        function R(e, t) {
          const n = m.document;
          if (null != t)
            if (Array.isArray(t)) for (const n of t) R(e, n);
            else
              !1 === t ||
                ("string" == typeof t
                  ? e.appendChild(n.createTextNode(t))
                  : t instanceof Node
                    ? e.appendChild(t)
                    : e.appendChild(n.createTextNode(String(t))));
        }
        function D({ buttonLabel: e, onClick: t }) {
          const n = P(
            "button",
            {
              type: "button",
              className: "widget__actor",
              "aria-label": e,
              "aria-hidden": "false",
            },
            (function () {
              const e = (e) => m.document.createElementNS(A, e),
                t = w(e("svg"), {
                  class: "feedback-icon",
                  width: `${I}`,
                  height: `${I}`,
                  viewBox: `0 0 ${I} ${I}`,
                  fill: "none",
                }),
                n = w(e("g"), { clipPath: "url(#clip0_57_80)" }),
                s = w(e("path"), {
                  "fill-rule": "evenodd",
                  "clip-rule": "evenodd",
                  d: "M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z",
                });
              t.appendChild(n).appendChild(s);
              const i = e("defs"),
                o = w(e("clipPath"), { id: "clip0_57_80" }),
                a = w(e("rect"), {
                  width: `${I}`,
                  height: `${I}`,
                  fill: "white",
                });
              return (
                o.appendChild(a),
                i.appendChild(o),
                t.appendChild(i).appendChild(o).appendChild(a),
                {
                  get el() {
                    return t;
                  },
                }
              );
            })().el,
            e ? P("span", { className: "widget__actor__text" }, e) : null,
          );
          return (
            n.addEventListener("click", function (e) {
              t && t(e);
            }),
            {
              get el() {
                return n;
              },
              show: () => {
                n.classList.remove("widget__actor--hidden"),
                  n.setAttribute("aria-hidden", "false");
              },
              hide: () => {
                n.classList.add("widget__actor--hidden"),
                  n.setAttribute("aria-hidden", "true");
              },
            }
          );
        }
        function M(e, t) {
          const n = e.get(t);
          return "string" == typeof n ? n.trim() : "";
        }
        function O({
          nameLabel: e,
          namePlaceholder: t,
          emailLabel: n,
          emailPlaceholder: s,
          messageLabel: i,
          messagePlaceholder: o,
          cancelButtonLabel: a,
          submitButtonLabel: r,
          showName: l,
          showEmail: c,
          isNameRequired: u,
          isEmailRequired: m,
          defaultName: d,
          defaultEmail: p,
          onCancel: h,
          onSubmit: g,
        }) {
          const { el: f } = (function ({ label: e }) {
            return {
              el: P(
                "button",
                {
                  type: "submit",
                  className: "btn btn--primary",
                  "aria-label": e,
                },
                e,
              ),
            };
          })({ label: r });
          const S = P("div", {
            className: "form__error-container form__error-container--hidden",
            "aria-hidden": "true",
          });
          const b = P("input", {
              id: "name",
              type: l ? "text" : "hidden",
              "aria-hidden": l ? "false" : "true",
              name: "name",
              required: u,
              className: "form__input",
              placeholder: t,
              value: d,
            }),
            y = P("input", {
              id: "email",
              type: c ? "text" : "hidden",
              "aria-hidden": c ? "false" : "true",
              name: "email",
              required: m,
              className: "form__input",
              placeholder: s,
              value: p,
            }),
            _ = P("textarea", {
              id: "message",
              autoFocus: "true",
              rows: "5",
              name: "message",
              required: !0,
              className: "form__input form__input--textarea",
              placeholder: o,
            }),
            v = P(
              "button",
              {
                type: "button",
                className: "btn btn--default",
                "aria-label": a,
                onClick: (e) => {
                  h && h(e);
                },
              },
              a,
            ),
            x = P(
              "form",
              {
                className: "form",
                onSubmit: function (e) {
                  if ((e.preventDefault(), e.target instanceof HTMLFormElement))
                    try {
                      if (g) {
                        const t = new FormData(e.target),
                          n = {
                            name: M(t, "name"),
                            email: M(t, "email"),
                            message: M(t, "message"),
                          };
                        g(n);
                      }
                    } catch (e) {}
                },
              },
              [
                S,
                l &&
                  P("label", { htmlFor: "name", className: "form__label" }, [
                    P(
                      "span",
                      { className: "form__label__text" },
                      e,
                      u &&
                        P(
                          "span",
                          { className: "form__label__text--required" },
                          " (required)",
                        ),
                    ),
                    b,
                  ]),
                !l && b,
                c &&
                  P("label", { htmlFor: "email", className: "form__label" }, [
                    P(
                      "span",
                      { className: "form__label__text" },
                      n,
                      m &&
                        P(
                          "span",
                          { className: "form__label__text--required" },
                          " (required)",
                        ),
                    ),
                    y,
                  ]),
                !c && y,
                P("label", { htmlFor: "message", className: "form__label" }, [
                  P(
                    "span",
                    { className: "form__label__text" },
                    i,
                    P(
                      "span",
                      { className: "form__label__text--required" },
                      " (required)",
                    ),
                  ),
                  _,
                ]),
                P("div", { className: "btn-group" }, [f, v]),
              ],
            );
          return {
            get el() {
              return x;
            },
            showError: function (e) {
              (S.textContent = e),
                S.classList.remove("form__error-container--hidden"),
                S.setAttribute("aria-hidden", "false");
            },
            hideError: function () {
              (S.textContent = ""),
                S.classList.add("form__error-container--hidden"),
                S.setAttribute("aria-hidden", "true");
            },
          };
        }
        const N = "http://www.w3.org/2000/svg";
        function L({
          formTitle: e,
          showBranding: t,
          showName: n,
          showEmail: s,
          isNameRequired: i,
          isEmailRequired: o,
          colorScheme: a,
          defaultName: r,
          defaultEmail: l,
          onClosed: c,
          onCancel: u,
          onSubmit: d,
          ...p
        }) {
          let h = null;
          function g() {
            h && (h.open = !1);
          }
          const {
            el: f,
            showError: S,
            hideError: b,
          } = O({
            showEmail: s,
            showName: n,
            isEmailRequired: o,
            isNameRequired: i,
            defaultName: r,
            defaultEmail: l,
            onSubmit: d,
            onCancel: u,
            ...p,
          });
          return (
            (h = P(
              "dialog",
              {
                className: "dialog",
                open: !0,
                onClick: function () {
                  g(), c && c();
                },
              },
              P(
                "div",
                {
                  className: "dialog__content",
                  onClick: (e) => {
                    e.stopPropagation();
                  },
                },
                P(
                  "h2",
                  { className: "dialog__header" },
                  e,
                  t &&
                    P(
                      "a",
                      {
                        className: "brand-link",
                        target: "_blank",
                        href: "https://sentry.io/welcome/",
                        title: "Powered by Sentry",
                        rel: "noopener noreferrer",
                      },
                      (function ({ colorScheme: e }) {
                        const t = (e) => m.document.createElementNS(N, e),
                          n = w(t("svg"), {
                            class: "sentry-logo",
                            width: "32",
                            height: "30",
                            viewBox: "0 0 72 66",
                            fill: "none",
                          }),
                          s = w(t("path"), {
                            transform: "translate(11, 11)",
                            d: "M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z",
                          });
                        n.append(s);
                        const i = t("defs"),
                          o = t("style");
                        return (
                          (o.textContent = `\n    path {\n      fill: ${"dark" === e ? "#fff" : "#362d59"};\n    }`),
                          "system" === e &&
                            (o.textContent +=
                              "\n    @media (prefers-color-scheme: dark) {\n      path: {\n        fill: '#fff';\n      }\n    }\n    "),
                          i.append(o),
                          n.append(i),
                          {
                            get el() {
                              return n;
                            },
                          }
                        );
                      })({ colorScheme: a }).el,
                    ),
                ),
                f,
              ),
            )),
            {
              get el() {
                return h;
              },
              showError: S,
              hideError: b,
              open: function () {
                h && (h.open = !0);
              },
              close: g,
              checkIsOpen: function () {
                return (h && !0 === h.open) || !1;
              },
            }
          );
        }
        const B = 16,
          U = 17,
          F = "http://www.w3.org/2000/svg";
        function H({ message: e, onRemove: t }) {
          function n() {
            s && (s.remove(), t && t());
          }
          const s = P(
            "div",
            { className: "success-message", onClick: n },
            (function () {
              const e = (e) => m.document.createElementNS(F, e),
                t = w(e("svg"), {
                  class: "success-icon",
                  width: `${B}`,
                  height: `${U}`,
                  viewBox: `0 0 ${B} ${U}`,
                  fill: "none",
                }),
                n = w(e("g"), { clipPath: "url(#clip0_57_156)" }),
                s = w(e("path"), {
                  "fill-rule": "evenodd",
                  "clip-rule": "evenodd",
                  d: "M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z",
                }),
                i = w(e("path"), {
                  d: "M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z",
                });
              t.appendChild(n).append(i, s);
              const o = e("defs"),
                a = w(e("clipPath"), { id: "clip0_57_156" }),
                r = w(e("rect"), {
                  width: `${B}`,
                  height: `${B}`,
                  fill: "white",
                  transform: "translate(0 0.5)",
                });
              return (
                a.appendChild(r),
                o.appendChild(a),
                t.appendChild(o).appendChild(a).appendChild(r),
                {
                  get el() {
                    return t;
                  },
                }
              );
            })().el,
            e,
          );
          return { el: s, remove: n };
        }
        function j({
          shadow: e,
          options: { shouldCreateActor: t = !0, ...n },
          attachTo: s,
        }) {
          let i,
            a,
            r = !1;
          async function l(t) {
            if (!a) return;
            const s = [];
            if (
              (n.isNameRequired && !t.name && s.push(n.nameLabel),
              n.isEmailRequired && !t.email && s.push(n.emailLabel),
              t.message || s.push(n.messageLabel),
              s.length > 0)
            )
              return void a.showError(
                `Please enter in the following required fields: ${s.join(", ")}`,
              );
            (await C(a, t))
              ? (h(),
                (function () {
                  if (e)
                    try {
                      const t = H({
                        message: n.successMessageText,
                        onRemove: () => {
                          s && clearTimeout(s), u();
                        },
                      });
                      if (!t.el)
                        throw new Error("Unable to show success message");
                      e.appendChild(t.el);
                      const s = setTimeout(() => {
                        t && t.remove();
                      }, 5e3);
                    } catch (e) {
                      o.logger.error(e);
                    }
                })(),
                n.onSubmitSuccess && n.onSubmitSuccess())
              : n.onSubmitError && n.onSubmitError();
          }
          function u() {
            i && i.show();
          }
          function m() {
            i && i.hide();
          }
          function d() {
            try {
              if (a)
                return (
                  a.open(), (r = !0), void (n.onFormOpen && n.onFormOpen())
                );
              const t = n.useSentryUser,
                s = (0, c.getCurrentScope)(),
                i = s && s.getUser();
              if (
                ((a = L({
                  colorScheme: n.colorScheme,
                  showBranding: n.showBranding,
                  showName: n.showName || n.isNameRequired,
                  showEmail: n.showEmail || n.isEmailRequired,
                  isNameRequired: n.isNameRequired,
                  isEmailRequired: n.isEmailRequired,
                  formTitle: n.formTitle,
                  cancelButtonLabel: n.cancelButtonLabel,
                  submitButtonLabel: n.submitButtonLabel,
                  emailLabel: n.emailLabel,
                  emailPlaceholder: n.emailPlaceholder,
                  messageLabel: n.messageLabel,
                  messagePlaceholder: n.messagePlaceholder,
                  nameLabel: n.nameLabel,
                  namePlaceholder: n.namePlaceholder,
                  defaultName: (t && i && i[t.name]) || "",
                  defaultEmail: (t && i && i[t.email]) || "",
                  onClosed: () => {
                    u(), (r = !1), n.onFormClose && n.onFormClose();
                  },
                  onCancel: () => {
                    p(), u();
                  },
                  onSubmit: l,
                })),
                !a.el)
              )
                throw new Error("Unable to open Feedback dialog");
              e.appendChild(a.el), m(), n.onFormOpen && n.onFormOpen();
            } catch (e) {
              o.logger.error(e);
            }
          }
          function p() {
            a && (a.close(), (r = !1), n.onFormClose && n.onFormClose());
          }
          function h() {
            if (a) {
              p();
              const e = a.el;
              e && e.remove(), (a = void 0);
            }
          }
          function g() {
            r || d(), m();
          }
          return (
            s
              ? s.addEventListener("click", g)
              : t &&
                ((i = D({ buttonLabel: n.buttonLabel, onClick: g })),
                i.el && e.appendChild(i.el)),
            {
              get actor() {
                return i;
              },
              get dialog() {
                return a;
              },
              showActor: u,
              hideActor: m,
              removeActor: function () {
                i && i.el && i.el.remove();
              },
              openDialog: d,
              closeDialog: p,
              removeDialog: h,
            }
          );
        }
        const G = m.document,
          W = (e) => new q(e);
        class q {
          static __initStatic() {
            this.id = "Feedback";
          }
          constructor({
            id: e = "sentry-feedback",
            showBranding: t = !0,
            autoInject: n = !0,
            showEmail: s = !0,
            showName: i = !0,
            useSentryUser: o = { email: "email", name: "username" },
            isEmailRequired: a = !1,
            isNameRequired: r = !1,
            themeDark: l,
            themeLight: c,
            colorScheme: u = "system",
            buttonLabel: m = "Report a Bug",
            cancelButtonLabel: d = "Cancel",
            submitButtonLabel: p = "Send Bug Report",
            formTitle: h = "Report a Bug",
            emailPlaceholder: g = "your.email@example.org",
            emailLabel: b = "Email",
            messagePlaceholder: y = "What's the bug? What did you expect?",
            messageLabel: _ = "Description",
            namePlaceholder: v = "Your Name",
            nameLabel: x = "Name",
            successMessageText: k = "Thank you for your report!",
            onFormClose: E,
            onFormOpen: T,
            onSubmitError: C,
            onSubmitSuccess: w,
          } = {}) {
            (this.name = q.id),
              (this._host = null),
              (this._shadow = null),
              (this._widget = null),
              (this._widgets = new Set()),
              (this._hasInsertedActorStyles = !1),
              (this.options = {
                id: e,
                showBranding: t,
                autoInject: n,
                isEmailRequired: a,
                isNameRequired: r,
                showEmail: s,
                showName: i,
                useSentryUser: o,
                colorScheme: u,
                themeDark: { ...S, ...l },
                themeLight: { ...f, ...c },
                buttonLabel: m,
                cancelButtonLabel: d,
                submitButtonLabel: p,
                formTitle: h,
                emailLabel: b,
                emailPlaceholder: g,
                messageLabel: _,
                messagePlaceholder: y,
                nameLabel: x,
                namePlaceholder: v,
                successMessageText: k,
                onFormClose: E,
                onFormOpen: T,
                onSubmitError: C,
                onSubmitSuccess: w,
              });
          }
          setupOnce() {
            if ((0, a.isBrowser)())
              try {
                this._cleanupWidgetIfExists();
                const { autoInject: e } = this.options;
                if (!e) return;
                this._createWidget(this.options);
              } catch (e) {
                x && o.logger.error(e);
              }
          }
          openDialog() {
            this._widget ||
              this._createWidget({ ...this.options, shouldCreateActor: !1 }),
              this._widget && this._widget.openDialog();
          }
          closeDialog() {
            this._widget && this._widget.closeDialog();
          }
          attachTo(e, t) {
            try {
              const n = k(this.options, t || {});
              return this._ensureShadowHost(n, ({ shadow: t }) => {
                const s =
                  "string" == typeof e
                    ? G.querySelector(e)
                    : "function" == typeof e.addEventListener
                      ? e
                      : null;
                if (!s)
                  return (
                    x &&
                      o.logger.error(
                        "[Feedback] Unable to attach to target element",
                      ),
                    null
                  );
                const i = j({ shadow: t, options: n, attachTo: s });
                return (
                  this._widgets.add(i), this._widget || (this._widget = i), i
                );
              });
            } catch (e) {
              return x && o.logger.error(e), null;
            }
          }
          createWidget(e) {
            try {
              return this._createWidget(k(this.options, e || {}));
            } catch (e) {
              return x && o.logger.error(e), null;
            }
          }
          removeWidget(e) {
            if (!e) return !1;
            try {
              if (this._widgets.has(e))
                return (
                  e.removeActor(),
                  e.removeDialog(),
                  this._widgets.delete(e),
                  this._widget === e && (this._widget = null),
                  !0
                );
            } catch (e) {
              x && o.logger.error(e);
            }
            return !1;
          }
          getWidget() {
            return this._widget;
          }
          remove() {
            this._host && this._host.remove(), this._initialize();
          }
          _initialize() {
            (this._host = null),
              (this._shadow = null),
              (this._widget = null),
              (this._widgets = new Set()),
              (this._hasInsertedActorStyles = !1);
          }
          _cleanupWidgetIfExists() {
            this._host && this.remove();
            const e = G.querySelector(`#${this.options.id}`);
            e && e.remove();
          }
          _createWidget(e) {
            return this._ensureShadowHost(e, ({ shadow: t }) => {
              const n = j({ shadow: t, options: e });
              return (
                !this._hasInsertedActorStyles &&
                  n.actor &&
                  (t.appendChild(
                    (function (e) {
                      const t = e.createElement("style");
                      return (
                        (t.textContent =
                          "\n.widget__actor {\n  line-height: 25px;\n\n  display: flex;\n  align-items: center;\n  gap: 8px;\n\n  border-radius: var(--border-radius);\n  cursor: pointer;\n  font-size: 14px;\n  font-weight: 600;\n  padding: 12px 16px;\n  text-decoration: none;\n  z-index: 9000;\n\n  color: var(--foreground);\n  background-color: var(--background);\n  border: var(--border);\n  box-shadow: var(--box-shadow);\n  opacity: 1;\n  transition: opacity 0.1s ease-in-out;\n}\n\n.widget__actor:hover {\n  background-color: var(--background-hover);\n}\n\n.widget__actor svg {\n  width: 16px;\n  height: 16px;\n}\n\n.widget__actor--hidden {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n\n.widget__actor__text {\n}\n\n.feedback-icon path {\n  fill: var(--foreground);\n}\n"),
                        t
                      );
                    })(G),
                  ),
                  (this._hasInsertedActorStyles = !0)),
                this._widgets.add(n),
                this._widget || (this._widget = n),
                n
              );
            });
          }
          _ensureShadowHost(e, t) {
            let n = !1;
            if (!this._shadow || !this._host) {
              const { id: t, colorScheme: s, themeLight: i, themeDark: o } = e,
                { shadow: a, host: r } = T({
                  id: t,
                  colorScheme: s,
                  themeLight: i,
                  themeDark: o,
                });
              (this._shadow = a), (this._host = r), (n = !0);
            }
            this._host.dataset.sentryFeedbackColorscheme = e.colorScheme;
            const s = t({ shadow: this._shadow, host: this._host });
            return n && G.body.appendChild(this._host), s;
          }
        }
        q.__initStatic();
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            BROWSER_TRACING_INTEGRATION_ID: () => f,
            BrowserTracing: () => b,
            getMetaContent: () => y,
          });
        var s = n(57),
          i = n(48),
          o = n(62),
          a = n(40),
          r = n(7),
          l = n(21),
          c = n(10),
          u = n(107),
          m = n(131),
          d = n(129),
          p = n(127),
          h = n(126),
          g = n(111);
        const f = "BrowserTracing",
          S = {
            ...s.TRACING_DEFAULTS,
            markBackgroundTransactions: !0,
            routingInstrumentation: h.instrumentRoutingWithDefaults,
            startTransactionOnLocationChange: !0,
            startTransactionOnPageLoad: !0,
            enableLongTask: !0,
            _experiments: {},
            ...p.defaultRequestInstrumentationOptions,
          };
        class b {
          constructor(e) {
            (this.name = f),
              (this._hasSetTracePropagationTargets = !1),
              (0, i.addTracingExtensions)(),
              u.DEBUG_BUILD &&
                (this._hasSetTracePropagationTargets = !(
                  !e ||
                  (!e.tracePropagationTargets && !e.tracingOrigins)
                )),
              (this.options = { ...S, ...e }),
              void 0 !== this.options._experiments.enableLongTask &&
                (this.options.enableLongTask =
                  this.options._experiments.enableLongTask),
              e &&
                !e.tracePropagationTargets &&
                e.tracingOrigins &&
                (this.options.tracePropagationTargets = e.tracingOrigins),
              (this._collectWebVitals = (0, d.startTrackingWebVitals)()),
              this.options.enableLongTask && (0, d.startTrackingLongTasks)(),
              this.options._experiments.enableInteractions &&
                (0, d.startTrackingInteractions)();
          }
          setupOnce(e, t) {
            this._getCurrentHub = t;
            const n = t().getClient(),
              s = n && n.getOptions(),
              {
                routingInstrumentation: i,
                startTransactionOnLocationChange: o,
                startTransactionOnPageLoad: a,
                markBackgroundTransactions: l,
                traceFetch: c,
                traceXHR: d,
                shouldCreateSpanForRequest: h,
                enableHTTPTimings: g,
                _experiments: f,
              } = this.options,
              S = s && s.tracePropagationTargets,
              b = S || this.options.tracePropagationTargets;
            u.DEBUG_BUILD &&
              this._hasSetTracePropagationTargets &&
              S &&
              r.logger.warn(
                "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.",
              ),
              i(
                (e) => {
                  const n = this._createRouteTransaction(e);
                  return (
                    this.options._experiments.onStartRouteTransaction &&
                      this.options._experiments.onStartRouteTransaction(
                        n,
                        e,
                        t,
                      ),
                    n
                  );
                },
                a,
                o,
              ),
              l && (0, m.registerBackgroundTabDetection)(),
              f.enableInteractions && this._registerInteractionListener(),
              (0, p.instrumentOutgoingRequests)({
                traceFetch: c,
                traceXHR: d,
                tracePropagationTargets: b,
                shouldCreateSpanForRequest: h,
                enableHTTPTimings: g,
              });
          }
          _createRouteTransaction(e) {
            if (!this._getCurrentHub)
              return void (
                u.DEBUG_BUILD &&
                r.logger.warn(
                  `[Tracing] Did not create ${e.op} transaction because _getCurrentHub is invalid.`,
                )
              );
            const t = this._getCurrentHub(),
              {
                beforeNavigate: n,
                idleTimeout: s,
                finalTimeout: o,
                heartbeatInterval: c,
              } = this.options,
              m = "pageload" === e.op;
            let p;
            if (m) {
              const t = m ? y("sentry-trace") : "",
                n = m ? y("baggage") : void 0,
                {
                  traceId: s,
                  dsc: i,
                  parentSpanId: o,
                  sampled: a,
                } = (0, l.propagationContextFromHeaders)(t, n);
              p = {
                traceId: s,
                parentSpanId: o,
                parentSampled: a,
                ...e,
                metadata: { ...e.metadata, dynamicSamplingContext: i },
                trimEnd: !0,
              };
            } else p = { trimEnd: !0, ...e };
            const h = "function" == typeof n ? n(p) : p,
              f = void 0 === h ? { ...p, sampled: !1 } : h;
            (f.metadata =
              f.name !== p.name
                ? { ...f.metadata, source: "custom" }
                : f.metadata),
              (this._latestRouteName = f.name),
              (this._latestRouteSource = (function (e) {
                const t =
                    e.attributes &&
                    e.attributes[a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
                  n = e.data && e.data[a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
                  s = e.metadata && e.metadata.source;
                return t || n || s;
              })(f)),
              !1 === f.sampled &&
                u.DEBUG_BUILD &&
                r.logger.log(
                  `[Tracing] Will not send ${f.op} transaction because of beforeNavigate.`,
                ),
              u.DEBUG_BUILD &&
                r.logger.log(`[Tracing] Starting ${f.op} transaction on scope`);
            const { location: S } = g.WINDOW,
              b = (0, i.startIdleTransaction)(
                t,
                f,
                s,
                o,
                !0,
                { location: S },
                c,
                m,
              );
            return (
              m &&
                (g.WINDOW.document.addEventListener("readystatechange", () => {
                  ["interactive", "complete"].includes(
                    g.WINDOW.document.readyState,
                  ) && b.sendAutoFinishSignal();
                }),
                ["interactive", "complete"].includes(
                  g.WINDOW.document.readyState,
                ) && b.sendAutoFinishSignal()),
              b.registerBeforeFinishCallback((e) => {
                this._collectWebVitals(), (0, d.addPerformanceEntries)(e);
              }),
              b
            );
          }
          _registerInteractionListener() {
            let e;
            const t = () => {
              const {
                  idleTimeout: t,
                  finalTimeout: n,
                  heartbeatInterval: s,
                } = this.options,
                l = "ui.action.click",
                c = (0, o.getActiveTransaction)();
              if (c && c.op && ["navigation", "pageload"].includes(c.op))
                return void (
                  u.DEBUG_BUILD &&
                  r.logger.warn(
                    `[Tracing] Did not create ${l} transaction because a pageload or navigation transaction is in progress.`,
                  )
                );
              if (
                (e &&
                  (e.setFinishReason("interactionInterrupted"),
                  e.end(),
                  (e = void 0)),
                !this._getCurrentHub)
              )
                return void (
                  u.DEBUG_BUILD &&
                  r.logger.warn(
                    `[Tracing] Did not create ${l} transaction because _getCurrentHub is invalid.`,
                  )
                );
              if (!this._latestRouteName)
                return void (
                  u.DEBUG_BUILD &&
                  r.logger.warn(
                    `[Tracing] Did not create ${l} transaction because _latestRouteName is missing.`,
                  )
                );
              const m = this._getCurrentHub(),
                { location: d } = g.WINDOW,
                p = {
                  name: this._latestRouteName,
                  op: l,
                  trimEnd: !0,
                  data: {
                    [a.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]:
                      this._latestRouteSource || "url",
                  },
                };
              e = (0, i.startIdleTransaction)(
                m,
                p,
                t,
                n,
                !0,
                { location: d },
                s,
              );
            };
            ["click"].forEach((e) => {
              addEventListener(e, t, { once: !1, capture: !0 });
            });
          }
        }
        function y(e) {
          const t = (0, c.getDomElement)(`meta[name=${e}]`);
          return t ? t.getAttribute("content") : void 0;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { instrumentRoutingWithDefaults: () => l });
        var s = n(7),
          i = n(17),
          o = n(95),
          a = n(107),
          r = n(111);
        function l(e, t = !0, n = !0) {
          if (!r.WINDOW || !r.WINDOW.location)
            return void (
              a.DEBUG_BUILD &&
              s.logger.warn(
                "Could not initialize routing instrumentation due to invalid location",
              )
            );
          let l,
            c = r.WINDOW.location.href;
          t &&
            (l = e({
              name: r.WINDOW.location.pathname,
              startTimestamp: i.browserPerformanceTimeOrigin
                ? i.browserPerformanceTimeOrigin / 1e3
                : void 0,
              op: "pageload",
              origin: "auto.pageload.browser",
              metadata: { source: "url" },
            })),
            n &&
              (0, o.addHistoryInstrumentationHandler)(({ to: t, from: n }) => {
                void 0 === n && c && -1 !== c.indexOf(t)
                  ? (c = void 0)
                  : n !== t &&
                    ((c = void 0),
                    l &&
                      (a.DEBUG_BUILD &&
                        s.logger.log(
                          `[Tracing] Finishing current transaction with op: ${l.op}`,
                        ),
                      l.end()),
                    (l = e({
                      name: r.WINDOW.location.pathname,
                      op: "navigation",
                      origin: "auto.navigation.browser",
                      metadata: { source: "url" },
                    })));
              });
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            DEFAULT_TRACE_PROPAGATION_TARGETS: () => y,
            defaultRequestInstrumentationOptions: () => _,
            extractNetworkProtocol: () => k,
            instrumentOutgoingRequests: () => v,
            shouldAttachHeaders: () => T,
            xhrCallback: () => C,
          });
        var s = n(20),
          i = n(55),
          o = n(51),
          a = n(12),
          r = n(13),
          l = n(53),
          c = n(40),
          u = n(24),
          m = n(94),
          d = n(93),
          p = n(17),
          h = n(11),
          g = n(21),
          f = n(22),
          S = n(128),
          b = n(106);
        const y = ["localhost", /^\/(?!\/)/],
          _ = {
            traceFetch: !0,
            traceXHR: !0,
            enableHTTPTimings: !0,
            tracingOrigins: y,
            tracePropagationTargets: y,
          };
        function v(e) {
          const {
              traceFetch: t,
              traceXHR: n,
              tracePropagationTargets: s,
              tracingOrigins: i,
              shouldCreateSpanForRequest: o,
              enableHTTPTimings: a,
            } = { traceFetch: _.traceFetch, traceXHR: _.traceXHR, ...e },
            r = "function" == typeof o ? o : (e) => !0,
            l = (e) => T(e, s || i),
            c = {};
          t &&
            (0, m.addFetchInstrumentationHandler)((e) => {
              const t = (0, S.instrumentFetchRequest)(e, r, l, c);
              a && t && x(t);
            }),
            n &&
              (0, d.addXhrInstrumentationHandler)((e) => {
                const t = C(e, r, l, c);
                a && t && x(t);
              });
        }
        function x(e) {
          const { url: t } = (0, s.spanToJSON)(e).data || {};
          if (!t || "string" != typeof t) return;
          const n = (0, b.addPerformanceInstrumentationHandler)(
            "resource",
            ({ entries: s }) => {
              s.forEach((s) => {
                if (
                  (function (e) {
                    return (
                      "resource" === e.entryType &&
                      "initiatorType" in e &&
                      "string" == typeof e.nextHopProtocol &&
                      ("fetch" === e.initiatorType ||
                        "xmlhttprequest" === e.initiatorType)
                    );
                  })(s) &&
                  s.name.endsWith(t)
                ) {
                  (function (e) {
                    const { name: t, version: n } = k(e.nextHopProtocol),
                      s = [];
                    if (
                      (s.push(
                        ["network.protocol.version", n],
                        ["network.protocol.name", t],
                      ),
                      !p.browserPerformanceTimeOrigin)
                    )
                      return s;
                    return [
                      ...s,
                      ["http.request.redirect_start", E(e.redirectStart)],
                      ["http.request.fetch_start", E(e.fetchStart)],
                      [
                        "http.request.domain_lookup_start",
                        E(e.domainLookupStart),
                      ],
                      ["http.request.domain_lookup_end", E(e.domainLookupEnd)],
                      ["http.request.connect_start", E(e.connectStart)],
                      [
                        "http.request.secure_connection_start",
                        E(e.secureConnectionStart),
                      ],
                      ["http.request.connection_end", E(e.connectEnd)],
                      ["http.request.request_start", E(e.requestStart)],
                      ["http.request.response_start", E(e.responseStart)],
                      ["http.request.response_end", E(e.responseEnd)],
                    ];
                  })(s).forEach((t) => e.setAttribute(...t)),
                    setTimeout(n);
                }
              });
            },
          );
        }
        function k(e) {
          let t = "unknown",
            n = "unknown",
            s = "";
          for (const i of e) {
            if ("/" === i) {
              [t, n] = e.split("/");
              break;
            }
            if (!isNaN(Number(i))) {
              (t = "h" === s ? "http" : s), (n = e.split(s)[1]);
              break;
            }
            s += i;
          }
          return s === e && (t = s), { name: t, version: n };
        }
        function E(e = 0) {
          return (
            ((p.browserPerformanceTimeOrigin || performance.timeOrigin) + e) /
            1e3
          );
        }
        function T(e, t) {
          return (0, h.stringMatchesSomePattern)(e, t || y);
        }
        function C(e, t, n, m) {
          const p = e.xhr,
            h = p && p[d.SENTRY_XHR_DATA_KEY];
          if (
            !(0, i.hasTracingEnabled)() ||
            !p ||
            p.__sentry_own_request__ ||
            !h
          )
            return;
          const S = t(h.url);
          if (e.endTimestamp && S) {
            const e = p.__sentry_xhr_span_id__;
            if (!e) return;
            const t = m[e];
            return void (
              t &&
              void 0 !== h.status_code &&
              ((0, o.setHttpStatus)(t, h.status_code), t.end(), delete m[e])
            );
          }
          const b = (0, a.getCurrentScope)(),
            y = (0, r.getIsolationScope)(),
            _ = S
              ? (0, l.startInactiveSpan)({
                  name: `${h.method} ${h.url}`,
                  onlyIfParent: !0,
                  attributes: {
                    type: "xhr",
                    "http.method": h.method,
                    url: h.url,
                    [c.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: "auto.http.browser",
                  },
                  op: "http.client",
                })
              : void 0;
          _ &&
            ((p.__sentry_xhr_span_id__ = _.spanContext().spanId),
            (m[p.__sentry_xhr_span_id__] = _));
          const v = (0, a.getClient)();
          if (p.setRequestHeader && n(h.url) && v) {
            const {
              traceId: e,
              spanId: t,
              sampled: n,
              dsc: i,
            } = { ...y.getPropagationContext(), ...b.getPropagationContext() };
            !(function (e, t, n) {
              try {
                e.setRequestHeader("sentry-trace", t),
                  n && e.setRequestHeader(f.BAGGAGE_HEADER_NAME, n);
              } catch (e) {}
            })(
              p,
              _
                ? (0, s.spanToTraceHeader)(_)
                : (0, g.generateSentryTraceHeader)(e, t, n),
              (0, f.dynamicSamplingContextToSentryBaggageHeader)(
                i ||
                  (_
                    ? (0, u.getDynamicSamplingContextFromSpan)(_)
                    : (0, u.getDynamicSamplingContextFromClient)(e, v, b)),
              ),
            );
          }
          return _;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            addTracingHeadersToFetchRequest: () => g,
            instrumentFetchRequest: () => h,
          });
        var s = n(55),
          i = n(51),
          o = n(12),
          a = n(53),
          r = n(40),
          l = n(13),
          c = n(20),
          u = n(24),
          m = n(21),
          d = n(22),
          p = n(9);
        function h(e, t, n, l, c = "auto.http.browser") {
          if (!(0, s.hasTracingEnabled)() || !e.fetchData) return;
          const u = t(e.fetchData.url);
          if (e.endTimestamp && u) {
            const t = e.fetchData.__span;
            if (!t) return;
            const n = l[t];
            if (n) {
              if (e.response) {
                (0, i.setHttpStatus)(n, e.response.status);
                const t =
                  e.response &&
                  e.response.headers &&
                  e.response.headers.get("content-length");
                if (t) {
                  const e = parseInt(t);
                  e > 0 && n.setAttribute("http.response_content_length", e);
                }
              } else e.error && n.setStatus("internal_error");
              n.end(), delete l[t];
            }
            return;
          }
          const m = (0, o.getCurrentScope)(),
            d = (0, o.getClient)(),
            { method: p, url: h } = e.fetchData,
            f = u
              ? (0, a.startInactiveSpan)({
                  name: `${p} ${h}`,
                  onlyIfParent: !0,
                  attributes: {
                    url: h,
                    type: "fetch",
                    "http.method": p,
                    [r.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: c,
                  },
                  op: "http.client",
                })
              : void 0;
          if (
            (f &&
              ((e.fetchData.__span = f.spanContext().spanId),
              (l[f.spanContext().spanId] = f)),
            n(e.fetchData.url) && d)
          ) {
            const t = e.args[0];
            e.args[1] = e.args[1] || {};
            const n = e.args[1];
            n.headers = g(t, d, m, n, f);
          }
          return f;
        }
        function g(e, t, n, s, i) {
          const o = i || n.getSpan(),
            a = (0, l.getIsolationScope)(),
            {
              traceId: r,
              spanId: h,
              sampled: g,
              dsc: f,
            } = { ...a.getPropagationContext(), ...n.getPropagationContext() },
            S = o
              ? (0, c.spanToTraceHeader)(o)
              : (0, m.generateSentryTraceHeader)(r, h, g),
            b = (0, d.dynamicSamplingContextToSentryBaggageHeader)(
              f ||
                (o
                  ? (0, u.getDynamicSamplingContextFromSpan)(o)
                  : (0, u.getDynamicSamplingContextFromClient)(r, t, n)),
            ),
            y =
              s.headers ||
              ("undefined" != typeof Request && (0, p.isInstanceOf)(e, Request)
                ? e.headers
                : void 0);
          if (y) {
            if (
              "undefined" != typeof Headers &&
              (0, p.isInstanceOf)(y, Headers)
            ) {
              const e = new Headers(y);
              return (
                e.append("sentry-trace", S),
                b && e.append(d.BAGGAGE_HEADER_NAME, b),
                e
              );
            }
            if (Array.isArray(y)) {
              const e = [...y, ["sentry-trace", S]];
              return b && e.push([d.BAGGAGE_HEADER_NAME, b]), e;
            }
            {
              const e = "baggage" in y ? y.baggage : void 0,
                t = [];
              return (
                Array.isArray(e) ? t.push(...e) : e && t.push(e),
                b && t.push(b),
                {
                  ...y,
                  "sentry-trace": S,
                  baggage: t.length > 0 ? t.join(",") : void 0,
                }
              );
            }
          }
          return { "sentry-trace": S, baggage: b };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            _addMeasureSpans: () => C,
            _addResourceSpans: () => I,
            _addTtfbToMeasurements: () => P,
            addPerformanceEntries: () => T,
            startTrackingInteractions: () => E,
            startTrackingLongTasks: () => k,
            startTrackingWebVitals: () => x,
          });
        var s = n(62),
          i = n(20),
          o = n(74),
          a = n(17),
          r = n(10),
          l = n(7),
          c = n(63),
          u = n(107),
          m = n(106),
          d = n(111),
          p = n(118),
          h = n(130);
        const g = 2147483647;
        function f(e) {
          return e / 1e3;
        }
        function S() {
          return d.WINDOW && d.WINDOW.addEventListener && d.WINDOW.performance;
        }
        let b,
          y,
          _ = 0,
          v = {};
        function x() {
          const e = S();
          if (e && a.browserPerformanceTimeOrigin) {
            e.mark && d.WINDOW.performance.mark("sentry-tracing-init");
            const t = (0, m.addFidInstrumentationHandler)(({ metric: e }) => {
                const t = e.entries[e.entries.length - 1];
                if (!t) return;
                const n = f(a.browserPerformanceTimeOrigin),
                  s = f(t.startTime);
                u.DEBUG_BUILD && l.logger.log("[Measurements] Adding FID"),
                  (v.fid = { value: e.value, unit: "millisecond" }),
                  (v["mark.fid"] = { value: n + s, unit: "second" });
              }),
              n = (0, m.addClsInstrumentationHandler)(({ metric: e }) => {
                const t = e.entries[e.entries.length - 1];
                t &&
                  (u.DEBUG_BUILD && l.logger.log("[Measurements] Adding CLS"),
                  (v.cls = { value: e.value, unit: "" }),
                  (y = t));
              }, !0),
              s = (0, m.addLcpInstrumentationHandler)(({ metric: e }) => {
                const t = e.entries[e.entries.length - 1];
                t &&
                  (u.DEBUG_BUILD && l.logger.log("[Measurements] Adding LCP"),
                  (v.lcp = { value: e.value, unit: "millisecond" }),
                  (b = t));
              }, !0);
            return () => {
              t(), n(), s();
            };
          }
          return () => {};
        }
        function k() {
          (0, m.addPerformanceInstrumentationHandler)(
            "longtask",
            ({ entries: e }) => {
              for (const t of e) {
                const e = (0, s.getActiveTransaction)();
                if (!e) return;
                const n = f(a.browserPerformanceTimeOrigin + t.startTime),
                  i = f(t.duration);
                e.startChild({
                  description: "Main UI thread blocked",
                  op: "ui.long-task",
                  origin: "auto.ui.browser.metrics",
                  startTimestamp: n,
                  endTimestamp: n + i,
                });
              }
            },
          );
        }
        function E() {
          (0, m.addPerformanceInstrumentationHandler)(
            "event",
            ({ entries: e }) => {
              for (const t of e) {
                const e = (0, s.getActiveTransaction)();
                if (!e) return;
                if ("click" === t.name) {
                  const n = f(a.browserPerformanceTimeOrigin + t.startTime),
                    s = f(t.duration),
                    i = {
                      description: (0, r.htmlTreeAsString)(t.target),
                      op: `ui.interaction.${t.name}`,
                      origin: "auto.ui.browser.metrics",
                      startTimestamp: n,
                      endTimestamp: n + s,
                    },
                    o = (0, r.getComponentName)(t.target);
                  o && (i.attributes = { "ui.component_name": o }),
                    e.startChild(i);
                }
              }
            },
          );
        }
        function T(e) {
          const t = S();
          if (
            !t ||
            !d.WINDOW.performance.getEntries ||
            !a.browserPerformanceTimeOrigin
          )
            return;
          u.DEBUG_BUILD &&
            l.logger.log(
              "[Tracing] Adding & adjusting spans using Performance API",
            );
          const n = f(a.browserPerformanceTimeOrigin),
            s = t.getEntries();
          let c, m;
          const { op: g, start_timestamp: x } = (0, i.spanToJSON)(e);
          if (
            (s.slice(_).forEach((t) => {
              const s = f(t.startTime),
                i = f(t.duration);
              if (!("navigation" === e.op && x && n + s < x))
                switch (t.entryType) {
                  case "navigation":
                    !(function (e, t, n) {
                      [
                        "unloadEvent",
                        "redirect",
                        "domContentLoadedEvent",
                        "loadEvent",
                        "connect",
                      ].forEach((s) => {
                        w(e, t, s, n);
                      }),
                        w(e, t, "secureConnection", n, "TLS/SSL", "connectEnd"),
                        w(e, t, "fetch", n, "cache", "domainLookupStart"),
                        w(e, t, "domainLookup", n, "DNS"),
                        (function (e, t, n) {
                          t.responseEnd &&
                            ((0, h._startChild)(e, {
                              op: "browser",
                              origin: "auto.browser.browser.metrics",
                              description: "request",
                              startTimestamp: n + f(t.requestStart),
                              endTimestamp: n + f(t.responseEnd),
                            }),
                            (0, h._startChild)(e, {
                              op: "browser",
                              origin: "auto.browser.browser.metrics",
                              description: "response",
                              startTimestamp: n + f(t.responseStart),
                              endTimestamp: n + f(t.responseEnd),
                            }));
                        })(e, t, n);
                    })(e, t, n),
                      (c = n + f(t.responseStart)),
                      (m = n + f(t.requestStart));
                    break;
                  case "mark":
                  case "paint":
                  case "measure": {
                    C(e, t, s, i, n);
                    const o = (0, p.getVisibilityWatcher)(),
                      a = t.startTime < o.firstHiddenTime;
                    "first-paint" === t.name &&
                      a &&
                      (u.DEBUG_BUILD &&
                        l.logger.log("[Measurements] Adding FP"),
                      (v.fp = { value: t.startTime, unit: "millisecond" })),
                      "first-contentful-paint" === t.name &&
                        a &&
                        (u.DEBUG_BUILD &&
                          l.logger.log("[Measurements] Adding FCP"),
                        (v.fcp = { value: t.startTime, unit: "millisecond" }));
                    break;
                  }
                  case "resource":
                    I(e, t, t.name, s, i, n);
                }
            }),
            (_ = Math.max(s.length - 1, 0)),
            (function (e) {
              const t = d.WINDOW.navigator;
              if (!t) return;
              const n = t.connection;
              n &&
                (n.effectiveType &&
                  e.setTag("effectiveConnectionType", n.effectiveType),
                n.type && e.setTag("connectionType", n.type),
                (0, h.isMeasurementValue)(n.rtt) &&
                  (v["connection.rtt"] = {
                    value: n.rtt,
                    unit: "millisecond",
                  }));
              (0, h.isMeasurementValue)(t.deviceMemory) &&
                e.setTag("deviceMemory", `${t.deviceMemory} GB`);
              (0, h.isMeasurementValue)(t.hardwareConcurrency) &&
                e.setTag("hardwareConcurrency", String(t.hardwareConcurrency));
            })(e),
            "pageload" === g)
          ) {
            P(v, c, m, x),
              ["fcp", "fp", "lcp"].forEach((e) => {
                if (!v[e] || !x || n >= x) return;
                const t = v[e].value,
                  s = n + f(t),
                  i = Math.abs(1e3 * (s - x)),
                  o = i - t;
                u.DEBUG_BUILD &&
                  l.logger.log(
                    `[Measurements] Normalized ${e} from ${t} to ${i} (${o})`,
                  ),
                  (v[e].value = i);
              });
            const t = v["mark.fid"];
            t &&
              v.fid &&
              ((0, h._startChild)(e, {
                description: "first input delay",
                endTimestamp: t.value + f(v.fid.value),
                op: "ui.action",
                origin: "auto.ui.browser.metrics",
                startTimestamp: t.value,
              }),
              delete v["mark.fid"]),
              "fcp" in v || delete v.cls,
              Object.keys(v).forEach((e) => {
                (0, o.setMeasurement)(e, v[e].value, v[e].unit);
              }),
              (function (e) {
                b &&
                  (u.DEBUG_BUILD &&
                    l.logger.log("[Measurements] Adding LCP Data"),
                  b.element &&
                    e.setTag("lcp.element", (0, r.htmlTreeAsString)(b.element)),
                  b.id && e.setTag("lcp.id", b.id),
                  b.url && e.setTag("lcp.url", b.url.trim().slice(0, 200)),
                  e.setTag("lcp.size", b.size));
                y &&
                  y.sources &&
                  (u.DEBUG_BUILD &&
                    l.logger.log("[Measurements] Adding CLS Data"),
                  y.sources.forEach((t, n) =>
                    e.setTag(
                      `cls.source.${n + 1}`,
                      (0, r.htmlTreeAsString)(t.node),
                    ),
                  ));
              })(e);
          }
          (b = void 0), (y = void 0), (v = {});
        }
        function C(e, t, n, s, i) {
          const o = i + n,
            a = o + s;
          return (
            (0, h._startChild)(e, {
              description: t.name,
              endTimestamp: a,
              op: t.entryType,
              origin: "auto.resource.browser.metrics",
              startTimestamp: o,
            }),
            o
          );
        }
        function w(e, t, n, s, i, o) {
          const a = o ? t[o] : t[`${n}End`],
            r = t[`${n}Start`];
          r &&
            a &&
            (0, h._startChild)(e, {
              op: "browser",
              origin: "auto.browser.browser.metrics",
              description: i || n,
              startTimestamp: s + f(r),
              endTimestamp: s + f(a),
            });
        }
        function I(e, t, n, s, i, o) {
          if (
            "xmlhttprequest" === t.initiatorType ||
            "fetch" === t.initiatorType
          )
            return;
          const a = (0, c.parseUrl)(n),
            r = {};
          A(r, t, "transferSize", "http.response_transfer_size"),
            A(r, t, "encodedBodySize", "http.response_content_length"),
            A(r, t, "decodedBodySize", "http.decoded_response_content_length"),
            "renderBlockingStatus" in t &&
              (r["resource.render_blocking_status"] = t.renderBlockingStatus),
            a.protocol && (r["url.scheme"] = a.protocol.split(":").pop()),
            a.host && (r["server.address"] = a.host),
            (r["url.same_origin"] = n.includes(d.WINDOW.location.origin));
          const l = o + s,
            u = l + i;
          (0, h._startChild)(e, {
            description: n.replace(d.WINDOW.location.origin, ""),
            endTimestamp: u,
            op: t.initiatorType
              ? `resource.${t.initiatorType}`
              : "resource.other",
            origin: "auto.resource.browser.metrics",
            startTimestamp: l,
            data: r,
          });
        }
        function A(e, t, n, s) {
          const i = t[n];
          null != i && i < g && (e[s] = i);
        }
        function P(e, t, n, s) {
          "number" == typeof t &&
            s &&
            (u.DEBUG_BUILD && l.logger.log("[Measurements] Adding TTFB"),
            (e.ttfb = { value: 1e3 * Math.max(t - s, 0), unit: "millisecond" }),
            "number" == typeof n &&
              n <= t &&
              (e["ttfb.requestTime"] = {
                value: 1e3 * (t - n),
                unit: "millisecond",
              }));
        }
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          return "number" == typeof e && isFinite(e);
        }
        function i(e, { startTimestamp: t, ...n }) {
          return (
            t && e.startTimestamp > t && (e.startTimestamp = t),
            e.startChild({ startTimestamp: t, ...n })
          );
        }
        n.r(t), n.d(t, { _startChild: () => i, isMeasurementValue: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { registerBackgroundTabDetection: () => l });
        var s = n(62),
          i = n(20),
          o = n(7),
          a = n(107),
          r = n(111);
        function l() {
          r.WINDOW && r.WINDOW.document
            ? r.WINDOW.document.addEventListener("visibilitychange", () => {
                const e = (0, s.getActiveTransaction)();
                if (r.WINDOW.document.hidden && e) {
                  const t = "cancelled",
                    { op: n, status: s } = (0, i.spanToJSON)(e);
                  a.DEBUG_BUILD &&
                    o.logger.log(
                      `[Tracing] Transaction: ${t} -> since tab moved to the background, op: ${n}`,
                    ),
                    s || e.setStatus(t),
                    e.setTag("visibilitychange", "document.hidden"),
                    e.end();
                }
              })
            : a.DEBUG_BUILD &&
              o.logger.warn(
                "[Tracing] Could not set up background tab detection due to lack of global document",
              );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            BROWSER_TRACING_INTEGRATION_ID: () => _,
            browserTracingIntegration: () => x,
            getMetaContent: () => T,
            startBrowserTracingNavigationSpan: () => E,
            startBrowserTracingPageLoadSpan: () => k,
          });
        var s = n(57),
          i = n(48),
          o = n(13),
          a = n(20),
          r = n(40),
          l = n(53),
          c = n(62),
          u = n(21),
          m = n(7),
          d = n(17),
          p = n(95),
          h = n(10),
          g = n(107),
          f = n(131),
          S = n(129),
          b = n(127),
          y = n(111);
        const _ = "BrowserTracing",
          v = {
            ...s.TRACING_DEFAULTS,
            instrumentNavigation: !0,
            instrumentPageLoad: !0,
            markBackgroundSpan: !0,
            enableLongTask: !0,
            _experiments: {},
            ...b.defaultRequestInstrumentationOptions,
          },
          x = (e = {}) => {
            const t =
              !!g.DEBUG_BUILD &&
              !(!e.tracePropagationTargets && !e.tracingOrigins);
            (0, i.addTracingExtensions)(),
              !e.tracePropagationTargets &&
                e.tracingOrigins &&
                (e.tracePropagationTargets = e.tracingOrigins);
            const n = { ...v, ...e },
              s = (0, S.startTrackingWebVitals)();
            let l, h;
            function x(e) {
              const t = (0, o.getCurrentHub)(),
                {
                  beforeStartSpan: a,
                  idleTimeout: c,
                  finalTimeout: d,
                  heartbeatInterval: p,
                } = n,
                f = "pageload" === e.op;
              let b;
              if (f) {
                const t = f ? T("sentry-trace") : "",
                  n = f ? T("baggage") : void 0,
                  {
                    traceId: s,
                    dsc: i,
                    parentSpanId: o,
                    sampled: a,
                  } = (0, u.propagationContextFromHeaders)(t, n);
                b = {
                  traceId: s,
                  parentSpanId: o,
                  parentSampled: a,
                  ...e,
                  metadata: { ...e.metadata, dynamicSamplingContext: i },
                  trimEnd: !0,
                };
              } else b = { trimEnd: !0, ...e };
              const _ = a ? a(b) : b;
              (_.metadata =
                _.name !== b.name
                  ? { ..._.metadata, source: "custom" }
                  : _.metadata),
                (l = _.name),
                (h = (function (e) {
                  const t =
                      e.attributes &&
                      e.attributes[r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
                    n = e.data && e.data[r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE],
                    s = e.metadata && e.metadata.source;
                  return t || n || s;
                })(_)),
                !1 === _.sampled &&
                  g.DEBUG_BUILD &&
                  m.logger.log(
                    `[Tracing] Will not send ${_.op} transaction because of beforeNavigate.`,
                  ),
                g.DEBUG_BUILD &&
                  m.logger.log(
                    `[Tracing] Starting ${_.op} transaction on scope`,
                  );
              const { location: v } = y.WINDOW,
                x = (0, i.startIdleTransaction)(
                  t,
                  _,
                  c,
                  d,
                  !0,
                  { location: v },
                  p,
                  f,
                );
              return (
                f &&
                  (y.WINDOW.document.addEventListener(
                    "readystatechange",
                    () => {
                      ["interactive", "complete"].includes(
                        y.WINDOW.document.readyState,
                      ) && x.sendAutoFinishSignal();
                    },
                  ),
                  ["interactive", "complete"].includes(
                    y.WINDOW.document.readyState,
                  ) && x.sendAutoFinishSignal()),
                x.registerBeforeFinishCallback((e) => {
                  s(), (0, S.addPerformanceEntries)(e);
                }),
                x
              );
            }
            return (
              n.enableLongTask && (0, S.startTrackingLongTasks)(),
              n._experiments.enableInteractions &&
                (0, S.startTrackingInteractions)(),
              {
                name: _,
                setupOnce: () => {},
                afterAllSetup(e) {
                  const s = e.getOptions(),
                    {
                      markBackgroundSpan: u,
                      traceFetch: S,
                      traceXHR: _,
                      shouldCreateSpanForRequest: v,
                      enableHTTPTimings: T,
                      _experiments: C,
                    } = n,
                    w = s && s.tracePropagationTargets,
                    I = w || n.tracePropagationTargets;
                  let A;
                  g.DEBUG_BUILD &&
                    t &&
                    w &&
                    m.logger.warn(
                      "[Tracing] The `tracePropagationTargets` option was set in the BrowserTracing integration and top level `Sentry.init`. The top level `Sentry.init` value is being used.",
                    );
                  let P = y.WINDOW.location.href;
                  if (
                    (e.on &&
                      (e.on("startNavigationSpan", (e) => {
                        A &&
                          (g.DEBUG_BUILD &&
                            m.logger.log(
                              `[Tracing] Finishing current transaction with op: ${(0, a.spanToJSON)(A).op}`,
                            ),
                          A.end()),
                          (A = x({ op: "navigation", ...e }));
                      }),
                      e.on("startPageLoadSpan", (e) => {
                        A &&
                          (g.DEBUG_BUILD &&
                            m.logger.log(
                              `[Tracing] Finishing current transaction with op: ${(0, a.spanToJSON)(A).op}`,
                            ),
                          A.end()),
                          (A = x({ op: "pageload", ...e }));
                      })),
                    n.instrumentPageLoad && e.emit)
                  ) {
                    const t = {
                      name: y.WINDOW.location.pathname,
                      startTimestamp: d.browserPerformanceTimeOrigin
                        ? d.browserPerformanceTimeOrigin / 1e3
                        : void 0,
                      origin: "auto.pageload.browser",
                      attributes: {
                        [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url",
                      },
                    };
                    k(e, t);
                  }
                  n.instrumentNavigation &&
                    e.emit &&
                    (0, p.addHistoryInstrumentationHandler)(
                      ({ to: t, from: n }) => {
                        if (void 0 === n && P && -1 !== P.indexOf(t))
                          P = void 0;
                        else if (n !== t) {
                          P = void 0;
                          const t = {
                            name: y.WINDOW.location.pathname,
                            origin: "auto.navigation.browser",
                            attributes: {
                              [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: "url",
                            },
                          };
                          E(e, t);
                        }
                      },
                    ),
                    u && (0, f.registerBackgroundTabDetection)(),
                    C.enableInteractions &&
                      (function (e, t, n) {
                        let s;
                        const a = () => {
                          const {
                              idleTimeout: a,
                              finalTimeout: l,
                              heartbeatInterval: u,
                            } = e,
                            d = "ui.action.click",
                            p = (0, c.getActiveTransaction)();
                          if (
                            p &&
                            p.op &&
                            ["navigation", "pageload"].includes(p.op)
                          )
                            return void (
                              g.DEBUG_BUILD &&
                              m.logger.warn(
                                `[Tracing] Did not create ${d} transaction because a pageload or navigation transaction is in progress.`,
                              )
                            );
                          if (
                            (s &&
                              (s.setFinishReason("interactionInterrupted"),
                              s.end(),
                              (s = void 0)),
                            !t)
                          )
                            return void (
                              g.DEBUG_BUILD &&
                              m.logger.warn(
                                `[Tracing] Did not create ${d} transaction because _latestRouteName is missing.`,
                              )
                            );
                          const { location: h } = y.WINDOW,
                            f = {
                              name: t,
                              op: d,
                              trimEnd: !0,
                              data: {
                                [r.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]:
                                  n || "url",
                              },
                            };
                          s = (0, i.startIdleTransaction)(
                            (0, o.getCurrentHub)(),
                            f,
                            a,
                            l,
                            !0,
                            { location: h },
                            u,
                          );
                        };
                        ["click"].forEach((e) => {
                          addEventListener(e, a, { once: !1, capture: !0 });
                        });
                      })(n, l, h),
                    (0, b.instrumentOutgoingRequests)({
                      traceFetch: S,
                      traceXHR: _,
                      tracePropagationTargets: I,
                      shouldCreateSpanForRequest: v,
                      enableHTTPTimings: T,
                    });
                },
                options: n,
              }
            );
          };
        function k(e, t) {
          if (!e.emit) return;
          e.emit("startPageLoadSpan", t);
          const n = (0, l.getActiveSpan)();
          return "pageload" === (n && (0, a.spanToJSON)(n).op) ? n : void 0;
        }
        function E(e, t) {
          if (!e.emit) return;
          e.emit("startNavigationSpan", t);
          const n = (0, l.getActiveSpan)();
          return "navigation" === (n && (0, a.spanToJSON)(n).op) ? n : void 0;
        }
        function T(e) {
          const t = (0, h.getDomElement)(`meta[name=${e}]`);
          return t ? t.getAttribute("content") : void 0;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            createStore: () => a,
            insert: () => l,
            makeBrowserOfflineTransport: () => m,
            pop: () => c,
          });
        var s = n(134),
          i = n(37);
        function o(e) {
          return new Promise((t, n) => {
            (e.oncomplete = e.onsuccess = () => t(e.result)),
              (e.onabort = e.onerror = () => n(e.error));
          });
        }
        function a(e, t) {
          const n = indexedDB.open(e);
          n.onupgradeneeded = () => n.result.createObjectStore(t);
          const s = o(n);
          return (e) =>
            s.then((n) => e(n.transaction(t, "readwrite").objectStore(t)));
        }
        function r(e) {
          return o(e.getAllKeys());
        }
        function l(e, t, n) {
          return e((e) =>
            r(e).then((s) => {
              if (!(s.length >= n))
                return e.put(t, Math.max(...s, 0) + 1), o(e.transaction);
            }),
          );
        }
        function c(e) {
          return e((e) =>
            r(e).then((t) => {
              if (0 !== t.length)
                return o(e.get(t[0])).then(
                  (n) => (e.delete(t[0]), o(e.transaction).then(() => n)),
                );
            }),
          );
        }
        function u(e) {
          let t;
          function n() {
            return (
              null == t &&
                (t = a(e.dbName || "sentry-offline", e.storeName || "queue")),
              t
            );
          }
          return {
            insert: async (t) => {
              try {
                const s = await (0, i.serializeEnvelope)(t, e.textEncoder);
                await l(n(), s, e.maxQueueSize || 30);
              } catch (e) {}
            },
            pop: async () => {
              try {
                const t = await c(n());
                if (t)
                  return (0, i.parseEnvelope)(
                    t,
                    e.textEncoder || new TextEncoder(),
                    e.textDecoder || new TextDecoder(),
                  );
              } catch (e) {}
            },
          };
        }
        function m(e) {
          return (function (e) {
            return (t) => e({ ...t, createStore: u });
          })((0, s.makeOfflineTransport)(e));
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            MIN_DELAY: () => r,
            START_DELAY: () => l,
            makeOfflineTransport: () => m,
          });
        var s = n(7),
          i = n(37),
          o = n(66),
          a = n(28);
        const r = 100,
          l = 5e3,
          c = 36e5;
        function u(e, t) {
          a.DEBUG_BUILD && s.logger.info(`[Offline]: ${e}`, t);
        }
        function m(e) {
          return (t) => {
            const n = e(t),
              s = t.createStore ? t.createStore(t) : void 0;
            let a,
              m = l;
            function d(e) {
              s &&
                (a && clearTimeout(a),
                (a = setTimeout(async () => {
                  a = void 0;
                  const e = await s.pop();
                  e &&
                    (u("Attempting to send previously queued event"),
                    h(e).catch((e) => {
                      u("Failed to retry sending", e);
                    }));
                }, e)),
                "number" != typeof a && a.unref && a.unref());
            }
            function p() {
              a || (d(m), (m = Math.min(2 * m, c)));
            }
            async function h(e) {
              try {
                const t = await n.send(e);
                let s = r;
                if (t)
                  if (t.headers && t.headers["retry-after"])
                    s = (0, o.parseRetryAfterHeader)(t.headers["retry-after"]);
                  else if ((t.statusCode || 0) >= 400) return t;
                return d(s), (m = l), t;
              } catch (n) {
                if (
                  s &&
                  (await (function (e, n, s) {
                    return (
                      !(0, i.envelopeContainsItemType)(e, [
                        "replay_event",
                        "replay_recording",
                        "client_report",
                      ]) &&
                      (!t.shouldStore || t.shouldStore(e, n, s))
                    );
                  })(e, n, m))
                )
                  return (
                    await s.insert(e),
                    p(),
                    u("Error sending. Event queued", n),
                    {}
                  );
                throw n;
              }
            }
            return (
              t.flushAtStartup && p(), { send: h, flush: (e) => n.flush(e) }
            );
          };
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            onProfilingStartRouteTransaction: () => u,
            startProfileForTransaction: () => m,
          });
        var s = n(20),
          i = n(7),
          o = n(17),
          a = n(18),
          r = n(80),
          l = n(75),
          c = n(136);
        function u(e) {
          return e
            ? (0, c.shouldProfileTransaction)(e)
              ? m(e)
              : e
            : (r.DEBUG_BUILD &&
                i.logger.log(
                  "[Profiling] Transaction is undefined, skipping profiling",
                ),
              e);
        }
        function m(e) {
          let t;
          (0, c.isAutomatedPageLoadTransaction)(e) &&
            (t = 1e3 * (0, o.timestampInSeconds)());
          const n = (0, c.startJSSelfProfile)();
          if (!n) return e;
          r.DEBUG_BUILD &&
            i.logger.log(
              `[Profiling] started profiling transaction: ${(0, s.spanToJSON)(e).description}`,
            );
          const u = (0, a.uuid4)();
          async function m() {
            return e && n
              ? n
                  .stop()
                  .then(
                    (t) => (
                      d && (l.WINDOW.clearTimeout(d), (d = void 0)),
                      r.DEBUG_BUILD &&
                        i.logger.log(
                          `[Profiling] stopped profiling of transaction: ${(0, s.spanToJSON)(e).description}`,
                        ),
                      t
                        ? ((0, c.addProfileToGlobalCache)(u, t), null)
                        : (r.DEBUG_BUILD &&
                            i.logger.log(
                              `[Profiling] profiler returned null profile for: ${(0, s.spanToJSON)(e).description}`,
                              "this may indicate an overlapping transaction or a call to stopProfiling with a profile title that was never started",
                            ),
                          null)
                    ),
                  )
                  .catch(
                    (e) => (
                      r.DEBUG_BUILD &&
                        i.logger.log(
                          "[Profiling] error while stopping profiler:",
                          e,
                        ),
                      null
                    ),
                  )
              : null;
          }
          let d = l.WINDOW.setTimeout(() => {
            r.DEBUG_BUILD &&
              i.logger.log(
                "[Profiling] max profile duration elapsed, stopping profiling for:",
                (0, s.spanToJSON)(e).description,
              ),
              m();
          }, c.MAX_PROFILE_DURATION_MS);
          const p = e.end.bind(e);
          return (
            (e.end = function () {
              return e
                ? (m().then(
                    () => {
                      e.setContext("profile", {
                        profile_id: u,
                        start_timestamp: t,
                      }),
                        p();
                    },
                    () => {
                      p();
                    },
                  ),
                  e)
                : p();
            }),
            e
          );
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            MAX_PROFILE_DURATION_MS: () => M,
            addProfileToGlobalCache: () => H,
            addProfilesToEnvelope: () => w,
            applyDebugMetadata: () => P,
            convertJSSelfProfileToSampledFormat: () => C,
            createProfilePayload: () => E,
            createProfilingEvent: () => L,
            enrichWithThreadInformation: () => k,
            findProfiledTransactionsFromEnvelope: () => I,
            getActiveProfilesCount: () => U,
            isAutomatedPageLoadTransaction: () => T,
            isValidSampleRate: () => R,
            shouldProfileTransaction: () => N,
            startJSSelfProfile: () => O,
            takeProfileFromGlobalCache: () => F,
          });
        var s = n(25),
          i = n(12),
          o = n(7),
          a = n(18),
          r = n(17),
          l = n(37),
          c = n(8),
          u = n(80),
          m = n(75);
        const d = 1e6,
          p = String(0),
          h = "main";
        let g = "",
          f = "",
          S = "",
          b = (m.WINDOW.navigator && m.WINDOW.navigator.userAgent) || "",
          y = "";
        const _ =
          (m.WINDOW.navigator && m.WINDOW.navigator.language) ||
          (m.WINDOW.navigator &&
            m.WINDOW.navigator.languages &&
            m.WINDOW.navigator.languages[0]) ||
          "";
        const v = m.WINDOW.navigator && m.WINDOW.navigator.userAgentData;
        var x;
        function k(e) {
          return (function (e) {
            return !("thread_metadata" in e);
          })(e)
            ? C(e)
            : e;
        }
        function E(e, t, n, i) {
          if ("transaction" !== i.type)
            throw new TypeError(
              "Profiling events may only be attached to transactions, this should never occur.",
            );
          if (null == n)
            throw new TypeError(
              `Cannot construct profiling event envelope without a valid profile. Got ${n} instead.`,
            );
          const r = (function (e) {
              const t =
                e &&
                e.contexts &&
                e.contexts.trace &&
                e.contexts.trace.trace_id;
              return (
                "string" == typeof t &&
                  32 !== t.length &&
                  u.DEBUG_BUILD &&
                  o.logger.log(
                    `[Profiling] Invalid traceId: ${t} on profiled event`,
                  ),
                "string" != typeof t ? "" : t
              );
            })(i),
            l = k(n),
            c =
              t ||
              ("number" == typeof i.start_timestamp
                ? 1e3 * i.start_timestamp
                : Date.now()),
            d = "number" == typeof i.timestamp ? 1e3 * i.timestamp : Date.now();
          return {
            event_id: e,
            timestamp: new Date(c).toISOString(),
            platform: "javascript",
            version: "1",
            release: i.release || "",
            environment: i.environment || s.DEFAULT_ENVIRONMENT,
            runtime: {
              name: "javascript",
              version: m.WINDOW.navigator.userAgent,
            },
            os: { name: g, version: f, build_number: b },
            device: {
              locale: _,
              model: y,
              manufacturer: b,
              architecture: S,
              is_emulator: !1,
            },
            debug_meta: { images: P(n.resources) },
            profile: l,
            transactions: [
              {
                name: i.transaction || "",
                id: i.event_id || (0, a.uuid4)(),
                trace_id: r,
                active_thread_id: p,
                relative_start_ns: "0",
                relative_end_ns: (1e6 * (d - c)).toFixed(0),
              },
            ],
          };
        }
        function T(e) {
          return "pageload" === e.op;
        }
        function C(e) {
          let t,
            n = 0;
          const s = {
            samples: [],
            stacks: [],
            frames: [],
            thread_metadata: { [p]: { name: h } },
          };
          if (!e.samples.length) return s;
          const i = e.samples[0].timestamp,
            o =
              "number" == typeof performance.timeOrigin
                ? performance.timeOrigin
                : r.browserPerformanceTimeOrigin || 0,
            a = o - (r.browserPerformanceTimeOrigin || o);
          for (let o = 0; o < e.samples.length; o++) {
            const r = e.samples[o];
            if (void 0 === r.stackId) {
              void 0 === t && ((t = n), (s.stacks[t] = []), n++),
                (s.samples[o] = {
                  elapsed_since_start_ns: ((r.timestamp + a - i) * d).toFixed(
                    0,
                  ),
                  stack_id: t,
                  thread_id: p,
                });
              continue;
            }
            let l = e.stacks[r.stackId];
            const c = [];
            for (; l; ) {
              c.push(l.frameId);
              const t = e.frames[l.frameId];
              void 0 === s.frames[l.frameId] &&
                (s.frames[l.frameId] = {
                  function: t.name,
                  abs_path:
                    "number" == typeof t.resourceId
                      ? e.resources[t.resourceId]
                      : void 0,
                  lineno: t.line,
                  colno: t.column,
                }),
                (l = void 0 === l.parentId ? void 0 : e.stacks[l.parentId]);
            }
            const u = {
              elapsed_since_start_ns: ((r.timestamp + a - i) * d).toFixed(0),
              stack_id: n,
              thread_id: p,
            };
            (s.stacks[n] = c), (s.samples[o] = u), n++;
          }
          return s;
        }
        function w(e, t) {
          if (!t.length) return e;
          for (const n of t) e[1].push([{ type: "profile" }, n]);
          return e;
        }
        function I(e) {
          const t = [];
          return (
            (0, l.forEachEnvelopeItem)(e, (e, n) => {
              if ("transaction" === n)
                for (let n = 1; n < e.length; n++) {
                  const s = e[n];
                  s &&
                    s.contexts &&
                    s.contexts.profile &&
                    s.contexts.profile.profile_id &&
                    t.push(e[n]);
                }
            }),
            t
          );
        }
        "object" == typeof (x = v) &&
          null !== x &&
          "getHighEntropyValues" in x &&
          v
            .getHighEntropyValues([
              "architecture",
              "model",
              "platform",
              "platformVersion",
              "fullVersionList",
            ])
            .then((e) => {
              if (
                ((g = e.platform || ""),
                (S = e.architecture || ""),
                (y = e.model || ""),
                (f = e.platformVersion || ""),
                e.fullVersionList && e.fullVersionList.length > 0)
              ) {
                const t = e.fullVersionList[e.fullVersionList.length - 1];
                b = `${t.brand} ${t.version}`;
              }
            })
            .catch((e) => {});
        const A = new WeakMap();
        function P(e) {
          const t = c.GLOBAL_OBJ._sentryDebugIds;
          if (!t) return [];
          const n = (0, i.getClient)(),
            s = n && n.getOptions(),
            o = s && s.stackParser;
          if (!o) return [];
          let a;
          const r = A.get(o);
          r ? (a = r) : ((a = new Map()), A.set(o, a));
          const l = Object.keys(t).reduce((e, n) => {
              let s;
              const i = a.get(n);
              i ? (s = i) : ((s = o(n)), a.set(n, s));
              for (let i = s.length - 1; i >= 0; i--) {
                const o = s[i],
                  a = o && o.filename;
                if (o && a) {
                  e[a] = t[n];
                  break;
                }
              }
              return e;
            }, {}),
            u = [];
          for (const t of e)
            t &&
              l[t] &&
              u.push({ type: "sourcemap", code_file: t, debug_id: l[t] });
          return u;
        }
        function R(e) {
          return ("number" != typeof e && "boolean" != typeof e) ||
            ("number" == typeof e && isNaN(e))
            ? (u.DEBUG_BUILD &&
                o.logger.warn(
                  `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(e)} of type ${JSON.stringify(typeof e)}.`,
                ),
              !1)
            : !0 === e ||
                !1 === e ||
                !(e < 0 || e > 1) ||
                (u.DEBUG_BUILD &&
                  o.logger.warn(
                    `[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${e}.`,
                  ),
                !1);
        }
        let D = !1;
        const M = 3e4;
        function O() {
          const e = m.WINDOW.Profiler;
          if ("function" != typeof e)
            return void (
              u.DEBUG_BUILD &&
              o.logger.log(
                "[Profiling] Profiling is not supported by this browser, Profiler interface missing on window object.",
              )
            );
          const t = Math.floor(M / 10);
          try {
            return new e({ sampleInterval: 10, maxBufferSize: t });
          } catch (e) {
            u.DEBUG_BUILD &&
              (o.logger.log(
                "[Profiling] Failed to initialize the Profiling constructor, this is likely due to a missing 'Document-Policy': 'js-profiling' header.",
              ),
              o.logger.log(
                "[Profiling] Disabling profiling for current user session.",
              )),
              (D = !0);
          }
        }
        function N(e) {
          if (D)
            return (
              u.DEBUG_BUILD &&
                o.logger.log(
                  "[Profiling] Profiling has been disabled for the duration of the current user session.",
                ),
              !1
            );
          if (!e.isRecording())
            return (
              u.DEBUG_BUILD &&
                o.logger.log(
                  "[Profiling] Discarding profile because transaction was not sampled.",
                ),
              !1
            );
          const t = (0, i.getClient)(),
            n = t && t.getOptions();
          if (!n)
            return (
              u.DEBUG_BUILD &&
                o.logger.log(
                  "[Profiling] Profiling disabled, no options found.",
                ),
              !1
            );
          const s = n.profilesSampleRate;
          if (!R(s))
            return (
              u.DEBUG_BUILD &&
                o.logger.warn(
                  "[Profiling] Discarding profile because of invalid sample rate.",
                ),
              !1
            );
          if (!s)
            return (
              u.DEBUG_BUILD &&
                o.logger.log(
                  "[Profiling] Discarding profile because a negative sampling decision was inherited or profileSampleRate is set to 0",
                ),
              !1
            );
          return (
            !!(!0 === s || Math.random() < s) ||
            (u.DEBUG_BUILD &&
              o.logger.log(
                `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(s)})`,
              ),
            !1)
          );
        }
        function L(e, t, n, s) {
          return (function (e) {
            return e.samples.length < 2
              ? (u.DEBUG_BUILD &&
                  o.logger.log(
                    "[Profiling] Discarding profile because it contains less than 2 samples",
                  ),
                !1)
              : !!e.frames.length ||
                  (u.DEBUG_BUILD &&
                    o.logger.log(
                      "[Profiling] Discarding profile because it contains no frames",
                    ),
                  !1);
          })(n)
            ? E(e, t, n, s)
            : null;
        }
        const B = new Map();
        function U() {
          return B.size;
        }
        function F(e) {
          const t = B.get(e);
          return t && B.delete(e), t;
        }
        function H(e, t) {
          if ((B.set(e, t), B.size > 30)) {
            const e = B.keys().next().value;
            B.delete(e);
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            BrowserProfilingIntegration: () => m,
            browserProfilingIntegration: () => u,
          });
        var s = n(12),
          i = n(34),
          o = n(7),
          a = n(80),
          r = n(135),
          l = n(136);
        const c = "BrowserProfiling",
          u = (0, i.defineIntegration)(() => ({
            name: c,
            setupOnce() {},
            setup(e) {
              const t = (0, s.getCurrentScope)().getTransaction();
              t &&
                (0, l.isAutomatedPageLoadTransaction)(t) &&
                (0, l.shouldProfileTransaction)(t) &&
                (0, r.startProfileForTransaction)(t),
                "function" == typeof e.on
                  ? (e.on("startTransaction", (e) => {
                      (0, l.shouldProfileTransaction)(e) &&
                        (0, r.startProfileForTransaction)(e);
                    }),
                    e.on("beforeEnvelope", (e) => {
                      if (!(0, l.getActiveProfilesCount)()) return;
                      const t = (0, l.findProfiledTransactionsFromEnvelope)(e);
                      if (!t.length) return;
                      const n = [];
                      for (const e of t) {
                        const t = e && e.contexts,
                          s = t && t.profile && t.profile.profile_id,
                          i = t && t.profile && t.profile.start_timestamp;
                        if ("string" != typeof s) {
                          a.DEBUG_BUILD &&
                            o.logger.log(
                              "[Profiling] cannot find profile for a transaction without a profile context",
                            );
                          continue;
                        }
                        if (!s) {
                          a.DEBUG_BUILD &&
                            o.logger.log(
                              "[Profiling] cannot find profile for a transaction without a profile context",
                            );
                          continue;
                        }
                        t && t.profile && delete t.profile;
                        const r = (0, l.takeProfileFromGlobalCache)(s);
                        if (!r) {
                          a.DEBUG_BUILD &&
                            o.logger.log(
                              `[Profiling] Could not retrieve profile for transaction: ${s}`,
                            );
                          continue;
                        }
                        const c = (0, l.createProfilingEvent)(s, i, r, e);
                        c && n.push(c);
                      }
                      (0, l.addProfilesToEnvelope)(e, n);
                    }))
                  : o.logger.warn(
                      "[Profiling] Client does not support hooks, profiling will be disabled",
                    );
            },
          })),
          m = (0, i.convertIntegrationFnToClass)(c, u);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            BaseClient: () => v.BaseClient,
            DEFAULT_ENVIRONMENT: () => F.DEFAULT_ENVIRONMENT,
            FunctionToString: () => W.FunctionToString,
            Hub: () => g.Hub,
            IdleTransaction: () => i.IdleTransaction,
            InboundFilters: () => G.InboundFilters,
            Integrations: () => z,
            LinkedErrors: () => q.LinkedErrors,
            ModuleMetadata: () => H.ModuleMetadata,
            RequestData: () => j.RequestData,
            SDK_VERSION: () => w.SDK_VERSION,
            SEMANTIC_ATTRIBUTE_SENTRY_OP: () => d.SEMANTIC_ATTRIBUTE_SENTRY_OP,
            SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN: () =>
              d.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
            SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE: () =>
              d.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,
            SEMANTIC_ATTRIBUTE_SENTRY_SOURCE: () =>
              d.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
            Scope: () => b.Scope,
            ServerRuntimeClient: () => x.ServerRuntimeClient,
            SessionFlusher: () => S.SessionFlusher,
            Span: () => o.Span,
            SpanStatus: () => l.SpanStatus,
            TRACING_DEFAULTS: () => i.TRACING_DEFAULTS,
            Transaction: () => a.Transaction,
            addBreadcrumb: () => h.addBreadcrumb,
            addEventProcessor: () => v.addEventProcessor,
            addGlobalEventProcessor: () => y.addGlobalEventProcessor,
            addIntegration: () => I.addIntegration,
            addTracingExtensions: () => s.addTracingExtensions,
            applyScopeDataToEvent: () => A.applyScopeDataToEvent,
            applySdkMetadata: () => U.applySdkMetadata,
            captureCheckIn: () => h.captureCheckIn,
            captureEvent: () => h.captureEvent,
            captureException: () => h.captureException,
            captureMessage: () => h.captureMessage,
            captureSession: () => h.captureSession,
            close: () => h.close,
            closeSession: () => f.closeSession,
            configureScope: () => h.configureScope,
            continueTrace: () => c.continueTrace,
            convertIntegrationFnToClass: () => I.convertIntegrationFnToClass,
            createCheckInEnvelope: () => R.createCheckInEnvelope,
            createEventEnvelope: () => p.createEventEnvelope,
            createSessionEnvelope: () => p.createSessionEnvelope,
            createTransport: () => E.createTransport,
            defineIntegration: () => I.defineIntegration,
            endSession: () => h.endSession,
            ensureHubOnCarrier: () => g.ensureHubOnCarrier,
            extractTraceparentData: () => r.extractTraceparentData,
            flush: () => h.flush,
            functionToStringIntegration: () => W.functionToStringIntegration,
            getActiveSpan: () => c.getActiveSpan,
            getActiveTransaction: () => r.getActiveTransaction,
            getClient: () => h.getClient,
            getCurrentHub: () => g.getCurrentHub,
            getCurrentScope: () => h.getCurrentScope,
            getDynamicSamplingContextFromClient: () =>
              u.getDynamicSamplingContextFromClient,
            getDynamicSamplingContextFromSpan: () =>
              u.getDynamicSamplingContextFromSpan,
            getEnvelopeEndpointWithUrlEncodedAuth: () =>
              _.getEnvelopeEndpointWithUrlEncodedAuth,
            getGlobalScope: () => b.getGlobalScope,
            getHubFromCarrier: () => g.getHubFromCarrier,
            getIntegrationsToSetup: () => I.getIntegrationsToSetup,
            getIsolationScope: () => g.getIsolationScope,
            getMainCarrier: () => g.getMainCarrier,
            getReportDialogEndpoint: () => _.getReportDialogEndpoint,
            getRootSpan: () => B.getRootSpan,
            getSpanStatusFromHttpCode: () => l.getSpanStatusFromHttpCode,
            handleCallbackErrors: () => O.handleCallbackErrors,
            hasTracingEnabled: () => D.hasTracingEnabled,
            inboundFiltersIntegration: () => G.inboundFiltersIntegration,
            initAndBind: () => k.initAndBind,
            isInitialized: () => h.isInitialized,
            isSentryRequestUrl: () => M.isSentryRequestUrl,
            lastEventId: () => h.lastEventId,
            linkedErrorsIntegration: () => q.linkedErrorsIntegration,
            makeMain: () => g.makeMain,
            makeMultiplexedTransport: () => C.makeMultiplexedTransport,
            makeOfflineTransport: () => T.makeOfflineTransport,
            makeSession: () => f.makeSession,
            mergeScopeData: () => A.mergeScopeData,
            metrics: () => V.metrics,
            moduleMetadataIntegration: () => H.moduleMetadataIntegration,
            notifyEventProcessors: () => y.notifyEventProcessors,
            parameterize: () => N.parameterize,
            prepareEvent: () => P.prepareEvent,
            requestDataIntegration: () => j.requestDataIntegration,
            runWithAsyncContext: () => g.runWithAsyncContext,
            setAsyncContextStrategy: () => g.setAsyncContextStrategy,
            setContext: () => h.setContext,
            setCurrentClient: () => k.setCurrentClient,
            setExtra: () => h.setExtra,
            setExtras: () => h.setExtras,
            setGlobalScope: () => b.setGlobalScope,
            setHttpStatus: () => l.setHttpStatus,
            setHubOnCarrier: () => g.setHubOnCarrier,
            setMeasurement: () => m.setMeasurement,
            setTag: () => h.setTag,
            setTags: () => h.setTags,
            setUser: () => h.setUser,
            spanIsSampled: () => L.spanIsSampled,
            spanStatusfromHttpCode: () => l.spanStatusfromHttpCode,
            spanToJSON: () => L.spanToJSON,
            spanToTraceContext: () => L.spanToTraceContext,
            spanToTraceHeader: () => L.spanToTraceHeader,
            startActiveSpan: () => c.startActiveSpan,
            startIdleTransaction: () => s.startIdleTransaction,
            startInactiveSpan: () => c.startInactiveSpan,
            startSession: () => h.startSession,
            startSpan: () => c.startSpan,
            startSpanManual: () => c.startSpanManual,
            startTransaction: () => h.startTransaction,
            trace: () => c.trace,
            updateSession: () => f.updateSession,
            withActiveSpan: () => h.withActiveSpan,
            withIsolationScope: () => h.withIsolationScope,
            withMonitor: () => h.withMonitor,
            withScope: () => h.withScope,
          });
        var s = n(48),
          i = n(57),
          o = n(50),
          a = n(49),
          r = n(62),
          l = n(51),
          c = n(53),
          u = n(24),
          m = n(74),
          d = n(40),
          p = n(43),
          h = n(12),
          g = n(13),
          f = n(16),
          S = n(139),
          b = n(15),
          y = n(26),
          _ = n(42),
          v = n(41),
          x = n(140),
          k = n(73),
          E = n(64),
          T = n(134),
          C = n(67),
          w = n(14),
          I = n(34),
          A = n(19),
          P = n(29),
          R = n(143),
          D = n(55),
          M = n(120),
          O = n(54),
          N = n(72),
          L = n(20),
          B = n(23),
          U = n(78),
          F = n(25),
          H = n(36),
          j = n(144),
          G = n(35),
          W = n(4),
          q = n(147),
          $ = n(148),
          V = n(68);
        const z = $;
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { SessionFlusher: () => o });
        var s = n(5),
          i = n(12);
        class o {
          constructor(e, t) {
            (this._client = e),
              (this.flushTimeout = 60),
              (this._pendingAggregates = {}),
              (this._isEnabled = !0),
              (this._intervalId = setInterval(
                () => this.flush(),
                1e3 * this.flushTimeout,
              )),
              (this._sessionAttrs = t);
          }
          flush() {
            const e = this.getSessionAggregates();
            0 !== e.aggregates.length &&
              ((this._pendingAggregates = {}), this._client.sendSession(e));
          }
          getSessionAggregates() {
            const e = Object.keys(this._pendingAggregates).map(
                (e) => this._pendingAggregates[parseInt(e)],
              ),
              t = { attrs: this._sessionAttrs, aggregates: e };
            return (0, s.dropUndefinedKeys)(t);
          }
          close() {
            clearInterval(this._intervalId),
              (this._isEnabled = !1),
              this.flush();
          }
          incrementSessionStatusCount() {
            if (!this._isEnabled) return;
            const e = (0, i.getCurrentScope)(),
              t = e.getRequestSession();
            t &&
              t.status &&
              (this._incrementSessionStatusCount(t.status, new Date()),
              e.setRequestSession(void 0));
          }
          _incrementSessionStatusCount(e, t) {
            const n = new Date(t).setSeconds(0, 0);
            this._pendingAggregates[n] = this._pendingAggregates[n] || {};
            const s = this._pendingAggregates[n];
            switch ((s.started || (s.started = new Date(n).toISOString()), e)) {
              case "errored":
                return (s.errored = (s.errored || 0) + 1), s.errored;
              case "ok":
                return (s.exited = (s.exited || 0) + 1), s.exited;
              default:
                return (s.crashed = (s.crashed || 0) + 1), s.crashed;
            }
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { ServerRuntimeClient: () => S });
        var s = n(27),
          i = n(142),
          o = n(7),
          a = n(18),
          r = n(41),
          l = n(143),
          c = n(28),
          u = n(12),
          m = n(141),
          d = n(139),
          p = n(48),
          h = n(20),
          g = n(23),
          f = n(24);
        class S extends r.BaseClient {
          constructor(e) {
            (0, p.addTracingExtensions)(),
              super(e),
              e._experiments &&
                e._experiments.metricsAggregator &&
                (this.metricsAggregator = new m.MetricsAggregator(this));
          }
          eventFromException(e, t) {
            return (0, s.resolvedSyncPromise)(
              (0, i.eventFromUnknownInput)(
                (0, u.getClient)(),
                this._options.stackParser,
                e,
                t,
              ),
            );
          }
          eventFromMessage(e, t = "info", n) {
            return (0, s.resolvedSyncPromise)(
              (0, i.eventFromMessage)(
                this._options.stackParser,
                e,
                t,
                n,
                this._options.attachStacktrace,
              ),
            );
          }
          captureException(e, t, n) {
            if (
              this._options.autoSessionTracking &&
              this._sessionFlusher &&
              n
            ) {
              const e = n.getRequestSession();
              e && "ok" === e.status && (e.status = "errored");
            }
            return super.captureException(e, t, n);
          }
          captureEvent(e, t, n) {
            if (
              this._options.autoSessionTracking &&
              this._sessionFlusher &&
              n
            ) {
              if (
                "exception" === (e.type || "exception") &&
                e.exception &&
                e.exception.values &&
                e.exception.values.length > 0
              ) {
                const e = n.getRequestSession();
                e && "ok" === e.status && (e.status = "errored");
              }
            }
            return super.captureEvent(e, t, n);
          }
          close(e) {
            return (
              this._sessionFlusher && this._sessionFlusher.close(),
              super.close(e)
            );
          }
          initSessionFlusher() {
            const { release: e, environment: t } = this._options;
            e
              ? (this._sessionFlusher = new d.SessionFlusher(this, {
                  release: e,
                  environment: t,
                }))
              : c.DEBUG_BUILD &&
                o.logger.warn(
                  "Cannot initialise an instance of SessionFlusher if no release is provided!",
                );
          }
          captureCheckIn(e, t, n) {
            const s =
              "checkInId" in e && e.checkInId ? e.checkInId : (0, a.uuid4)();
            if (!this._isEnabled())
              return (
                c.DEBUG_BUILD &&
                  o.logger.warn("SDK not enabled, will not capture checkin."),
                s
              );
            const i = this.getOptions(),
              { release: r, environment: u, tunnel: m } = i,
              d = {
                check_in_id: s,
                monitor_slug: e.monitorSlug,
                status: e.status,
                release: r,
                environment: u,
              };
            "duration" in e && (d.duration = e.duration),
              t &&
                (d.monitor_config = {
                  schedule: t.schedule,
                  checkin_margin: t.checkinMargin,
                  max_runtime: t.maxRuntime,
                  timezone: t.timezone,
                });
            const [p, h] = this._getTraceInfoFromScope(n);
            h && (d.contexts = { trace: h });
            const g = (0, l.createCheckInEnvelope)(
              d,
              p,
              this.getSdkMetadata(),
              m,
              this.getDsn(),
            );
            return (
              c.DEBUG_BUILD &&
                o.logger.info("Sending checkin:", e.monitorSlug, e.status),
              this._sendEnvelope(g),
              s
            );
          }
          _captureRequestSession() {
            this._sessionFlusher
              ? this._sessionFlusher.incrementSessionStatusCount()
              : c.DEBUG_BUILD &&
                o.logger.warn(
                  "Discarded request mode session because autoSessionTracking option was disabled",
                );
          }
          _prepareEvent(e, t, n, s) {
            return (
              this._options.platform &&
                (e.platform = e.platform || this._options.platform),
              this._options.runtime &&
                (e.contexts = {
                  ...e.contexts,
                  runtime: (e.contexts || {}).runtime || this._options.runtime,
                }),
              this._options.serverName &&
                (e.server_name = e.server_name || this._options.serverName),
              super._prepareEvent(e, t, n, s)
            );
          }
          _getTraceInfoFromScope(e) {
            if (!e) return [void 0, void 0];
            const t = e.getSpan();
            if (t) {
              return [
                (0, g.getRootSpan)(t)
                  ? (0, f.getDynamicSamplingContextFromSpan)(t)
                  : void 0,
                (0, h.spanToTraceContext)(t),
              ];
            }
            const {
                traceId: n,
                spanId: s,
                parentSpanId: i,
                dsc: o,
              } = e.getPropagationContext(),
              a = { trace_id: n, span_id: s, parent_span_id: i };
            return o
              ? [o, a]
              : [(0, f.getDynamicSamplingContextFromClient)(n, this, e), a];
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { MetricsAggregator: () => l });
        var s = n(17),
          i = n(46),
          o = n(71),
          a = n(52),
          r = n(45);
        class l {
          constructor(e) {
            (this._client = e),
              (this._buckets = new Map()),
              (this._bucketsTotalWeight = 0),
              (this._interval = setInterval(
                () => this._flush(),
                i.DEFAULT_FLUSH_INTERVAL,
              )),
              (this._flushShift = Math.floor(
                (Math.random() * i.DEFAULT_FLUSH_INTERVAL) / 1e3,
              )),
              (this._forceFlush = !1);
          }
          add(e, t, n, l = "none", c = {}, u = (0, s.timestampInSeconds)()) {
            const m = Math.floor(u),
              d = t.replace(i.NAME_AND_TAG_KEY_NORMALIZATION_REGEX, "_"),
              p = (0, r.sanitizeTags)(c),
              h = (0, r.getBucketKey)(e, d, l, p);
            let g = this._buckets.get(h);
            const f = g && e === i.SET_METRIC_TYPE ? g.metric.weight : 0;
            g
              ? (g.metric.add(n), g.timestamp < m && (g.timestamp = m))
              : ((g = {
                  metric: new o.METRIC_MAP[e](n),
                  timestamp: m,
                  metricType: e,
                  name: d,
                  unit: l,
                  tags: p,
                }),
                this._buckets.set(h, g));
            const S = "string" == typeof n ? g.metric.weight - f : n;
            (0, a.updateMetricSummaryOnActiveSpan)(e, d, S, l, c, h),
              (this._bucketsTotalWeight += g.metric.weight),
              this._bucketsTotalWeight >= i.MAX_WEIGHT && this.flush();
          }
          flush() {
            (this._forceFlush = !0), this._flush();
          }
          close() {
            (this._forceFlush = !0),
              clearInterval(this._interval),
              this._flush();
          }
          _flush() {
            if (this._forceFlush)
              return (
                (this._forceFlush = !1),
                (this._bucketsTotalWeight = 0),
                this._captureMetrics(this._buckets),
                void this._buckets.clear()
              );
            const e =
                Math.floor((0, s.timestampInSeconds)()) -
                i.DEFAULT_FLUSH_INTERVAL / 1e3 -
                this._flushShift,
              t = new Map();
            for (const [n, s] of this._buckets)
              s.timestamp <= e &&
                (t.set(n, s), (this._bucketsTotalWeight -= s.metric.weight));
            for (const [e] of t) this._buckets.delete(e);
            this._captureMetrics(t);
          }
          _captureMetrics(e) {
            if (e.size > 0 && this._client.captureAggregateMetrics) {
              const t = Array.from(e).map(([, e]) => e);
              this._client.captureAggregateMetrics(t);
            }
          }
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            eventFromMessage: () => u,
            eventFromUnknownInput: () => c,
            exceptionFromError: () => l,
            parseStackFrames: () => r,
          });
        var s = n(9),
          i = n(18),
          o = n(30),
          a = n(5);
        function r(e, t) {
          return e(t.stack || "", 1);
        }
        function l(e, t) {
          const n = { type: t.name || t.constructor.name, value: t.message },
            s = r(e, t);
          return s.length && (n.stacktrace = { frames: s }), n;
        }
        function c(e, t, n, r) {
          const c = "function" == typeof e ? e().getClient() : e;
          let u = n;
          const m = (r && r.data && r.data.mechanism) || {
            handled: !0,
            type: "generic",
          };
          let d;
          if (!(0, s.isError)(n)) {
            if ((0, s.isPlainObject)(n)) {
              const e = c && c.getOptions().normalizeDepth;
              d = { __serialized__: (0, o.normalizeToSize)(n, e) };
              const t = (function (e) {
                if ("name" in e && "string" == typeof e.name) {
                  let t = `'${e.name}' captured as exception`;
                  return (
                    "message" in e &&
                      "string" == typeof e.message &&
                      (t += ` with message '${e.message}'`),
                    t
                  );
                }
                return "message" in e && "string" == typeof e.message
                  ? e.message
                  : `Object captured as exception with keys: ${(0, a.extractExceptionKeysForMessage)(e)}`;
              })(n);
              (u = (r && r.syntheticException) || new Error(t)),
                (u.message = t);
            } else
              (u = (r && r.syntheticException) || new Error(n)),
                (u.message = n);
            m.synthetic = !0;
          }
          const p = { exception: { values: [l(t, u)] } };
          return (
            d && (p.extra = d),
            (0, i.addExceptionTypeValue)(p, void 0, void 0),
            (0, i.addExceptionMechanism)(p, m),
            { ...p, event_id: r && r.event_id }
          );
        }
        function u(e, t, n = "info", i, o) {
          const a = { event_id: i && i.event_id, level: n };
          if (o && i && i.syntheticException) {
            const n = r(e, i.syntheticException);
            n.length &&
              (a.exception = {
                values: [{ value: t, stacktrace: { frames: n } }],
              });
          }
          if ((0, s.isParameterizedString)(t)) {
            const {
              __sentry_template_string__: e,
              __sentry_template_values__: n,
            } = t;
            return (a.logentry = { message: e, params: n }), a;
          }
          return (a.message = t), a;
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t), n.d(t, { createCheckInEnvelope: () => a });
        var s = n(38),
          i = n(5),
          o = n(37);
        function a(e, t, n, a, r) {
          const l = { sent_at: new Date().toISOString() };
          n && n.sdk && (l.sdk = { name: n.sdk.name, version: n.sdk.version }),
            a && r && (l.dsn = (0, s.dsnToString)(r)),
            t && (l.trace = (0, i.dropUndefinedKeys)(t));
          const c = (function (e) {
            return [{ type: "check_in" }, e];
          })(e);
          return (0, o.createEnvelope)(l, [c]);
        }
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { RequestData: () => c, requestDataIntegration: () => l });
        var s = n(145),
          i = n(34),
          o = n(20);
        const a = {
            include: {
              cookies: !0,
              data: !0,
              headers: !0,
              ip: !1,
              query_string: !0,
              url: !0,
              user: { id: !0, username: !0, email: !0 },
            },
            transactionNamingScheme: "methodPath",
          },
          r = "RequestData",
          l = (0, i.defineIntegration)((e = {}) => {
            const t = s.addRequestDataToEvent,
              n = {
                ...a,
                ...e,
                include: {
                  method: !0,
                  ...a.include,
                  ...e.include,
                  user:
                    e.include && "boolean" == typeof e.include.user
                      ? e.include.user
                      : { ...a.include.user, ...(e.include || {}).user },
                },
              };
            return {
              name: r,
              setupOnce() {},
              processEvent(e, i, a) {
                const { transactionNamingScheme: r } = n,
                  { sdkProcessingMetadata: l = {} } = e,
                  c = l.request;
                if (!c) return e;
                const u =
                    l.requestDataOptionsFromExpressHandler ||
                    l.requestDataOptionsFromGCPWrapper ||
                    (function (e) {
                      const {
                          transactionNamingScheme: t,
                          include: { ip: n, user: s, ...i },
                        } = e,
                        o = [];
                      for (const [e, t] of Object.entries(i)) t && o.push(e);
                      let a;
                      if (void 0 === s) a = !0;
                      else if ("boolean" == typeof s) a = s;
                      else {
                        const e = [];
                        for (const [t, n] of Object.entries(s)) n && e.push(t);
                        a = e;
                      }
                      return {
                        include: {
                          ip: n,
                          user: a,
                          request: 0 !== o.length ? o : void 0,
                          transaction: t,
                        },
                      };
                    })(n),
                  m = t(e, c, u);
                if ("transaction" === e.type || "handler" === r) return m;
                const d = c._sentryTransaction;
                if (d) {
                  const e = (0, o.spanToJSON)(d).description || "",
                    t =
                      "sentry.javascript.nextjs" ===
                      (function (e) {
                        try {
                          return e.getOptions()._metadata.sdk.name;
                        } catch (e) {
                          return;
                        }
                      })(a)
                        ? e.startsWith("/api")
                        : "path" !== r,
                    [n] = (0, s.extractPathForTransaction)(c, {
                      path: !0,
                      method: t,
                      customRoute: e,
                    });
                  m.transaction = n;
                }
                return m;
              },
            };
          }),
          c = (0, i.convertIntegrationFnToClass)(r, l);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            DEFAULT_USER_INCLUDES: () => m,
            addRequestDataToEvent: () => g,
            addRequestDataToTransaction: () => d,
            extractPathForTransaction: () => p,
            extractRequestData: () => h,
            winterCGHeadersToDict: () => S,
            winterCGRequestToRequestData: () => b,
          });
        var s = n(146),
          i = n(6),
          o = n(9),
          a = n(7),
          r = n(30),
          l = n(63);
        const c = { ip: !1, request: !0, transaction: !0, user: !0 },
          u = ["cookies", "data", "headers", "method", "query_string", "url"],
          m = ["id", "username", "email"];
        function d(e, t, n) {
          if (e) {
            if (!e.metadata.source || "url" === e.metadata.source) {
              const [n, s] = p(t, { path: !0, method: !0 });
              e.updateName(n), e.setMetadata({ source: s });
            }
            e.setAttribute("url", t.originalUrl || t.url),
              t.baseUrl && e.setAttribute("baseUrl", t.baseUrl),
              e.setData("query", f(t, n));
          }
        }
        function p(e, t = {}) {
          const n = e.method && e.method.toUpperCase();
          let s = "",
            i = "url";
          t.customRoute || e.route
            ? ((s =
                t.customRoute ||
                `${e.baseUrl || ""}${e.route && e.route.path}`),
              (i = "route"))
            : (e.originalUrl || e.url) &&
              (s = (0, l.stripUrlQueryAndFragment)(
                e.originalUrl || e.url || "",
              ));
          let o = "";
          return (
            t.method && n && (o += n),
            t.method && t.path && (o += " "),
            t.path && s && (o += s),
            [o, i]
          );
        }
        function h(e, t) {
          const { include: n = u, deps: i } = t || {},
            a = {},
            l = e.headers || {},
            c = e.method,
            m = l.host || e.hostname || e.host || "<no host>",
            d =
              "https" === e.protocol || (e.socket && e.socket.encrypted)
                ? "https"
                : "http",
            p = e.originalUrl || e.url || "",
            h = p.startsWith(d) ? p : `${d}://${m}${p}`;
          return (
            n.forEach((t) => {
              switch (t) {
                case "headers":
                  (a.headers = l),
                    n.includes("cookies") || delete a.headers.cookie;
                  break;
                case "method":
                  a.method = c;
                  break;
                case "url":
                  a.url = h;
                  break;
                case "cookies":
                  a.cookies =
                    e.cookies ||
                    (l.cookie && (0, s.parseCookie)(l.cookie)) ||
                    {};
                  break;
                case "query_string":
                  a.query_string = f(e, i);
                  break;
                case "data":
                  if ("GET" === c || "HEAD" === c) break;
                  void 0 !== e.body &&
                    (a.data = (0, o.isString)(e.body)
                      ? e.body
                      : JSON.stringify((0, r.normalize)(e.body)));
                  break;
                default:
                  ({}).hasOwnProperty.call(e, t) && (a[t] = e[t]);
              }
            }),
            a
          );
        }
        function g(e, t, n) {
          const s = { ...c, ...(n && n.include) };
          if (s.request) {
            const i = Array.isArray(s.request)
              ? h(t, { include: s.request, deps: n && n.deps })
              : h(t, { deps: n && n.deps });
            e.request = { ...e.request, ...i };
          }
          if (s.user) {
            const n =
              t.user && (0, o.isPlainObject)(t.user)
                ? (function (e, t) {
                    const n = {};
                    return (
                      (Array.isArray(t) ? t : m).forEach((t) => {
                        e && t in e && (n[t] = e[t]);
                      }),
                      n
                    );
                  })(t.user, s.user)
                : {};
            Object.keys(n).length && (e.user = { ...e.user, ...n });
          }
          if (s.ip) {
            const n = t.ip || (t.socket && t.socket.remoteAddress);
            n && (e.user = { ...e.user, ip_address: n });
          }
          return (
            s.transaction &&
              !e.transaction &&
              (e.transaction = (function (e, t) {
                switch (t) {
                  case "path":
                    return p(e, { path: !0 })[0];
                  case "handler":
                    return (
                      (e.route &&
                        e.route.stack &&
                        e.route.stack[0] &&
                        e.route.stack[0].name) ||
                      "<anonymous>"
                    );
                  default:
                    return p(e, {
                      path: !0,
                      method: !0,
                      customRoute: e._reconstructedRoute
                        ? e._reconstructedRoute
                        : void 0,
                    })[0];
                }
              })(t, s.transaction)),
            e
          );
        }
        function f(e, t) {
          let n = e.originalUrl || e.url || "";
          if (n) {
            n.startsWith("/") && (n = `http://dogs.are.great${n}`);
            try {
              return (
                e.query ||
                ("undefined" != typeof URL && new URL(n).search.slice(1)) ||
                (t && t.url && t.url.parse(n).query) ||
                void 0
              );
            } catch (e) {
              return;
            }
          }
        }
        function S(e) {
          const t = {};
          try {
            e.forEach((e, n) => {
              "string" == typeof e && (t[n] = e);
            });
          } catch (e) {
            i.DEBUG_BUILD &&
              a.logger.warn(
                "Sentry failed extracting headers from a request object. If you see this, please file an issue.",
              );
          }
          return t;
        }
        function b(e) {
          const t = S(e.headers);
          return { method: e.method, url: e.url, headers: t };
        }
      },
      (e, t, n) => {
        "use strict";
        function s(e) {
          const t = {};
          let n = 0;
          for (; n < e.length; ) {
            const s = e.indexOf("=", n);
            if (-1 === s) break;
            let i = e.indexOf(";", n);
            if (-1 === i) i = e.length;
            else if (i < s) {
              n = e.lastIndexOf(";", s - 1) + 1;
              continue;
            }
            const o = e.slice(n, s).trim();
            if (void 0 === t[o]) {
              let n = e.slice(s + 1, i).trim();
              34 === n.charCodeAt(0) && (n = n.slice(1, -1));
              try {
                t[o] = -1 !== n.indexOf("%") ? decodeURIComponent(n) : n;
              } catch (e) {
                t[o] = n;
              }
            }
            n = i + 1;
          }
          return t;
        }
        n.r(t), n.d(t, { parseCookie: () => s });
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, { LinkedErrors: () => l, linkedErrorsIntegration: () => r });
        var s = n(100),
          i = n(142),
          o = n(34);
        const a = "LinkedErrors",
          r = (0, o.defineIntegration)((e = {}) => {
            const t = e.limit || 5,
              n = e.key || "cause";
            return {
              name: a,
              setupOnce() {},
              preprocessEvent(e, o, a) {
                const r = a.getOptions();
                (0, s.applyAggregateErrorsToEvent)(
                  i.exceptionFromError,
                  r.stackParser,
                  r.maxValueLength,
                  n,
                  t,
                  e,
                  o,
                );
              },
            };
          }),
          l = (0, o.convertIntegrationFnToClass)(a, r);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            FunctionToString: () => s.FunctionToString,
            InboundFilters: () => i.InboundFilters,
            LinkedErrors: () => o.LinkedErrors,
          });
        var s = n(4),
          i = n(35),
          o = n(147);
      },
      (e, t, n) => {
        "use strict";
        n.r(t),
          n.d(t, {
            Breadcrumbs: () => o.Breadcrumbs,
            Dedupe: () => l.Dedupe,
            GlobalHandlers: () => s.GlobalHandlers,
            HttpContext: () => r.HttpContext,
            LinkedErrors: () => a.LinkedErrors,
            TryCatch: () => i.TryCatch,
          });
        var s = n(98),
          i = n(89),
          o = n(90),
          a = n(99),
          r = n(102),
          l = n(101);
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s,
          i = (s = n(1)) && s.__esModule ? s : { default: s };
        t.default = class {
          static getAudioManager() {
            if (!this._audioManager) {
              const e = i.default.getProvider().get("rcp-fe-audio");
              this._audioManager = e.createAudioManager(
                "rcp-fe-lol-champ-select",
              );
            }
            return this._audioManager;
          }
          static createSound(e, t, n) {
            return this.getAudioManager().createSound(e, t, n);
          }
          static playSound(e, t, n) {
            return this.getAudioManager().playSound(e, t, n);
          }
          static dispose() {
            this._audioManager &&
              (this._audioManager.dispose(), (this._audioManager = null));
          }
        };
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default =
            t.PositionAssignmentPreloadVideos =
            t.PositionAssignmentPinVideos =
            t.MapVideos =
              void 0);
        var s = n(1),
          i = n(152);
        const { RunMixin: o } = s.EmberAddons.EmberLifeline;
        n(153);
        const a = {
          redIntro:
            "/fe/lol-champ-select/video/position-assignment-intro/map-north-intro.webm",
          blueIntro:
            "/fe/lol-champ-select/video/position-assignment-intro/map-south-intro.webm",
        };
        t.MapVideos = a;
        const r = {
          me: "/fe/lol-champ-select/video/position-assignment/Pin_Me_Intro(Fixed).webm",
          everyone:
            "/fe/lol-champ-select/video/position-assignment/Pin_Intro(Fixed).webm",
        };
        t.PositionAssignmentPinVideos = r;
        const l = [a.redIntro, a.blueIntro, r.me, r.everyone];
        t.PositionAssignmentPreloadVideos = l;
        var c = s.Ember.Component.extend(o, {
          classNames: ["position-assignment"],
          classNameBindings: [
            "isOnRedSide:top-right:bottom-left",
            "shouldPlayVideos:animation-enabled",
            "splashDefocus:defocussed:focussed",
            "hidePins",
          ],
          layout: n(154),
          champSelectSfxService: s.Ember.inject.service("champ-select-sfx"),
          _laneVideoTimeouts: [],
          _pinIntroVideoTimeouts: [],
          didReceiveAttrs: function () {
            if ((this._super(...arguments), this.element)) {
              const e = this.get("showPositionAssignment"),
                t = void 0 !== this.get("localSummoner");
              t && !this._wasInChampSelect && e
                ? (this._startVideoTimeout = this.runTask(
                    this.startPositionAssignment,
                    10,
                  ))
                : this._wasInChampSelect &&
                  !t &&
                  this.cleanupPositionAssignmentVideos(),
                (this._wasInChampSelect = t);
            }
          },
          startPositionAssignment: function () {
            const e = this.get("pinDropSummoners") || [];
            this.schedulePinDropSounds(e),
              this.get("shouldPlayVideos") &&
                this.element.querySelector(".map-intro-video").play(),
              e.forEach((e) => {
                if (!e.get("isPlaceholder")) {
                  const t = e.get("slotId"),
                    n = e.get("lane"),
                    s = (t + 1) * i.DURATIONS.pinAnimation + 130,
                    o = (t + 1) * i.DURATIONS.pinAnimation;
                  this._laneVideoTimeouts.push(
                    this.runTask(() => this.playLaneVideo(n), o),
                  ),
                    this._pinIntroVideoTimeouts.push(
                      this.runTask(() => this.playPinIntroVideo(t), s),
                    );
                }
              });
          },
          schedulePinDropSounds(e) {
            const t = e.map((e) => {
              const t = e.get("slotId");
              return {
                eventType: e.get("isLocalSummoner")
                  ? "pin-drop-local-player"
                  : `pin-drop-ally-${t}`,
                delayMillis: 700 * (t + 1) + 10,
              };
            });
            this.get("champSelectSfxService").handleSfxNotifications(t);
          },
          playLaneVideo(e) {
            if (!this.get("shouldPlayVideos")) return;
            const t = this.get("mapSide"),
              n = this.element.querySelector(`.lane-intro-video.${t}-${e}`);
            n && ((n.currentTime = 0), n.play());
          },
          playPinIntroVideo(e) {
            if (this.get("shouldPlayVideos")) {
              const t = this.element.querySelector(
                `.position-assignment-pin.slot-${e} .pin-intro-video`,
              );
              t && ((t.style.visibility = "visible"), t.play());
            } else {
              const t = this.element.querySelector(
                `.position-assignment-pin.slot-${e} .pin-static-image`,
              );
              t && (t.style.visibility = "visible");
            }
            const t = this.element.querySelector(
              `.position-assignment-pin.slot-${e} .pin-position-icon`,
            );
            t && (t.style.visibility = "visible");
          },
          cleanupPositionAssignmentVideos: function () {
            this.cancelTask(this._startVideoTimeout),
              this._laneVideoTimeouts.forEach((e) => this.cancelTask(e)),
              this._pinIntroVideoTimeouts.forEach((e) => this.cancelTask(e)),
              (this._laneVideoTimeouts = []),
              (this._pinIntroVideoTimeouts = []),
              (this.get("pinDropSummoners") || []).forEach((e) => {
                const t = e.get("slotId"),
                  n = this.element.querySelector(
                    `.position-assignment-pin.slot-${t} .pin-intro-video`,
                  );
                n && (n.style.visibility = "hidden");
                const s = this.element.querySelector(
                  `.position-assignment-pin.slot-${t} .pin-static-image`,
                );
                s && (s.style.visibility = "hidden");
                const i = this.element.querySelector(
                  `.position-assignment-pin.slot-${t} .pin-position-icon`,
                );
                i && (i.style.visibility = "hidden");
              });
          },
          isOnRedSide: s.Ember.computed("mapSide", function () {
            return "red" === this.get("mapSide");
          }),
          mapIntroPath: s.Ember.computed("isOnRedSide", function () {
            return this.get("isOnRedSide") ? a.redIntro : a.blueIntro;
          }),
          localSummoner: s.Ember.computed(
            "pinDropSummoners.@each.isLocalSummoner",
            function () {
              return (this.get("pinDropSummoners") || []).find((e) =>
                e.get("isLocalSummoner"),
              );
            },
          ),
          localSummonerSlotClass: s.Ember.computed(
            "localSummoner.slotId",
            function () {
              return `slot-id-${this.get("localSummoner.slotId")}`;
            },
          ),
          assignedPositionLabel: s.Ember.computed(
            "localSummoner.position",
            function () {
              const e = this.get("localSummoner.position");
              return this.get(`tra.summoner_assigned_position_${e}`);
            },
          ),
          isMapIntroVisible: s.Ember.computed(
            "shouldPlayVideos",
            "showPositionAssignment",
            function () {
              return (
                this.get("showPositionAssignment") &&
                this.get("shouldPlayVideos")
              );
            },
          ),
        });
        t.default = c;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.skinProductTypes =
            t.VOTE_MAJORITY_THRESHOLD =
            t.TIMER_PHASES =
            t.SUMMONER_OBJECT_SIZE =
            t.STANDARD_MAX_TEAM_SIZE =
            t.SOUNDS_PATH =
            t.SFX_CHANNEL =
            t.SCREENS =
            t.RUNES =
            t.RANDOM_CHAMP =
            t.QUEST_SKIN_TAG =
            t.POSITION_TOP =
            t.POSITION_SUPPORT =
            t.POSITION_NONE =
            t.POSITION_MIDDLE =
            t.POSITION_JUNGLE =
            t.POSITION_BOTTOM =
            t.POSITION_ANY =
            t.POSITIONS =
            t.NONE_CHAMP_ID =
            t.NEXUS_BLITZ_QUEUE_IDS =
            t.NAME_VISIBILITY_TYPE =
            t.MINUTE_SECOND_TIME_DISPLAY_THRESHOLD_MS =
            t.INVALID_SPELL_ID =
            t.GAME_MODES_WITH_SUBTEAMS =
            t.GAME_MODES_WITH_NO_BAN_DELAY_TIMERS =
            t.GAME_MODES_WITH_COMPANIONS =
            t.GAME_MODES_WITH_CHEST_AVAILABILITY_ENABLED =
            t.GAMEFLOW_PHASE_CHAMP_SELECT =
            t.FINALIZATION_PHASE_CEREMONIES =
            t.DURATIONS =
            t.DRAFT_PICK_MODES =
            t.DISCONNECT_ERROR_INDICATORS =
            t.DEFAULT_DISCONNECT_SHOULD_EXIT_DELAY_MS =
            t.DEFAULT_DISCONNECT_DELAY_MS =
            t.CHAMP_SELECT_PAW_SOURCE =
            t.CHAMPION_BENCH_SWAP_COOLDOWN_MS =
            t.CHAMPION_BENCH_SOUND_COOLDOWN_MS =
            t.CHAMPION_BENCH_SIZE =
            t.CHAMPION_BENCH_NON_PRIORITISED_PREFILL_COOLDOWN_MS =
            t.CHAMPION_BENCH_ALLY_SWAP_COOLDOWN_MS =
            t.CEREMONIES =
              void 0);
        t.SCREENS = {
          pick: "pick-screen",
          banShowcase: "ban-showcase-screen",
          selected: "selected-screen",
          positionAssignment: "position-assignment-screen",
          gameStarting: "game-starting-screen",
        };
        t.TIMER_PHASES = {
          planning: "PLANNING",
          banPick: "BAN_PICK",
          finalization: "FINALIZATION",
          gameStarting: "GAME_STARTING",
        };
        t.GAMEFLOW_PHASE_CHAMP_SELECT = "ChampSelect";
        t.DURATIONS = {
          teamBansAnimationDelayBeforeBanItem: 1750,
          tenBansReveal: 6400,
          tenBansAnimationDelayBetweenEnemyBans: 650,
          tenBansAnimationDelayBeforeEnemyBans: 500,
          tenBansAnimationDelayBeforePickSnipeSound: 750,
          pinAnimation: 630,
          pickPhaseChangeTransition: 1e3,
          pickIntentSeconds: 15,
          actionSoundThreshold: 10,
          showLockedInSplash: 1700,
          timeBeforeShowingReportingTooltipSec: 3,
          timeBeforeHidingReportingTooltipSec: 8,
        };
        const n = {
          tenBansReveal: "ten_bans_reveal",
          tenBansRevealOld: "TEN_BANS_REVEAL",
          phaseTransition: "phase_transition",
          voteTransition: "vote_transition",
          voteReveal: "team_vote_reveal",
        };
        t.CEREMONIES = n;
        const s = [n.voteTransition, n.voteReveal];
        t.FINALIZATION_PHASE_CEREMONIES = s;
        t.RANDOM_CHAMP = { championId: -2 };
        t.NONE_CHAMP_ID = -1;
        t.NEXUS_BLITZ_QUEUE_IDS = [1300, 1301, 1302, 1303, 1304];
        const i = Object.freeze({ ARAM: !0, KINGPORO: !0 });
        t.GAME_MODES_WITH_COMPANIONS = i;
        t.GAME_MODES_WITH_CHEST_AVAILABILITY_ENABLED = ["ARAM"];
        const o = Object.freeze({ CHERRY: !0 });
        t.GAME_MODES_WITH_NO_BAN_DELAY_TIMERS = o;
        t.GAME_MODES_WITH_SUBTEAMS = {
          CHERRY: {
            teamSize: 2,
            teamSizeLabel: "cherry_map_size_label",
            subteams: [
              {
                cellIds: [0, 1],
                display: {
                  label: "cherry_subteam_display_name_poro",
                  icon: "/fe/lol-champ-select/images/subteams/Poro.png",
                },
              },
              {
                cellIds: [2, 3],
                display: {
                  label: "cherry_subteam_display_name_minion",
                  icon: "/fe/lol-champ-select/images/subteams/Minion.png",
                },
              },
              {
                cellIds: [4, 5],
                display: {
                  label: "cherry_subteam_display_name_scuttle",
                  icon: "/fe/lol-champ-select/images/subteams/Scuttle.png",
                },
              },
              {
                cellIds: [6, 7],
                display: {
                  label: "cherry_subteam_display_name_krug",
                  icon: "/fe/lol-champ-select/images/subteams/Krug.png",
                },
              },
              {
                cellIds: [8, 9],
                display: {
                  label: "cherry_subteam_display_name_raptor",
                  icon: "/fe/lol-champ-select/images/subteams/Raptor.png",
                },
              },
              {
                cellIds: [10, 11],
                display: {
                  label: "cherry_subteam_display_name_sentinel",
                  icon: "/fe/lol-champ-select/images/subteams/Sentinel.png",
                },
              },
              {
                cellIds: [12, 13],
                display: {
                  label: "cherry_subteam_display_name_wolf",
                  icon: "/fe/lol-champ-select/images/subteams/Wolf.png",
                },
              },
              {
                cellIds: [14, 15],
                display: {
                  label: "cherry_subteam_display_name_gromp",
                  icon: "/fe/lol-champ-select/images/subteams/Gromp.png",
                },
              },
            ],
          },
        };
        t.INVALID_SPELL_ID = -1;
        t.SUMMONER_OBJECT_SIZE = 80;
        t.MINUTE_SECOND_TIME_DISPLAY_THRESHOLD_MS = 1e5;
        t.POSITION_TOP = "top";
        const a = "jungle";
        t.POSITION_JUNGLE = a;
        const r = "middle";
        t.POSITION_MIDDLE = r;
        const l = "bottom";
        t.POSITION_BOTTOM = l;
        const c = "support";
        t.POSITION_SUPPORT = c;
        const u = ["top", a, r, l, c];
        t.POSITIONS = u;
        t.POSITION_NONE = "NONE";
        t.POSITION_ANY = "any";
        t.DRAFT_PICK_MODES = [
          "DraftModeSinglePickStrategy",
          "TeamBuilderSimulBanStrategy",
          "TeamBuilderDraftPickStrategy",
          "TournamentPickStrategy",
        ];
        t.RUNES = {
          minChooseRunesEnabledLevel: 8,
          maxTutorialHighlightSeenCount: 9,
          tutorialHighlightActionSeenCountIncrement: 2,
          tutorialHighlightDelay: 5e3,
        };
        t.SOUNDS_PATH = "/fe/lol-champ-select/sounds";
        t.SFX_CHANNEL = "sfx-ui";
        t.STANDARD_MAX_TEAM_SIZE = 5;
        t.VOTE_MAJORITY_THRESHOLD = 0.6;
        t.CHAMP_SELECT_PAW_SOURCE = "champSelect";
        t.CHAMPION_BENCH_SIZE = 10;
        t.CHAMPION_BENCH_SWAP_COOLDOWN_MS = 3e3;
        t.CHAMPION_BENCH_NON_PRIORITISED_PREFILL_COOLDOWN_MS = 1e4;
        t.CHAMPION_BENCH_ALLY_SWAP_COOLDOWN_MS = 600;
        t.CHAMPION_BENCH_SOUND_COOLDOWN_MS = 3e3;
        t.QUEST_SKIN_TAG = "quest-skin";
        t.DISCONNECT_ERROR_INDICATORS = [
          "Failed to deserialize response payload",
          ": GROUP_NOT_FOUND",
          ": Timeout",
          ": SERVICE UNAVAILABLE",
        ];
        t.DEFAULT_DISCONNECT_DELAY_MS = 6e3;
        t.DEFAULT_DISCONNECT_SHOULD_EXIT_DELAY_MS = 4e4;
        t.NAME_VISIBILITY_TYPE = {
          VISIBLE: "VISIBLE",
          HIDDEN: "HIDDEN",
          UNHIDDEN: "UNHIDDEN",
        };
        t.skinProductTypes = {
          kQuestSkin: "kQuestSkin",
          kTieredSkin: "kTieredSkin",
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "O4ZhbbdT",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\position-assignment-intro-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\position-assignment-intro-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\position-assignment-intro-component\\\\index.js\\" "],["text","\\n\\n"],["open-element","img",[]],["static-attr","class","map-static-image"],["dynamic-attr","src",["concat",[["unknown",["mapStaticPath"]]]]],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["dynamic-attr","class",["concat",["map-intro-video ",["helper",["if"],[["get",["isMapIntroVisible"]],"visible","hidden"],null]]]],["dynamic-attr","src",["unknown",["mapIntroPath"]],null],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video blue-top"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_South_Top.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video blue-jungle"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_South_Jungle.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video blue-middle"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_South_Mid.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video blue-bottom"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_South_Bot.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video red-top"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_North_Top.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video red-jungle"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_North_Jungle.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video red-middle"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_North_Mid.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n"],["open-element","video",[]],["static-attr","class","lane-intro-video red-bottom"],["static-attr","src","/fe/lol-champ-select/video/position-assignment/Path_North_Bot.webm"],["static-attr","preload","auto"],["flush-element"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["position-text ",["helper",["if"],[["get",["showPositionAssignment"]],"visible","hidden"],null]," ",["unknown",["localSummonerSlotClass"]]]]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","position-assignment-title"],["flush-element"],["text","\\n    "],["append",["unknown",["tra","assigned_position_title"]],false],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","position-assignment-label"],["flush-element"],["text","\\n    "],["append",["unknown",["assignedPositionLabel"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["block",["unless"],[["get",["hidePins"]]],null,1]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","div",[]],["dynamic-attr","class",["concat",["position-assignment-pin slot-",["unknown",["summoner","slotId"]]," ",["helper",["if"],[["get",["summoner","isLocalSummoner"]],"is-self"],null]," ",["unknown",["mapSide"]]," ",["helper",["if"],[["get",["summoner","isPlaceholder"]],"hidden","visible"],null]," ",["unknown",["summoner","lane"]],"-",["unknown",["summoner","lanePosition"]]]]],["flush-element"],["text","\\n        "],["open-element","video",[]],["static-attr","class","pin-intro-video"],["dynamic-attr","src",["helper",["if"],[["get",["summoner","isLocalSummoner"]],"/fe/lol-champ-select/video/position-assignment/Pin_Me_Intro(Fixed).webm","/fe/lol-champ-select/video/position-assignment/Pin_Intro(Fixed).webm"],null],null],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","pin-container"],["flush-element"],["text","\\n          "],["open-element","div",[]],["dynamic-attr","class",["concat",["pin-static-image ",["helper",["unless"],[["get",["showPositionAssignment"]],"static"],null]]]],["flush-element"],["close-element"],["text","\\n          "],["open-element","div",[]],["dynamic-attr","class",["concat",["pin-position-icon ",["unknown",["summoner","position"]]]]],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":["summoner"]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","position-assignment-pins"],["flush-element"],["text","\\n"],["block",["each"],[["get",["pinDropSummoners"]]],null,0],["text","  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.useEmotesApi = function (e) {
            return s.default
              .getProvider()
              .getOptional("rcp-fe-lol-collections")
              .then(
                (t) => e(t.getEmotePanelApi()),
                (e) => s.logger.error("Provider getOptional failure", e),
              );
          }),
          (t.usePerksApi = function (e) {
            return s.default
              .getProvider()
              .getOptional("rcp-fe-lol-collections")
              .then(
                (t) => e(t.perksApi()),
                (e) => s.logger.error("Provider getOptional failure", e),
              );
          });
        var s = (function (e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var n = i(t);
          if (n && n.has(e)) return n.get(e);
          var s = {},
            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a in e)
            if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
              var r = o ? Object.getOwnPropertyDescriptor(e, a) : null;
              r && (r.get || r.set)
                ? Object.defineProperty(s, a, r)
                : (s[a] = e[a]);
            }
          (s.default = e), n && n.set(e, s);
          return s;
        })(n(1));
        function i(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (i = function (e) {
            return e ? n : t;
          })(e);
        }
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1);
        t.default = class {
          constructor(e, t) {
            (this._screenRoot = e),
              (this._gameflowBinding = (0, s.DataBinding)(
                "/lol-gameflow",
                (0, s.getProvider)().getSocket(),
              )),
              t.registerReplacementChampSelectHandler(
                (e) => e && e.skipChampionSelect,
                this.show.bind(this),
                this.hide.bind(this),
              ),
              (this._bgElement = document.createElement("div")),
              this._screenRoot.getElement().appendChild(this._bgElement);
          }
          show() {
            this.isShown ||
              this._getModeBgPath().then((e) => {
                (this._bgElement.style = `background-image: url(${e}); width: 1280px; height: 720px; top: 0; left: 0;`),
                  this._screenRoot.bump(),
                  (this.isShown = !0);
              });
          }
          hide() {
            return (
              this.isShown && (this._screenRoot.release(), (this.isShown = !1)),
              !0
            );
          }
          _getModeBgPath() {
            return this._gameflowBinding
              .get("/v1/session")
              .then(
                (e) =>
                  (e &&
                    e.map &&
                    e.map.assets &&
                    e.map.assets["champ-select-skip-bg"]) ||
                  "",
              );
          }
        };
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createRootComponent = l),
          (t.default = function (e) {
            const t = i.default
                .getProvider()
                .get("rcp-fe-lol-l10n")
                .tra()
                .overlay("/fe/lol-l10n/trans.json")
                .overlay("/fe/lol-champ-select/trans.json"),
              n = (0, i.EmberL10n)(i.Ember, t);
            return o.default.useTra(t), l(n, e);
          });
        var s,
          i = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = r(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          o = (s = n(158)) && s.__esModule ? s : { default: s },
          a = n(159);
        function r(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (r = function (e) {
            return e ? n : t;
          })(e);
        }
        i.Lodash;
        function l(e, t) {
          const n = (0, a.getEmberApplicationArguments)(e, t);
          return i.default.EmberApplicationFactory.create(
            a.EMBER_APP_NAME,
            null,
            n,
            e,
            { EMBER_CLI_COMPAT: !0 },
          );
        }
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        const s = n(1),
          { Ember: i, logger: o } = s,
          a = s.UiKitPlugin.getModalManager();
        var r = new (class {
          constructor() {
            this._errorsShown = {};
          }
          _requestErrorHandler(e, t, n) {
            if (((e = e || "error_generic"), !this._errorsShown[e])) {
              this._errorsShown[e] = !0;
              const { tra: n } = this;
              if (n && n.get) {
                let s = n.get(e);
                0 === t.statusCode().readyState
                  ? (s += " " + n.get("error_network_try_again"))
                  : (s += " " + n.get("error_unknown_try_again"));
                a.add({
                  type: "DialogAlert",
                  data: {
                    contents: s,
                    okText: n.get("lib_ui_dialog_alert_ok"),
                  },
                }).okPromise.then(() => {
                  delete this._errorsShown[e];
                });
              }
            }
            o.error("Failed request, url=" + n.url, t);
          }
          _run(e, t) {
            let n;
            "object" == typeof t[0]
              ? (o.trace("_run request", t[0]),
                (n = t[0].errorMessage),
                delete t[0].errorMessage)
              : "object" == typeof t[1] &&
                (o.trace("_run request", t[1]),
                (n = t[1].errorMessage),
                delete t[1].errorMessage);
            const s = function (e, t) {
              this._requestErrorHandler(n, e, t);
            }.bind(this);
            return Promise.resolve(
              i.$.when(e(...t))
                .then(function (e, t, n) {
                  return (
                    n &&
                      (e
                        ? o.trace("_run response", {
                            url: this.url,
                            status: n.status,
                            data: e,
                          })
                        : o.trace("_run response", {
                            url: this.url,
                            status: n.status,
                          })),
                    e
                  );
                })
                .fail(function (e) {
                  2 !== Math.floor(e.status / 100)
                    ? s(e, this)
                    : o.trace("_run response fail", {
                        url: this.url,
                        status: e.status,
                      });
                }),
            );
          }
          ajax() {
            return this._run(i.$.ajax, arguments);
          }
          post() {
            return this._run(i.$.post, arguments);
          }
          useTra(e) {
            this.tra = e;
          }
        })();
        t.default = r;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.EMBER_APP_NAME = void 0),
          (t.getEmberApplicationArguments = function (e, t = null) {
            return (function (e, t = null) {
              const l = s.Navigation.getMissionsButton();
              let h = {
                name: p,
                rootElement: t,
                tra: e,
                componentFactory: s.ComponentFactory,
                Router: n(184),
                ApplicationRoute: o.default,
                IndexRoute: a.default,
                ApplicationController: i.default,
                ChampSelectRootComponent: r.default,
                ActionButtonComponent: n(185),
                BanShowcaseComponent: n(188),
                BansContainerComponent: n(191),
                BoostNotificationComponent: n(172),
                ButtonMaskIconComponent: c,
                ChampionShowcaseTeamComponent: n(194),
                ChampionShowcaseItemComponent: n(197),
                ChampionBenchComponent: n(199),
                ChampionBenchItemComponent: n(202),
                ChampionChestAvailabilityComponent: n(205),
                ChampionGridComponent: n(208),
                ChampionGridChampionComponent: n(218),
                ChampionSplashBackgroundComponent: n(220),
                ChampionSplashRingComponent: n(224),
                ChromaModalComponent: n(227),
                DisconnectNotificationComponent: n(230),
                EmotesEditComponent: n(233),
                FramedIconButtonComponent: u,
                FlyoutSelectorPopupButtonComponent: n(238),
                FlyoutSelectorTriggerButtonComponent: n(241),
                FullScreenModalComponent: n(234),
                GameEventInfoCardComponent: n(244).default,
                GameInfoComponent: n(247),
                LockInButtonComponent: n(250),
                LoadoutsEditComponent: n(253).default,
                PerkPageTooltipComponent: m,
                PerksPageDropdownComponent: n(256),
                PerksPageDropdownOptionComponent: n(259),
                PhaseTransitionComponent: n(262),
                PickBanRingComponent: n(265),
                PickPhaseComponent: n(268),
                PlayerNameComponent: d,
                PlayerNameWrapperComponent: n(271),
                PositionAssignmentIntroComponent: n(151).default,
                QuitButtonComponent: n(273),
                RerollButtonComponent: n(276),
                RingGearComponent: n(279),
                RuneRecommenderButtonComponent: n(282).default,
                SkinButtonComponent: n(284),
                SkinCarouselComponent: n(287),
                SkinNameComponent: n(290),
                SkinPurchaseButtonComponent: n(293),
                SkinSelectComponent: n(296),
                SummonerArrayComponent: n(299),
                SummonerOverlayComponent: n(302),
                SummonerObjectComponent: n(308),
                SummonerSpellPopupComponent: n(312),
                SummonerSpellSelectComponent: n(314),
                SummonerTimerComponent: n(317),
                TeamBansComponent: n(320),
                TeamBansItemComponent: n(323),
                TeamBoostButtonComponent: n(326),
                TeamBoostModalComponent: n(329),
                TimerStatusComponent: n(332),
                TradeButtonComponent: n(335),
                TradeDialogComponent: n(176).default,
                SwapButtonComponent: n(338),
                SwapDialogComponent: n(341).default,
                WardSkinPopupComponent: n(344),
                WardSkinSelectComponent: n(347),
                MissionsButtonComponent: l.MissionsButtonComponent,
                MissionsTrackerComponent: n(350),
                VoteRevealComponent: n(353),
                AnimationDispatcherService: n(221).default,
                ChampSelectSfxService: n(356).default,
                ChampSelectDisconnectService: n(358).default,
                ChampSelectInventoryService: n(359).default,
                InventoryService: n(360).default,
                ChatPublisherService: n(361).default,
                LoadoutsService: n(362).default,
                SkinPurchaseService: n(363).default,
                SummonerInfoService: n(382).default,
                PlayerReportService: n(383).default,
                MissionsService: l.MissionsService,
                TEMPLATES: { application: n(384), index: n(385) },
              };
              return (
                (h =
                  s.SharedEmberComponents.EmberCollectionApi.registerToFactoryDefinition(
                    h,
                  )),
                h
              );
            })(e, t);
          });
        var s = n(1),
          i = l(n(160)),
          o = l(n(161)),
          a = l(n(162)),
          r = l(n(163));
        function l(e) {
          return e && e.__esModule ? e : { default: e };
        }
        const {
            ButtonMaskIconComponent: c,
            FramedIconButtonComponent: u,
            PerkPageTooltipComponent: m,
            PlayerNameComponent: d,
          } = s.SharedComponents.getSharedEmberComponents(),
          p = "rcp-fe-lol-champ-select";
        t.EMBER_APP_NAME = p;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1).Ember.Controller.extend({
          init: function () {
            this._super(...arguments);
          },
        });
        t.default = s;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1);
        const i = [
          (0, s.DataBinding)("/lol-gameflow/v1/session").get(),
          (0, s.DataBinding)("/lol-champ-select/v1/session").get(),
          (0, s.DataBinding)(
            "/lol-champ-select/v1/pickable-champion-ids",
          ).get(),
          (0, s.DataBinding)("/lol-champ-select/v1/team-boost").get(),
          (0, s.DataBinding)("/lol-summoner/v1/current-summoner").get(),
          (0, s.DataBinding)("/lol-inventory/v1/wallet/RP").get(),
          (0, s.DataBinding)("/lol-inventory/v2/inventory/WARD_SKIN").get(),
          (0, s.DataBinding)("/lol-login/v1/session").get(),
          (0, s.DataBinding)("/lol-lobby/v2/comms/members").get(),
          (0, s.DataBinding)(
            "/lol-game-data/assets/v1/summoner-spells.json",
          ).get(),
          (0, s.DataBinding)("/lol-game-data/assets/v1/ward-skins.json").get(),
          (0, s.DataBinding)("/lol-platform-config/v1/namespaces").get(),
          (0, s.DataBinding)("/lol-perks/v1/perks").get(),
          (0, s.DataBinding)("/lol-perks/v1/pages").get(),
          (0, s.DataBinding)("/lol-perks/v1/styles").get(),
          (0, s.DataBinding)("/lol-perks/v1/currentpage").get(),
          (0, s.DataBinding)("/lol-perks/v1/settings").get(),
          (0, s.DataBinding)("/lol-chat/v1/conversations").get(),
          (0, s.DataBinding)("/entitlements/v1/token").get(),
          (0, s.DataBinding)("/lol-settings/v1/account/lol-tutorial").get(),
          (0, s.DataBinding)("/lol-loadouts/v4/loadouts/scope/account").get(),
        ];
        var o = s.Ember.Route.extend({
          model() {
            const e = Promise.all(i),
              t = new Promise((e) => {
                setTimeout(function () {
                  e();
                }, 1e3);
              });
            return Promise.race([e, t])
              .then(() => null)
              .catch(() => null);
          },
        });
        t.default = o;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1).Ember.Route.extend({ model() {} });
        t.default = s;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = c(n(164)),
          o = c(n(150)),
          a = c(n(175)),
          r = n(152),
          l = n(176);
        function c(e) {
          return e && e.__esModule ? e : { default: e };
        }
        const { RunMixin: u, DomMixin: m } = s.EmberAddons.EmberLifeline,
          d = s.UiKitPlugin.getModalManager(),
          p = s.PremadeVoice.voiceButton({ position: "left" }),
          h = s.ViewportPlugin.fullScreen().getScreenRoot(
            "rcp-fe-lol-champ-select",
          );
        n(179), n(180);
        const g = n(181),
          f = s.Lodash,
          S = [0, 1, 2, 3, 4],
          b = S.concat([5, 6, 7, 8, 9]),
          y = [...Array(16).keys()],
          _ = [
            "name_visibility_type_team_hidden_gromp",
            "name_visibility_type_team_hidden_krug",
            "name_visibility_type_team_hidden_murk_wolf",
            "name_visibility_type_team_hidden_raptor",
            "name_visibility_type_team_hidden_scuttle_crab",
          ];
        var v = s.Ember.Component.extend(u, m, i.default, a.default, {
          classNames: ["champion-select"],
          classNameBindings: [
            "showEntryAnimation:entry-animation",
            "showPreAnimation:pre-animation",
            "champSelectScreen",
            "sessionActions.hasBans:has-bans",
            "currentSummoner.isActingNow:is-acting-now",
            "currentSummoner.isPickingNow:is-picking-now",
            "currentSummoner.isExclusivelyPickIntenting:is-pick-intenting-now",
            "showCurrentSummonerBanning:is-banning-now",
            "sessionActions.currentBanAction:is-current-action",
            "isShowingGrid:is-showing-grid",
            "isSpectating",
            "session.timer.timerLessThan11Seconds:timer-less-than-11-seconds",
            "uxSettings.largeAreaAnimationsEnabled:large-area-animations:no-large-area-animations",
          ],
          layout: n(182),
          isShown: !1,
          isAnimatingIntro: !1,
          showChestAvailabilityHintedPortraits: !1,
          sentGameStartingMessageId: null,
          animationDispatcher: s.Ember.inject.service("animation-dispatcher"),
          chatPublisherService: s.Ember.inject.service("chat-publisher"),
          champSelectSfxService: s.Ember.inject.service("champ-select-sfx"),
          champSelectDisconnectService: s.Ember.inject.service(
            "champ-select-disconnect",
          ),
          summonerInfoService: s.Ember.inject.service("summoner-info"),
          inventoryService: s.Ember.inject.service("inventory"),
          myTeamSummonerIdsToNames: {},
          myTeamObfuscatedSummonerIdsSet: {},
          boostToastOpen: s.Ember.computed.alias("teamBoost.boostToastOpen"),
          boostToastData: s.Ember.computed.alias("teamBoost.boostToastData"),
          boosterSummonerId: s.Ember.computed.alias("teamBoost.summonerId"),
          model: null,
          tra: s.Ember.inject.service(),
          root: null,
          init: function () {
            this._super(...arguments),
              (this._playerNames = s.playerNames),
              this.uxSettingsInit(),
              (this.recordDidRequestSucceed =
                this._recordDidRequestSucceed.bind(this));
            this.set("sessionActions", n(183).create({ root: this })),
              s.Telemetry.startTracingEvent(
                "champ-select-init-ember-app-settle",
              ),
              this.get("chatPublisherService").registerSessionChangeCallback(
                "game-starting",
                this.gameStartDelayedSysMessage.bind(this),
              ),
              this.get("champSelectSfxService").initDataBindings(),
              this.initChatBindings(),
              this.initChampSelectBindings();
          },
          didReceiveAttrs() {
            this._super(...arguments);
          },
          didInsertElement: function () {
            this._super(...arguments), this.setupShowHandler();
          },
          didRender() {
            this._super(...arguments),
              this._endPerformanceMeasurement &&
                this.debounceTask("_endPerformanceMeasurement", 250);
          },
          willDestroyElement: function () {
            this._super(...arguments),
              this.uxSettingsDestroy(),
              this.set("isShown", !1),
              this._hideDisconnectNotification(),
              this._deleteDelayedShowDisconnectNotificationIfExists(),
              h.off("show", this._showHandler),
              h.off("hide", this._hideHandler);
          },
          _endPerformanceMeasurement() {
            s.Telemetry.endTracingEvent("champ-select-init-ember-app-settle"),
              (this._endPerformanceMeasurement = null);
          },
          initChatBindings: function () {
            (this._chatBinding = (0, s.DataBinding)(
              "/lol-chat",
              (0, s.getProvider)().getSocket(),
            )),
              this._chatBinding.observe(
                "v1/obfuscated-summoner-ids",
                this,
                this.handleChatObfuscatedSummonerIds,
              );
          },
          initChampSelectBindings: function () {
            (this._champSelectBinding = (0, s.DataBinding)(
              "/lol-champ-select",
              (0, s.getProvider)().getSocket(),
            )),
              this._champSelectBinding.observe(
                "/v1/ongoing-trade",
                this,
                this.handleOngoingTrade,
              ),
              this._champSelectBinding.observe(
                "/v1/ongoing-swap",
                this,
                this.handleOngoingSwap,
              ),
              this._champSelectBinding.observe(
                "/v1/pin-drop-notification",
                this,
                this.handlePinDropNotification,
              ),
              this._champSelectBinding.observe(
                "/v1/all-grid-champions",
                this,
                this.handleGridChampionsUpdated,
              ),
              this._initSummonerObservers();
          },
          handleChatObfuscatedSummonerIds(e) {
            s.logger.info(
              "champSelect received chatObfuscatedSummonerIds: " + e,
            ),
              this.set(
                "chatObfuscatedSummonerIds",
                (e || []).map((e) => e.toString()),
              ),
              this._checkIfShouldShowChatRoom();
          },
          _initSummonerObservers: function () {
            (this.summonerBySlotId = {}),
              y.forEach((e) => {
                (this.summonerBySlotId[e] = s.Ember.Object.create()),
                  this._champSelectBinding.observe(
                    `/v1/summoners/${e}`,
                    this,
                    (t) => this.handleSummoner(t, e),
                  );
              });
          },
          myTeamSummoners: s.Ember.computed(
            "gameModeSubteamMetadata",
            function () {
              const e = (this.get("gameModeSubteamMetadata.allSlotIds") || b)
                .filter((e) => this._isSummonerSlotIdInMyTeam(e))
                .map((e) => this.summonerBySlotId[e]);
              return s.Ember.A(e);
            },
          ),
          theirTeamSummoners: s.Ember.computed(
            "gameModeSubteamMetadata",
            function () {
              const e = (this.get("gameModeSubteamMetadata.allSlotIds") || b)
                .filter((e) => !this._isSummonerSlotIdInMyTeam(e))
                .map((e) => this.summonerBySlotId[e]);
              return s.Ember.A(e);
            },
          ),
          _isSummonerSlotIdInMyTeam: function (e) {
            const t = this.get("subteamDataList");
            if (!t) return S.includes(e);
            const n = t.find((t) => t.cellIds.includes(e));
            return !!n && n.isLocalSubteam;
          },
          _getHiddenName: function (e, t, n) {
            const s = this.get("tra");
            if (!n) return this._getEnemyName(s, e.slotId);
            if (
              t === r.NAME_VISIBILITY_TYPE.HIDDEN ||
              t === r.NAME_VISIBILITY_TYPE.UNHIDDEN
            ) {
              const t = (e.slotId || 0) % _.length,
                n = _[t] || "";
              return s.get(n) || "";
            }
            return "";
          },
          handleSummoner: function (e, t) {
            if (e) {
              this.summonerBySlotId[t].setProperties(e);
              const n = this._isSummonerSlotIdInMyTeam(
                  t,
                  this.get("session.localPlayerCellId"),
                ),
                s =
                  e.nameVisibilityType && e.nameVisibilityType.length > 0
                    ? e.nameVisibilityType
                    : r.NAME_VISIBILITY_TYPE.VISIBLE,
                i = this._getDisplayNamePromise(e, n, s),
                o = this._getHiddenName(e, s, n),
                a = this._getPuuidPromise(e, n, s);
              this.summonerBySlotId[t].set("isSummonerInMyTeam", n),
                this.summonerBySlotId[t].set("nameVisibilityType", s),
                this.summonerBySlotId[t].set("hiddenName", o),
                Promise.all([i, a]).then((i) => {
                  const o = i[0],
                    a = i[1];
                  if (
                    (this.summonerBySlotId[t].set("displayName", o),
                    this.summonerBySlotId[t].set("puuid", a),
                    n)
                  ) {
                    if (!e.obfuscatedSummonerId && !e.summonerId) return;
                    e.obfuscatedSummonerId
                      ? ((this.myTeamObfuscatedSummonerIdsSet[
                          e.obfuscatedSummonerId
                        ] = !0),
                        (this.myTeamSummonerIdsToNames[e.obfuscatedSummonerId] =
                          o))
                      : (this.myTeamSummonerIdsToNames[e.summonerId] = o),
                      this._checkIfShouldShowChatRoom(s);
                  }
                });
            }
          },
          _getDisplayNamePromise: async function (e, t, n) {
            const s = this.get("tra"),
              i =
                this.myTeamSummonerIdsToNames[e.obfuscatedSummonerId] ||
                this.myTeamSummonerIdsToNames[e.summonerId];
            if (i && i.length > 0) return i;
            if (!t) {
              return this._getEnemyName(s, e.slotId);
            }
            if (
              n !== r.NAME_VISIBILITY_TYPE.HIDDEN &&
              n !== r.NAME_VISIBILITY_TYPE.UNHIDDEN
            ) {
              let t;
              if (e.summonerId) {
                const n = await this.get(
                  "_playerNames",
                ).getDisplayNameBySummonerId(e.summonerId);
                t = n?.playerNameFull;
              }
              return t;
            }
            {
              const i = this._getHiddenName(e, n, t);
              if (n === r.NAME_VISIBILITY_TYPE.HIDDEN) return i;
              if (n === r.NAME_VISIBILITY_TYPE.UNHIDDEN) {
                let t;
                if (e.summonerId) {
                  const n = await this.get(
                    "_playerNames",
                  ).getDisplayNameBySummonerId(e.summonerId);
                  t = n?.playerNameFull;
                }
                return s.formatString("name_visibility_type_team_unhidden", {
                  summonerName: t,
                  hiddenName: i,
                });
              }
            }
          },
          _getPuuidPromise: function (e) {
            return new Promise((t) =>
              e.puuid
                ? t(e.puuid)
                : this.get("summonerInfoService")
                    .getSummonerInfo(e.summonerId)
                    .then(({ puuid: e }) => t(e)),
            );
          },
          _getEnemyName: function (e, t) {
            const n = e.formatString("name_visibility_type_enemy", {
                summonerNumber: ((t || 0) % 5) + 1,
              }),
              s = this.get("subteamDataList");
            if (!s) return n;
            const i = s.find((e) => e.cellIds.includes(t));
            return i
              ? e.formatString("name_visibility_type_subteam_enemy", {
                  subTeam: e.get(i.display.label),
                  summonerNumber: (i.cellIds || []).indexOf(t) + 1,
                })
              : n;
          },
          _checkIfShouldShowChatRoom: function (e) {
            const t = this.get("queue");
            if (!t) return;
            if (e === r.NAME_VISIBILITY_TYPE.VISIBLE)
              return void this._showChatRoomIfNotShownYet();
            if (
              Object.keys(this.myTeamSummonerIdsToNames).length !==
              t.numPlayersPerTeam
            )
              return;
            const n = this.get("chatObfuscatedSummonerIds"),
              s = Object.keys(this.myTeamObfuscatedSummonerIdsSet);
            if (n && s && n.length === s.length) {
              for (let e = 0; e < s.length; e++) {
                const t = s[e];
                if (!n.includes(t)) return;
              }
              this._showChatRoomIfNotShownYet();
            }
          },
          _showChatRoomIfNotShownYet: function () {
            this.get("showChatRoom") ||
              (Object.keys(this.myTeamSummonerIdsToNames).length > 0 &&
                this.set(
                  "myTeamSummonerIdsToNameOverridesJson",
                  JSON.stringify(this.myTeamSummonerIdsToNames),
                ),
              this.set("showChatRoom", !0));
          },
          handleOngoingTrade: function (e) {
            this.set("activeTrade", e);
          },
          handleOngoingSwap: function (e) {
            this.set("activeSwap", e);
          },
          handlePinDropNotification: function (e) {
            if (this.get("pinDropSummoners")) {
              const t = this.get("pinDropSummoners");
              e.pinDropSummoners.forEach((e, n) => {
                t[n].setProperties(e);
              });
            } else {
              const t = e.pinDropSummoners.map((e) => s.Ember.Object.create(e));
              this.set("pinDropSummoners", s.Ember.A(t));
            }
            this.set("pinDropNotification", e);
          },
          setupShowHandler: function () {
            (this._showHandler = () => {
              if (
                !this.isDestroyed &&
                !this.isDestroying &&
                (this.set("isShown", !0),
                this.resetBanAnimations(),
                this.get("showEntryAnimation"))
              ) {
                this.set("isAnimatingIntro", !0);
                const e = () => {
                  this.set("isAnimatingIntro", !1),
                    this.removeEventListener(this.element, "transitionend", e);
                };
                this.addEventListener(this.element, "transitionend", e),
                  this.runTask(function () {
                    e();
                  }, 2e3);
              }
            }),
              h.on("show", this._showHandler),
              (this._hideHandler = () => {
                this.isDestroyed ||
                  this.isDestroying ||
                  (this.set("isShown", !1), this._hideChatRoom());
              }),
              h.on("hide", this._hideHandler),
              this.set("isShown", document.contains(this.get("element")));
          },
          _hideChatRoom: function () {
            (this.myTeamSummonerIdsToNames = {}),
              (this.myTeamObfuscatedSummonerIdsSet = {}),
              this.set("myTeamSummonerIdsToNameOverridesJson", ""),
              this.set("chatObfuscatedSummonerIds"),
              this.set("showChatRoom", !1);
          },
          showCurrentSummonerBanning: s.Ember.computed(
            "currentSummoner.isBanningNow",
            "waitingForBanAnimation",
            function () {
              return (
                (this.get("currentSummoner.isBanningNow") &&
                  !this.get("waitingForBanAnimation")) ||
                (this.get("currentSummoner.isBanningNow") &&
                  this.get("sessionActions.isSimultaneousBans"))
              );
            },
          ),
          pickOrderSwapDisabledConfigurationInSeconds: s.Ember.computed(
            "jmxSettings.LcuChampionSelect.timeLeftToDisablePickOrderSwap",
            function () {
              const e = this.get(
                "jmxSettings.LcuChampionSelect.timeLeftToDisablePickOrderSwap",
              );
              return e || 5;
            },
          ),
          timerDisabledPickOrderSwap: s.Ember.computed(
            "session.timer.timeRemaining",
            "session.timer.isInfinite",
            "session.timer.inPlanningPhase",
            "pickOrderSwapDisabledConfigurationInSeconds",
            function () {
              return (
                !this.get("session.timer.inPlanningPhase") &&
                this.get("session.timer.timeRemaining") <
                  this.get("pickOrderSwapDisabledConfigurationInSeconds") &&
                !this.get("session.timer.isInfinite")
              );
            },
          ),
          delayedLastCompletedActionId: s.EmberHelpers.delayed(
            "sessionActions.lastCompletedAction.id",
            r.DURATIONS.showLockedInSplash,
          ),
          actionWasJustCompleted: s.Ember.computed(
            "delayedLastCompletedActionId",
            "sessionActions.lastCompletedAction.id",
            "sessionActions.lastCompletedAction.isPickOrBanOrVote",
            function () {
              return (
                this.get(
                  "sessionActions.lastCompletedAction.isPickOrBanOrVote",
                ) &&
                this.get("delayedLastCompletedActionId") !==
                  this.get("sessionActions.lastCompletedAction.id")
              );
            },
          ),
          waitingForPickAnimation: s.Ember.computed(
            "actionWasJustCompleted",
            "sessionActions.lastCompletedAction.isPick",
            function () {
              return (
                this.get("actionWasJustCompleted") &&
                this.get("sessionActions.lastCompletedAction.isPick")
              );
            },
          ),
          waitingForBanAnimation: s.Ember.computed(
            "actionWasJustCompleted",
            "sessionActions.lastCompletedAction.isBan",
            function () {
              return (
                this.get("actionWasJustCompleted") &&
                this.get("sessionActions.lastCompletedAction.isBan")
              );
            },
          ),
          leavingChampSelect: s.Ember.computed(
            "isShown",
            "isUILockedForGameStart",
            function () {
              return !this.get("isShown") || this.get("isUILockedForGameStart");
            },
          ),
          showEntryAnimation: s.Ember.computed("isShown", function () {
            return (
              this.get("isShown") &&
              this.get("uxSettings.largeAreaAnimationsEnabled")
            );
          }),
          voiceButton: s.Ember.computed("isShown", function () {
            return this.get("isShown") ? p : "";
          }),
          shouldPlaySplashRingAnimation: s.Ember.computed(
            "isShowingVoteCeremonies",
            "sessionActions.completedVoteRevealActions.length",
            function () {
              return (
                !this.get("isShowingVoteCeremonies") &&
                0 ===
                  this.get("sessionActions.completedVoteRevealActions.length")
              );
            },
          ),
          showPreAnimation: s.Ember.computed("isShown", function () {
            return (
              !this.get("isShown") &&
              this.get("uxSettings.largeAreaAnimationsEnabled")
            );
          }),
          skinSplashUnlocked: s.Ember.computed(
            "viewSkin.unlocked",
            "session.allowSkinSelection",
            function () {
              return (
                !1 === this.get("session.allowSkinSelection") ||
                this.get("viewSkin.unlocked")
              );
            },
          ),
          splashUnlocked: s.Ember.computed(
            "champSelectScreen",
            "showPositionAssignmentBackground",
            "skinSplashUnlocked",
            "pickSplashUnlocked",
            function () {
              if (
                void 0 !== this.get("champSelectScreen") &&
                this.get("showPositionAssignmentBackground")
              )
                return !0;
              if (this.get("champSelectScreen") === r.SCREENS.selected)
                return this.get("skinSplashUnlocked");
              const e = this.get("pickSplashUnlocked");
              return null === e || e;
            },
          ),
          splashDefocus: s.Ember.computed(
            "pickSplashDefocus",
            "champSelectScreen",
            "isShowingGrid",
            "showVoteShowcase",
            function () {
              const e = this.get("champSelectScreen");
              return (
                this.get("pickSplashDefocus") &&
                (e === r.SCREENS.pick ||
                  e === r.SCREENS.banShowcase ||
                  (e === r.SCREENS.selected &&
                    (this.get("isShowingGrid") ||
                      this.get("showVoteShowcase"))))
              );
            },
          ),
          skinSplashPath: s.Ember.computed(
            "viewSkin.splashVideoPath",
            "viewSkin.splashPath",
            "viewSkin.unlocked",
            "viewSkin.groupSplash",
            "uxSettings.largeAreaAnimationsEnabled",
            function () {
              const e = this.get("viewSkin");
              return e
                ? !e.unlocked && e.groupSplash
                  ? e.groupSplash
                  : e.splashVideoPath &&
                      this.get("uxSettings.largeAreaAnimationsEnabled")
                    ? e.splashVideoPath
                    : e.splashPath || ""
                : null;
            },
          ),
          splashPath: s.Ember.computed(
            "showSkinSelectComponent",
            "skinSplashPath",
            "showPositionAssignmentBackground",
            "session.timer.inPlanningPhase",
            "pickSplashPath",
            "showPickPhaseComponent",
            "champSelectBackground",
            "isShowingVoteReveal",
            function () {
              return this.get("isShowingVoteReveal") &&
                this.get("currentSummoner.champion.skins.length")
                ? this.get("currentSummoner.champion.skins")[0].splashPath
                : this.get("showSkinSelectComponent")
                  ? this.get("skinSplashPath")
                  : this.get("showPositionAssignmentBackground")
                    ? this.get("session.timer.inPlanningPhase")
                      ? null
                      : this.get("pickSplashPath")
                    : (this.get("showPickPhaseComponent") &&
                        this.get("pickSplashPath")) ||
                      this.get("champSelectBackground");
            },
          ),
          skinAguments: s.Ember.computed(
            "viewSkin",
            "inventoryService.ownedSkinAugments",
            function () {
              const e = this.get("viewSkin")?.skinAugments,
                t = this.get("inventoryService")?.ownedSkinAugments;
              return e
                ? Object.keys(e).map((n) => {
                    if (t[n]) return e[n].centeredLCOverlayPath;
                  })
                : [];
            },
          ),
          resetBanAnimations: function () {
            this.get("animationDispatcher").stopAnimation("banSlashAnimation"),
              this.get("animationDispatcher").stopAnimation(
                "banLockedInAnimation",
              ),
              this.get("animationDispatcher").stopAnimation(
                "banOutroAnimation",
              ),
              this.get("animationDispatcher").stopAnimation(
                "banRotationAnimation",
              ),
              this.get("animationDispatcher").stopAnimation("fullBanAnimation");
          },
          playHighSpecBanAnimation: function () {
            const e = this.get("sessionActions.lastCompletedBanAction");
            this.get("animationDispatcher").playAnimation(
              "banLockedInAnimation",
            ),
              this.runTask(function () {
                this.get("sessionActions.lastCompletedBanAction") === e &&
                  this.get("animationDispatcher").playAnimation(
                    "banRotationAnimation",
                  );
              }, 800),
              this.get("animationDispatcher")
                .playAnimation("banSlashAnimation")
                .then(() => {
                  if (
                    this.get("sessionActions.lastCompletedBanAction") === e &&
                    !this.isDestroying &&
                    !this.isDestroyed
                  )
                    return (
                      this.runTask(function () {
                        this.get("sessionActions.lastCompletedBanAction") ===
                          e &&
                          (this.get("animationDispatcher").stopAnimation(
                            "banLockedInAnimation",
                          ),
                          this.get("animationDispatcher").stopAnimation(
                            "banOutroAnimation",
                          ),
                          this.get("animationDispatcher").stopAnimation(
                            "banRotationAnimation",
                          ),
                          this.get("animationDispatcher").stopAnimation(
                            "fullBanAnimation",
                          ));
                      }, 600),
                      this.get("animationDispatcher").playAnimation(
                        "banOutroAnimation",
                      )
                    );
                });
          },
          shouldShowChestFilter: s.Ember.computed(
            "queue.queueRewards.isChampionPointsEnabled",
            "queue.isRanked",
            function () {
              return (
                this.get("queue.queueRewards.isChampionPointsEnabled") &&
                !this.get("queue.isRanked")
              );
            },
          ),
          shouldShowChestAvailability: s.Ember.computed(
            "shouldShowChestFilter",
            "queue.gameMode",
            "session.timer.inFinalizationPhase",
            "gameflow.gameData.isCustomGame",
            "isLegendaryChampionMasteryEnabled",
            function () {
              return (
                !this.get("isLegendaryChampionMasteryEnabled") &&
                this.get("session.timer.inFinalizationPhase") &&
                this.get("shouldShowChestFilter") &&
                r.GAME_MODES_WITH_CHEST_AVAILABILITY_ENABLED.indexOf(
                  this.get("queue.gameMode"),
                ) > -1 &&
                !this.get("gameflow.gameData.isCustomGame")
              );
            },
          ),
          handleGridChampionsUpdated: function (e) {
            if (this.get("championChestAvailabilityMap")) {
              const t = this.get("championChestAvailabilityMap");
              e.forEach((e) => {
                t.set(e.id + "", !e.masteryChestGranted && e.owned);
              });
            } else {
              const t = s.Ember.Object.create({});
              e.forEach((e) => {
                t.set(e.id + "", !e.masteryChestGranted && e.owned);
              }),
                this.set("championChestAvailabilityMap", t);
            }
          },
          isPlayingCeremony: s.Ember.computed.readOnly(
            "sessionActions.activeAction.isCeremony",
          ),
          dispatchBanSelectedAction: s.EmberHelpers.observeChange(
            "sessionActions.lastCompletedBanAction",
            function () {
              this.get("sessionActions.lastCompletedBanAction") &&
                !this.get("isShowingBanShowcase") &&
                (this.resetBanAnimations(),
                this.runTask(() => {
                  this.get("animationDispatcher").playAnimation(
                    "fullBanAnimation",
                  ),
                    this.get("uxSettings.largeAreaAnimationsEnabled")
                      ? this.playHighSpecBanAnimation()
                      : this.get("animationDispatcher").playAnimation(
                          "lowSpecBanLockedInAnimation",
                        );
                }, 1));
            },
          ),
          isShowingBanShowcase: s.Ember.computed(
            "champSelectScreen",
            function () {
              return this.get("champSelectScreen") === r.SCREENS.banShowcase;
            },
          ),
          isShowingVoteReveal: s.Ember.computed.and(
            "sessionActions.activeAction.isVoteReveal",
            "session.timer.inFinalizationPhase",
          ),
          isShowingVoteTransition: s.Ember.computed.and(
            "sessionActions.activeAction.isVoteTransition",
            "session.timer.inFinalizationPhase",
          ),
          isShowingVoteCeremonies: s.Ember.computed.or(
            "isShowingVoteReveal",
            "isShowingVoteTransition",
          ),
          showVoteShowcase: s.Ember.computed.and(
            "sessionActions.activeAction.isVote",
            "currentSummoner.voteAction.completed",
            "session.timer.inBanPickPhase",
          ),
          timerNotAvailable: s.Ember.computed.not(
            "session.timer.timerAvailable",
          ),
          isUILockedForGameStart: s.Ember.computed.equal(
            "session.timer.phase",
            r.TIMER_PHASES.gameStarting,
          ),
          rerollsDisabled: s.Ember.computed.or(
            "isUILockedForGameStart",
            "hasSentOrReceivedTradeProposal",
          ),
          showRerollButton: s.Ember.computed.and(
            "session.allowRerolling",
            "session.timer.inFinalizationPhase",
          ),
          showChampionBench: s.Ember.computed.and(
            "session.benchEnabled",
            "session.timer.inFinalizationPhase",
          ),
          lockedEventsEnabledForQueue: s.Ember.computed.alias(
            "session.allowLockedEvents",
          ),
          lockedEventIndex: s.Ember.computed.alias("session.lockedEventIndex"),
          isHeaderExpanded: s.Ember.computed("showChampionBench", function () {
            return this.get("showChampionBench");
          }),
          benchChampions: s.Ember.computed(
            "session.benchChampions.@each.championId",
            function () {
              const e = this.get("session.benchChampions") || [];
              return s.Ember.A(e.map((e) => s.Ember.Object.create(e)));
            },
          ),
          boostableSkinCount: s.Ember.computed.alias(
            "session.boostableSkinCount",
          ),
          gameStartDelayedSysMessage: function (e) {
            const t = s.Ember.get(e, "timer.phase"),
              n = this.get("chatPublisherService.conversationId"),
              i = this.get("sentGameStartingMessageId");
            t === r.TIMER_PHASES.gameStarting &&
              i !== n &&
              (this.sendDelayedChatMessage(
                this.get("tra.system_message_starting_soon"),
                4e3,
              ),
              this.set("sentGameStartingMessageId", n));
          },
          champSelectScreen: s.EmberHelpers.computedGate(
            "showPositionAssignment",
            "showFinalization",
            "showBanShowcase",
            "sessionActions.activeAction.isPhaseTransition",
            "session.timer.inBanPickPhase",
            "session.timer.inPlanningPhase",
            "session.timer.inGameStartingPhase",
            function () {
              let e;
              return (
                this.get("showPositionAssignment")
                  ? (e = r.SCREENS.positionAssignment)
                  : this.get("showFinalization")
                    ? (e = r.SCREENS.selected)
                    : this.get("showBanShowcase")
                      ? (e = r.SCREENS.banShowcase)
                      : this.get("session.timer.inBanPickPhase") ||
                          this.get("session.timer.inPlanningPhase") ||
                          this.get(
                            "sessionActions.activeAction.isPhaseTransition",
                          )
                        ? (e = r.SCREENS.pick)
                        : this.get("session.timer.inGameStartingPhase") &&
                          (e = r.SCREENS.gameStarting),
                e
              );
            },
          ),
          isPlayingSimulBanOutro: s.Ember.computed.readOnly(
            "sessionActions.activeAction.isBanShowcase",
          ),
          playPickIntentSound: s.EmberHelpers.observeChange(
            "champSelectScreen",
            function (e, t) {
              if (
                this.get("isDraftMode") &&
                t === r.SCREENS.positionAssignment &&
                e === r.SCREENS.pick
              ) {
                const e =
                  "/fe/lol-champ-select/sounds/sfx-cs-draft-intent-champgrid-open.ogg";
                o.default.playSound("sfx-ui", e);
              }
            },
          ),
          hasSentOrReceivedTradeProposal: s.Ember.computed(
            "session.trades.@each.state",
            function () {
              return !!(this.get("session.trades") || []).find(
                (e) => e.state === l.TRADE_SENT || e.state === l.TRADE_RECEIVED,
              );
            },
          ),
          showQuitButton: s.Ember.computed(
            "gameflow.gameData.isCustomGame",
            "isNotSpectating",
            function () {
              return (
                this.get("gameflow.gameData.isCustomGame") &&
                this.get("isNotSpectating")
              );
            },
          ),
          disableQuitButton: s.Ember.computed(
            "session.timer.timerAvailable",
            "session.timer.inFinalizationPhase",
            "isUILockedForGameStart",
            function () {
              return (
                this.get("isUILockedForGameStart") ||
                (!this.get("session.timer.timerAvailable") &&
                  this.get("session.timer.inFinalizationPhase"))
              );
            },
          ),
          disableSpectatorQuitButton: s.EmberHelpers.computedGate.immediate(
            "session.timer.inGameStartingPhase",
            "session.timer.timeRemaining",
            function () {
              return (
                this.get("session.timer.inGameStartingPhase") &&
                this.get("session.timer.timeRemaining") < 3
              );
            },
          ),
          isNexusBlitz: s.Ember.computed("queue.id", function () {
            return r.NEXUS_BLITZ_QUEUE_IDS.includes(
              Number(this.get("queue.id")),
            );
          }),
          isGameModeWithCompanions: s.Ember.computed("gameMode", function () {
            return this.get("gameMode") in r.GAME_MODES_WITH_COMPANIONS;
          }),
          perPositionRequiredSummonerSpells: s.Ember.computed(
            "sessionPerPositionRequiredSummonerSpells",
            function () {
              try {
                const e = this.get("sessionPerPositionRequiredSummonerSpells");
                return JSON.parse(e);
              } catch (e) {
                return {};
              }
            },
          ),
          perPositionDisallowedSummonerSpells: s.Ember.computed(
            "sessionPerPositionDisallowedSummonerSpells",
            function () {
              try {
                const e = this.get(
                  "sessionPerPositionDisallowedSummonerSpells",
                );
                return JSON.parse(e);
              } catch (e) {
                return {};
              }
            },
          ),
          showPositionAssignment: s.EmberHelpers.computedGate.immediate(
            "session.timer.inPlanningPhase",
            "session.timer.inBanPickPhase",
            "session.timer.timeRemaining",
            "session.timer.totalTimeInPhase",
            "currentSummoner.hasPosition",
            "isBlindWithBans",
            "isNexusBlitz",
            function () {
              if (this.get("isNexusBlitz"))
                return this._shouldShowPositionAssignmentNexusBlitz();
              if (
                this.get("session.timer.inPlanningPhase") &&
                this.get("currentSummoner.hasPosition")
              ) {
                const e =
                  this.get(
                    "jmxSettings.LcuChampionSelect.MinPickIntentDuration",
                  ) || r.DURATIONS.pickIntentSeconds;
                return this.get("session.timer.timeRemaining") > e;
              }
              return !1;
            },
          ),
          _shouldShowPositionAssignmentNexusBlitz: function () {
            if (this.get("isBlindWithBans")) {
              if (this.get("session.timer.inPlanningPhase")) {
                const e =
                  this.get(
                    "jmxSettings.LcuChampionSelect.PositionAssignmentDuration",
                  ) || 7;
                return (
                  this.get("session.timer.totalTimeInPhase") / 1e3 -
                    this.get("session.timer.timeRemaining") <
                  e
                );
              }
            } else if (this.get("session.timer.inBanPickPhase")) {
              const e =
                this.get(
                  "jmxSettings.LcuChampionSelect.PositionAssignmentDuration",
                ) || 8;
              return (
                this.get("session.timer.totalTimeInPhase") / 1e3 -
                  this.get("session.timer.timeRemaining") <
                e
              );
            }
            return !1;
          },
          showPositionAssignmentBackground: s.Ember.computed(
            "currentSummoner.hasPosition",
            "session.timer.inPlanningPhase",
            "session.timer.inBanPickPhase",
            "pickSplashPath",
            function () {
              return (
                this.get("currentSummoner.hasPosition") &&
                (this.get("session.timer.inPlanningPhase") ||
                  this.get("session.timer.inBanPickPhase"))
              );
            },
          ),
          showFinalization: s.Ember.computed(
            "currentSummoner.pickAction.completed",
            "sessionActions.allPlayersPickTogether",
            "session.timer.inFinalizationPhase",
            "sessionActions.activeAction.isPhaseTransition",
            function () {
              const e = this.get("currentSummoner.pickAction.completed"),
                t =
                  this.get("session.timer.inFinalizationPhase") &&
                  !this.get("sessionActions.activeAction.isPhaseTransition");
              return (
                (e && !this.get("currentSummoner.hasUncompletedAction")) || t
              );
            },
          ),
          showBanShowcase: s.Ember.computed(
            "session.timer.inBanPickPhase",
            "sessionActions.isSimultaneousBans",
            "isPlayingSimulBanOutro",
            function () {
              return (
                this.get("isPlayingSimulBanOutro") ||
                (this.get("session.timer.inBanPickPhase") &&
                  this.get("sessionActions.isSimultaneousBans"))
              );
            },
          ),
          showPickPhaseComponent: s.Ember.computed(
            "isShown",
            "champSelectScreen",
            "transitioningToSelectedScreen",
            "session.timer.inFinalizationPhase",
            "sessionActions.allPlayersPickTogether",
            function () {
              if (!this.get("isShown")) return !0;
              const e = this.get("champSelectScreen");
              return (
                this.get("transitioningToSelectedScreen") ||
                e === r.SCREENS.pick ||
                e === r.SCREENS.banShowcase ||
                (e === r.SCREENS.selected &&
                  !this.get("session.timer.inFinalizationPhase") &&
                  !this.get("sessionActions.allPlayersPickTogether"))
              );
            },
          ),
          showSkinSelectComponent: s.Ember.computed(
            "isShown",
            "champSelectScreen",
            "isSpectating",
            "isShowingVoteCeremonies",
            function () {
              return (
                !this.get("isShown") ||
                (this.get("champSelectScreen") === r.SCREENS.selected &&
                  !this.get("isSpectating") &&
                  !this.get("isShowingVoteCeremonies"))
              );
            },
          ),
          showGameEventInfoCard: s.Ember.computed(
            "lockedEventsEnabledForQueue",
            "champSelectScreen",
            function () {
              return (
                this.get("champSelectScreen") !== r.SCREENS.gameStarting &&
                this.get("lockedEventsEnabledForQueue")
              );
            },
          ),
          shiftGameEventInfoCard: s.Ember.computed(
            "champSelectScreen",
            function () {
              const e = this.get("champSelectScreen");
              return (
                e === r.SCREENS.pick ||
                e === r.SCREENS.banShowcase ||
                e === r.SCREENS.selected
              );
            },
          ),
          currentSideMapImage: s.Ember.computed(
            "map.id",
            "currentSummoner.side",
            "map.assets.map-north",
            "map.assets.map-south",
            function () {
              if (11 !== this.get("map.id")) return null;
              const e =
                "red" === this.get("currentSummoner.side") ? "north" : "south";
              return this.get(`map.assets.map-${e}`);
            },
          ),
          champSelectBackground: s.Ember.computed(
            "currentSideMapImage",
            "map.assets.gameflow-background",
            function () {
              return (
                this.get("currentSideMapImage") ||
                this.get("map.assets.gameflow-background")
              );
            },
          ),
          sendDelayedChatMessage: function (e, t) {
            this.runTask(() => {
              this.get("chatPublisherService")
                .sendChatMessage(e)
                .catch((e) => {});
            }, t);
          },
          transitionScreenState: s.Ember.observer(
            "champSelectScreen",
            "isShown",
            function () {
              if (!this.get("isShown")) return;
              const e = this.get("previousChampSelectScreen"),
                t = this.get("champSelectScreen");
              this.set("previousChampSelectScreen", t),
                e === r.SCREENS.pick &&
                  t === r.SCREENS.selected &&
                  (this.set("transitioningToSelectedScreen", !0),
                  this.runTask(() => {
                    this.set("transitioningToSelectedScreen", !1);
                  }, r.DURATIONS.pickPhaseChangeTransition));
            },
          ),
          hasTwoTeams: s.Ember.computed(
            "session.myTeam.length",
            "session.theirTeam.length",
            function () {
              const e = this.get("session.myTeam.length"),
                t = this.get("session.theirTeam.length");
              return e > 0 && t > 0;
            },
          ),
          shouldShowFirstPick: s.Ember.computed(
            "sessionActions.pickActions.length",
            "sessionActions.allPlayersPickTogether",
            "sessionActions.pickActionsHaveBegun",
            "hasTwoTeams",
            function () {
              return (
                this.get("sessionActions.pickActions.length") &&
                !this.get("sessionActions.allPlayersPickTogether") &&
                !this.get("sessionActions.pickActionsHaveBegun") &&
                this.get("hasTwoTeams")
              );
            },
          ),
          showLeftSideFirstPick: s.Ember.computed(
            "shouldShowFirstPick",
            "sessionActions.leftSideFirstPick",
            function () {
              return (
                this.get("shouldShowFirstPick") &&
                this.get("sessionActions.leftSideFirstPick")
              );
            },
          ),
          teamSizeText: s.Ember.computed(
            "queue.numPlayersPerTeam",
            "queue.gameMode",
            function () {
              const e = r.GAME_MODES_WITH_SUBTEAMS[this.get("queue.gameMode")];
              return e
                ? this.get("tra").formatString(e.teamSizeLabel, {
                    size: e.teamSize,
                  })
                : this.get("tra").formatString("map_size", {
                    size: this.get("queue.numPlayersPerTeam"),
                  });
            },
          ),
          isShowingPerksModal: s.Ember.computed.readOnly("isShowingPerks"),
          queueNameText: s.Ember.computed.alias("queue.description"),
          showRightSideFirstPick: s.Ember.computed(
            "shouldShowFirstPick",
            "sessionActions.leftSideFirstPick",
            function () {
              return (
                this.get("shouldShowFirstPick") &&
                !this.get("sessionActions.leftSideFirstPick")
              );
            },
          ),
          randomChampionRateLimitConfig: s.Ember.computed(
            "jmxSettings.LcuChampionSelect.RandomChampionRateLimitMaxActions",
            "jmxSettings.LcuChampionSelect.RandomChampionRateLimitInterval",
            function () {
              const e = this.get(
                  "jmxSettings.LcuChampionSelect.RandomChampionRateLimitMaxActions",
                ),
                t = this.get(
                  "jmxSettings.LcuChampionSelect.RandomChampionRateLimitInterval",
                );
              return e && t
                ? s.Ember.Object.create({ maxActions: e, interval: t })
                : null;
            },
          ),
          isRandomChampionEnabled: s.Ember.computed(
            "queue",
            "jmxSettings.LcuChampionSelect.RandomChampionEnabledGameQueues",
            "sessionActions.activeAction.isBan",
            function () {
              const e = this.get(
                  "jmxSettings.LcuChampionSelect.RandomChampionEnabledGameQueues",
                ),
                t = this.get("queue"),
                n = this.get("sessionActions.activeAction.isBan");
              return !(!e || !t || n) && e.includes(t.id);
            },
          ),
          isCompanionsEnabled: s.Ember.computed.and(
            "isGameModeWithCompanions",
            "jmxSettings.Companions.SelectorInChampSelectEnabled",
          ),
          initialLoadTelemetryObserver: s.Ember.observer(
            "session.timer.phase",
            function () {
              this.get("session.timer.phase") &&
              !this._initialLoadTelemetryTracked
                ? ((this._initialLoadTelemetryTracked = !0),
                  s.Telemetry.waitForGoodFps().then((e) => {
                    this._initialLoadTelemetryFirstLoopCompleted
                      ? s.Telemetry.sendEvent(
                          "timer_champ-select-entry-subsequent-loop",
                          e,
                        )
                      : ((this._initialLoadTelemetryFirstLoopCompleted = !0),
                        s.Telemetry.sendEvent(
                          "timer_champ-select-entry-first-loop",
                          e,
                        ));
                  }))
                : this.get("session.timer.phase") ||
                  (this._initialLoadTelemetryTracked = !1);
            },
          ),
          formattedTime: s.Ember.computed(
            "session.timer.timeRemaining",
            "isSpectating",
            "session.timer.phase",
            function () {
              if (!(this.get("session.timer.timeRemaining") < 0))
                return this.get("displayTimeAsMinuteSecond")
                  ? this.get("minuteSecondTime")
                  : this.get("session.timer.timeRemaining");
            },
          ),
          displayTimeAsMinuteSecond: s.Ember.computed(
            "session.timer.totalTimeInPhase",
            function () {
              return (
                this.get("session.timer.totalTimeInPhase") >=
                r.MINUTE_SECOND_TIME_DISPLAY_THRESHOLD_MS
              );
            },
          ),
          minuteSecondTime: s.Ember.computed(
            "session.timer.timeRemaining",
            function () {
              const e = this.get("session.timer.timeRemaining");
              let t = e % 60;
              return t < 10 && (t = "0" + t), Math.floor(e / 60) + ":" + t;
            },
          ),
          actions: {
            selectViewSkin(e) {
              this.set("viewSkin", e);
            },
            showingPerksModalChanged: function (e) {
              const t = this.get("isShown");
              if (
                (this.set("isShowingPerks", e),
                !(this.isDestroying || this.isDestroyed || e) &&
                  t &&
                  this.get("currentPerksPage.hasError"))
              ) {
                const e = this.get("currentPerksPage.isValid")
                  ? "error_could_not_set_perks_page"
                  : "error_perks_page_contains_invalid_choices";
                d.add({
                  type: "DialogAlert",
                  data: {
                    contents: this.get("tra.service").formatString(e, {
                      page_name: this.get("currentPerksPage.name"),
                    }),
                    okText: this.get("tra.lib_ui_dialog_alert_ok"),
                  },
                  show: !0,
                });
              }
            },
            clickChat() {
              s.Telemetry.recordNonTimingTracingEvent(
                "champ-select-chat-button-click",
                1,
                "click",
              );
            },
            closeBoostNotificationToast() {
              this.get("teamBoost").set("boostToastOpen", !1);
            },
            updateChestAvailabilityHintedPortraits(e = !1) {
              this.set("showChestAvailabilityHintedPortraits", e);
            },
          },
          _recordDidRequestSucceed: function (e, t = null) {
            this.get(
              "jmxSettings.LcuChampionSelect.IsDisconnectNotificationEnabled",
            ) &&
              (e
                ? this.get(
                    "champSelectDisconnectService",
                  ).receivedServiceCallResponse(null)
                : this.get(
                    "champSelectDisconnectService",
                  ).receivedServiceCallResponse(t));
          },
          shouldShowDisconnectNotification: s.Ember.computed(
            "login",
            "login.connected",
            "jmxSettings.LcuChampionSelect.IsDisconnectNotificationEnabled",
            "champSelectDisconnectService.isDisconnected",
            "isShown",
            "session.timer.inGameStartingPhase",
            function () {
              const e = this.get("login"),
                t = !e || !0 !== e.connected,
                n = this.get(
                  "jmxSettings.LcuChampionSelect.IsDisconnectNotificationEnabled",
                ),
                s = this.get("champSelectDisconnectService.isDisconnected"),
                i = this.get("isShown"),
                o = this.get("session.timer.inGameStartingPhase");
              return n && s && i && !t && !o;
            },
          ),
          isSpectating: s.Ember.computed(
            "currentSummoner",
            "session.myTeam.length",
            "session.theirTeam.length",
            function () {
              return !(
                this.get("currentSummoner") ||
                (!this.get("session.myTeam.length") &&
                  !this.get("session.theirTeam.length"))
              );
            },
          ),
          isNotSpectating: s.Ember.computed.bool("currentSummoner"),
          loggedInPlayer: s.Ember.computed("login.summonerId", function () {
            if (
              this.get("login.summonerId") &&
              this.get("login.summonerId") > 0
            )
              return this.get("login.summonerId");
          }),
          playerId: s.Ember.computed.alias("login.summonerId"),
          currentSummoner: s.Ember.computed(
            "session.myTeam",
            "session.myTeam.@each.isSelf",
            function () {
              const e = this.get("session.myTeam");
              return e && e.findBy("isSelf", !0);
            },
          ),
          accountLoadout: s.Ember.computed.readOnly(
            "accountLoadouts.firstObject",
          ),
          selectedWardSkin: s.Ember.computed(
            "jmxSettings.WardSkinConfig.UseLoadouts",
            "accountLoadout.loadout.WARD_SKIN_SLOT.itemId",
            "currentSummoner.selectedWardSkin",
            "wardSkins",
            function () {
              if (this.get("jmxSettings.WardSkinConfig.UseLoadouts")) {
                const e = 0,
                  t =
                    this.get("accountLoadout.loadout.WARD_SKIN_SLOT.itemId") ||
                    e;
                return (this.get("wardSkins") || s.Ember.A()).findBy("id", t);
              }
              return this.get("currentSummoner.selectedWardSkin");
            },
          ),
          summoners: s.Ember.computed.union(
            "session.myTeam",
            "session.theirTeam",
          ),
          wardSkins: s.Ember.computed(
            "wardSkinsInventory.@each.itemId",
            "wardSkinsCatalog.@each.id",
            function () {
              const e = this.get("wardSkinsInventory"),
                t = this.get("wardSkinsCatalog");
              if (!f.isEmpty(e) || !f.isEmpty(t)) {
                const n = e.map((e) => ({ id: e.itemId })),
                  i = f
                    .intersectionBy(t, n, "id")
                    .map((e) => ((e.ownership = { owned: !0 }), e));
                return s.Ember.A(i.map((e) => new g(e)));
              }
            },
          ),
          championToSummonerMap: s.Ember.computed(
            "summoners.@each.champion",
            function () {
              const e = new Map();
              return (
                this.get("summoners").forEach(function (t) {
                  e.set(t.get("champion.id"), t);
                }),
                e
              );
            },
          ),
          availableSpells: s.Ember.computed(
            "spells.@each.available",
            function () {
              const e = this.get("spells");
              return s.Ember.A((e && e.filterBy("available")) || []);
            },
          ),
          queue: s.Ember.computed.alias("gameflow.gameData.queue"),
          map: s.Ember.computed.alias("gameflow.map"),
          gameMode: s.Ember.computed.alias("gameflow.gameData.queue.gameMode"),
          gameModeSupportsPerks: s.Ember.computed.not(
            "gameflow.map.properties.suppressRunesMasteriesPerks",
          ),
          gameModeSubteamMetadata: s.Ember.computed(
            "gameMode",
            "session.localPlayerCellId",
            function () {
              const e = this.get("gameMode"),
                t = r.GAME_MODES_WITH_SUBTEAMS[e];
              if (t) {
                const e = this.get("session.localPlayerCellId");
                return {
                  subteamDataList: t.subteams.map((t) => ({
                    ...t,
                    isLocalSubteam: t.cellIds.includes(e),
                  })),
                  allSlotIds: y,
                };
              }
              return null;
            },
          ),
          subteamDataList: s.Ember.computed(
            "gameModeSubteamMetadata",
            function () {
              return this.get("gameModeSubteamMetadata.subteamDataList");
            },
          ),
          disabledSpellIds: s.Ember.computed(
            "queue.gameMode",
            "jmxSettings.ClientSystemStates.gameModeToInactiveSpellIds",
            function () {
              const e = this.get("queue.gameMode"),
                t = this.get(
                  "jmxSettings.ClientSystemStates.gameModeToInactiveSpellIds",
                );
              if (!e || !t) return [];
              let n =
                s.Ember.get(t, "ALL_GAME_MODES_DISABLED_SPELLS_KEY") || [];
              return (
                (n = n.concat(s.Ember.get(t, e) || [])),
                n.map(function (e) {
                  return parseInt(e);
                })
              );
            },
          ),
          rp: s.Ember.computed("walletRP.RP", function () {
            return this.get("walletRP.RP") || 0;
          }),
          uxSettingsInit: function () {
            this.set("uxSettingsListener", this.uxSettingsObserver.bind(this)),
              s.UXSettings.addObserver(this.get("uxSettingsListener"));
          },
          uxSettingsDestroy: function () {
            s.UXSettings.removeObserver(this.get("uxSettingsListener"));
          },
          uxSettingsObserver: function (e) {
            this.set(
              "uxSettings",
              s.Ember.ObjectProxy.extend({
                largeAreaAnimationsEnabled: s.Ember.computed(
                  "root.jmxSettings.LcuChampionSelect.PotatoModeForced",
                  "content.largeAreaAnimationsEnabled",
                  function () {
                    return (
                      !this.get(
                        "root.jmxSettings.LcuChampionSelect.PotatoModeForced",
                      ) && this.get("content.largeAreaAnimationsEnabled")
                    );
                  },
                ),
              }).create({ content: e, root: this }),
            );
          },
          _debugLoggedInPlayerObserver: s.EmberHelpers.observeChange(
            "loggedInPlayer",
            function () {
              s.logger.trace(
                "logged in playerID is " + this.get("loggedInPlayer"),
              );
            },
          ),
          _debugPickableChampionsObserver: s.EmberHelpers.observeChange(
            "pickableChampionIds.length",
            function () {
              s.logger.trace(
                "pickable champions changed, length is " +
                  (this.get("pickableChampionIds") || []).length,
              );
            },
          ),
          _debugInventoryObserver: s.EmberHelpers.observeChange(
            "inventory.length",
            function () {
              s.logger.trace(
                "champion inventory changed, length is " +
                  (this.get("inventory") || []).length,
              );
            },
          ),
          _debugAvailableSpellsObserver: s.EmberHelpers.observeChange(
            "availableSpells.[]",
            function () {
              s.logger.trace(
                "availableSpells changed, length is " +
                  (this.get("availableSpells") || []).length,
              );
            },
          ),
        });
        t.default = v;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = (function (e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var n = i(t);
          if (n && n.has(e)) return n.get(e);
          var s = {},
            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a in e)
            if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
              var r = o ? Object.getOwnPropertyDescriptor(e, a) : null;
              r && (r.get || r.set)
                ? Object.defineProperty(s, a, r)
                : (s[a] = e[a]);
            }
          (s.default = e), n && n.set(e, s);
          return s;
        })(n(1));
        function i(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (i = function (e) {
            return e ? n : t;
          })(e);
        }
        var o = s.default.EmberDataBinding({
          Ember: s.Ember,
          websocket: s.default.getProvider().getSocket(),
          logPrefix: "rcp-fe-lol-champ-select",
          defaultPropertyValue: {},
          boundProperties: {
            gameflow: "/lol-gameflow/v1/session",
            sessionPerPositionRequiredSummonerSpells: {
              path: "/lol-gameflow/v1/session/per-position-summoner-spells/required/as-string",
              default: "{}",
            },
            sessionPerPositionDisallowedSummonerSpells: {
              path: "/lol-gameflow/v1/session/per-position-summoner-spells/disallowed/as-string",
              default: "{}",
            },
            localSummoner: "/lol-summoner/v1/current-summoner",
            login: "/lol-login/v1/session",
            walletRP: "/lol-inventory/v1/wallet/RP",
            commsMembers: "/lol-lobby/v2/comms/members",
            inventory: {
              path: "/lol-champions/v1/inventories/{{loggedInPlayer}}/champions",
              objectTypes: { "[]": n(165) },
              default: [],
            },
            pickableChampionIds: {
              path: "/lol-champ-select/v1/pickable-champion-ids",
              default: [],
            },
            jmxSettings: "/lol-platform-config/v1/namespaces",
            ChampTradingTooltipEnabled: {
              path: "/lol-platform-config/v1/namespaces/LcuChampionSelect/ChampTradingTooltipEnabled",
              default: !0,
            },
            PickOrderSwappingTooltipEnabled: {
              path: "/lol-platform-config/v1/namespaces/LcuChampionSelect/PickOrderSwappingTooltipEnabled",
              default: !0,
            },
            UseNewLoyaltyIcon: {
              path: "/client-config/v2/config/lol.client_settings.navigation.enableRewardsProgram",
              default: !1,
            },
            runeRecommenderEnabled: {
              path: "/client-config/v2/config/lol.client_settings.perks.runeRecommenderEnabled",
              default: !1,
            },
            unlockAllRunePageFunctionality: {
              path: "/client-config/v2/config/lol.client_settings.perks.unlockAllRunePageFunctionality",
              default: !1,
            },
            isLegendaryChampionMasteryEnabled: {
              path: "/lol-client-config/v3/client-config/lol.client_settings.champ_mastery.lcm_enabled",
              default: !1,
            },
            spells: {
              path: "/lol-game-data/assets/v1/summoner-spells.json",
              objectTypes: { "[]": n(166) },
              default: [],
            },
            wardSkinsInventory: {
              path: "/lol-inventory/v2/inventory/WARD_SKIN",
              default: [],
            },
            wardSkinsCatalog: {
              path: "/lol-game-data/assets/v1/ward-skins.json",
              default: [],
            },
            perksPages: {
              path: "/lol-perks/v1/pages",
              objectTypes: { "[]": n(167) },
              default: [],
            },
            currentPerksPage: {
              path: "/lol-perks/v1/currentpage",
              default: {},
            },
            perksSettings: {
              path: "/lol-perks/v1/settings",
              default: { showPresetPages: !0 },
            },
            useRuneRecommenderAutoSelect: {
              path: "/lol-perks/v1/rune-recommender-auto-select",
              default: !1,
            },
            conversations: "/lol-chat/v1/conversations",
            session: {
              path: "/lol-champ-select/v1/session",
              objectTypes: {
                "myTeam[]": n(168),
                "theirTeam[]": n(168),
                timer: n(169),
                "actions:flatten[]": n(170),
              },
              default: {},
            },
            teamBoost: {
              path: "/lol-champ-select/v1/team-boost",
              objectTypes: { "": n(171) },
              default: void 0,
            },
            entitlements: { path: "/entitlements/v1/token", default: null },
            tutorial: {
              path: "/lol-settings/v1/account/lol-tutorial",
              default: {},
            },
            accountLoadouts: {
              path: "/lol-loadouts/v4/loadouts/scope/account",
              default: [],
            },
          },
        });
        t.default = o;
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = n(152);
        const o = s.Ember.Object.extend({
          selectedByMe: s.Ember.computed.alias("selectedBy.isSelf"),
          selected: s.Ember.computed.bool("selectedBy"),
          selectedBy: s.Ember.computed(
            "root.championToSummonerMap",
            "root.currentSummoner.champion.id",
            "id",
            function () {
              if (
                this.get("root.currentSummoner.champion.id") === this.get("id")
              )
                return this.get("root.currentSummoner");
              const e = this.get("root.championToSummonerMap");
              return e ? e.get(this.get("id")) : void 0;
            },
          ),
          preloadSkinTileImages: s.Ember.observer("selectedByMe", function () {
            if (this.get("selectedByMe")) {
              const e = this.get("skins");
              e &&
                e.forEach(function (e) {
                  const t = e.get("tilePath");
                  if (t) {
                    new Image().src = t;
                  }
                });
            }
          }),
          banAction: s.Ember.computed(
            "id",
            "root.sessionActions.completedBanActions.@each.championId",
            function () {
              const e = this.get("root.sessionActions.completedBanActions");
              return (
                s.Lodash.find(
                  e,
                  (e) =>
                    e.get("championId") === this.get("id") &&
                    !e.get("actor.isOnPlayersTeam"),
                ) ||
                s.Lodash.find(e, (e) => e.get("championId") === this.get("id"))
              );
            },
          ),
          banned: s.Ember.computed.bool("banAction"),
          picked: s.Ember.computed(
            "selectedBy.pickAction.completed",
            "selectedBy.voteAction",
            function () {
              return (
                !this.get("selectedBy.voteAction") &&
                this.get("selectedBy") &&
                (this.get("selectedBy.pickAction.completed") ||
                  !this.get("selectedBy.pickAction"))
              );
            },
          ),
          hovered: s.Ember.computed(
            "selectedBy.pickAction.isActive",
            function () {
              return (
                this.get("selectedBy") &&
                this.get("selectedBy.pickAction.isActive")
              );
            },
          ),
          voted: s.Ember.computed(
            "selectedBy.voteAction.isActive",
            function () {
              return (
                this.get("selectedBy") &&
                this.get("selectedBy.voteAction.isActive")
              );
            },
          ),
          pickedByOtherOrBanned: s.Ember.computed(
            "picked",
            "selectedByMe",
            "root.currentSummoner.isBanningNow",
            "root.session.allowDuplicatePicks",
            "hovered",
            "banned",
            function () {
              return (
                !(
                  !this.get("banned") &&
                  this.get("root.session.allowDuplicatePicks")
                ) &&
                ((this.get("picked") &&
                  (!this.get("selectedByMe") ||
                    this.get("root.currentSummoner.isBanningNow"))) ||
                  (this.get("root.currentSummoner.isBanningNow") &&
                    this.get("banned") &&
                    this.get("id") !== i.NONE_CHAMP_ID) ||
                  (this.get("hovered") && !this.get("selectedByMe")) ||
                  (!this.get("root.currentSummoner.isBanningNow") &&
                    this.get("banned")))
              );
            },
          ),
          baseSkin: s.Ember.computed("skins.@each.isBase", function () {
            return s.Lodash.find(this.get("skins"), function (e) {
              return s.Ember.get(e, "isBase");
            });
          }),
        });
        e.exports = o;
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        const i = n(1),
          { Ember: o } = i,
          a = o.Object.extend({
            soundPath: o.computed("id", function () {
              return `${s.SOUNDS_PATH}/sfx-spellchoose-${this.get("id")}.ogg`;
            }),
            available: o.computed(
              "gameModes.[]",
              "root.queue.gameMode",
              function () {
                const e = this.get("root.queue.gameMode");
                return this.get("gameModes").indexOf(e) > -1;
              },
            ),
            locked: o.computed.bool("lockedReason"),
            lockedReason: o.computed("canUse", "disabled", function () {
              return this.get("canUse")
                ? this.get("disabled")
                  ? "DISABLED"
                  : void 0
                : "LEVEL";
            }),
            canUse: o.computed(
              "summonerLevel",
              "root.localSummoner.summonerLevel",
              function () {
                return (
                  this.get("summonerLevel") <=
                    this.get("root.localSummoner.summonerLevel") ||
                  !this.get("root.localSummoner.summonerLevel")
                );
              },
            ),
            disabled: o.computed("id", "root.disabledSpellIds", function () {
              return (
                -1 !==
                (this.get("root.disabledSpellIds") || []).indexOf(
                  this.get("id"),
                )
              );
            }),
          });
        e.exports = a;
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        const i = s.Ember.Object.extend({
          isPresetPage: s.Ember.computed("id", function () {
            const e = this.get("id");
            return e >= 50 && e <= 59;
          }),
          hasError: s.Ember.computed(
            "isValid",
            "current",
            "isActive",
            function () {
              return (
                !this.get("isValid") ||
                (this.get("current") && !this.get("isActive"))
              );
            },
          ),
        });
        e.exports = i;
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        const i = s.Ember.Object.extend({
          summonerIdObserver: s.EmberHelpers.observeChange(
            "summonerId",
            function () {
              const e = this.get("summonerId");
              e &&
                (0, s.DataBinding)("/lol-summoner")
                  .get(`/v1/summoners/${e}`)
                  .then((e) => {
                    if (!e) return;
                    const {
                      playerNameFull: t,
                      gameName: n,
                      tagLine: i,
                    } = s.playerNames.formatPlayerName(e);
                    (this.isDestroying && this.isDestroyed) ||
                      (this.set("displayName", t),
                      this.set("gameName", n),
                      this.set("tagLine", i));
                  });
            },
          ),
          name: s.Ember.computed("displayName", "summonerIndex", function () {
            if (this.get("displayName")) return this.get("displayName");
            let e;
            e =
              void 0 === this.get("summonerIndex")
                ? 1
                : this.get("summonerIndex") + 1;
            const t = this.get("root.tra");
            return t
              ? t.formatString("obfuscated_summoner_name", {
                  summonerNumber: e,
                })
              : "";
          }),
          lastPickSnipedChampion: null,
          champion: s.Ember.computed(
            "isSelf",
            "isPickingNow",
            "isVotingNow",
            "requestedChampionId",
            "championId",
            "pickAction.championId",
            "voteAction.championId",
            "root.inventory.@each.id",
            function () {
              let e;
              return (
                this.get("isSelf") &&
                  (this.get("isPickingNow") || this.get("isVotingNow")) &&
                  (e = this.get("requestedChampionId")),
                e ||
                  (e =
                    this.get("championId") ||
                    this.get("pickAction.championId") ||
                    this.get("voteAction.championId")),
                (this.get("root.inventory") || s.Ember.A()).findBy("id", e)
              );
            },
          ),
          isBanSniping: s.Ember.computed.and(
            "isBanningNow",
            "activeAction.champion.selected",
          ),
          checkForPickSnipe: s.EmberHelpers.observeChange(
            "champion",
            function (e, t) {
              !this.get("champion") &&
              this.get("pickAction") &&
              t &&
              t.get("pickedByOtherOrBanned")
                ? (this.set("lastPickSnipedChampion", t),
                  this.set("requestedChampionId", null))
                : this.set("lastPickSnipedChampion", null);
            },
          ),
          isSelf: s.Ember.computed(
            "root.session.localPlayerCellId",
            "cellId",
            function () {
              return (
                this.get("root.session.localPlayerCellId") ===
                this.get("cellId")
              );
            },
          ),
          isOnPlayersTeam: s.Ember.computed(
            "team",
            "root.currentSummoner.team",
            function () {
              return this.get("team") === this.get("root.currentSummoner.team");
            },
          ),
          isOnLeftSide: s.Ember.computed(
            "root.isSpectating",
            "isOnPlayersTeam",
            "side",
            function () {
              return this.get("root.isSpectating")
                ? "blue" === this.get("side")
                : this.get("isOnPlayersTeam");
            },
          ),
          side: s.Ember.computed("team", function () {
            switch (this.get("team")) {
              case 1:
                return "blue";
              case 2:
                return "red";
              default:
                return "spectator";
            }
          }),
          hasPosition: s.Ember.computed("assignedPosition", function () {
            return !!this.get("assignedPosition");
          }),
          uncompletedAction: s.Ember.computed(
            "actions.@each.completed",
            function () {
              return this.get("actions").findBy("completed", !1);
            },
          ),
          activeAction: s.EmberHelpers.computedGate(
            "actions.@each.isActive",
            function () {
              return this.get("actions").findBy("isActive", !0);
            },
          ),
          changingAction: s.Ember.computed(
            "activeAction.id",
            "isPickIntenting",
            "pickAction",
            function () {
              let e = this.get("activeAction");
              return (
                (e && void 0 !== e.get("id")) ||
                  !this.get("isPickIntenting") ||
                  (e = this.get("pickAction")),
                e
              );
            },
          ),
          nextAction: s.EmberHelpers.computedGate(
            "root.sessionActions.nextActions.@each.id",
            "actions.@each.isNext",
            function () {
              return this.get("actions").findBy("isNext", !0);
            },
          ),
          isExclusivelyPickIntenting: s.Ember.computed.readOnly(
            "root.session.timer.inPlanningPhase",
          ),
          isPickIntenting: s.Ember.computed(
            "isExclusivelyPickIntenting",
            "pickAction",
            "pickAction.completed",
            "isPickingNow",
            "isBanningNow",
            function () {
              return (
                this.get("isExclusivelyPickIntenting") ||
                (this.get("pickAction") &&
                  !this.get("pickAction.completed") &&
                  !this.get("isPickingNow") &&
                  !this.get("isBanningNow"))
              );
            },
          ),
          isBanningNow: s.Ember.computed.bool("activeAction.isBan"),
          isBanningNext: s.Ember.computed.bool("nextAction.isBan"),
          isPickingNow: s.Ember.computed.bool("activeAction.isPick"),
          isVotingNow: s.Ember.computed.bool("activeAction.isVote"),
          isPickingOrVotingNow: s.Ember.computed.or(
            "isPickingNow",
            "isVotingNow",
          ),
          isActingNow: s.Ember.computed.bool("activeAction"),
          actions: s.Ember.computed(
            "root.sessionActions.allActions.@each.actorCellId",
            "cellId",
            function () {
              const e =
                this.get("root.sessionActions.allActions") || s.Ember.A();
              return s.Ember.A(e.filterBy("actorCellId", this.get("cellId")));
            },
          ),
          hasUncompletedAction: s.Ember.computed(
            "uncompletedAction",
            function () {
              return !!this.get("uncompletedAction");
            },
          ),
          pickAction: s.Ember.computed("actions.@each.type", function () {
            return this.get("actions").findBy("type", "pick");
          }),
          voteAction: s.Ember.computed("actions.@each.type", function () {
            return this.get("actions").findBy("type", "vote");
          }),
          isDonePicking: s.Ember.computed(
            "pickAction.completed",
            "pickAction",
            "champion",
            function () {
              return (
                this.get("pickAction.completed") ||
                (!this.get("pickAction") && !!this.get("champion"))
              );
            },
          ),
          banActions: s.Ember.computed("actions.@each.type", function () {
            return s.Ember.A(this.get("actions").filterBy("type", "ban"));
          }),
          allyIndex: s.Ember.computed("root.session.myTeam.[]", function () {
            const e = (this.get("root.session.myTeam") || []).indexOf(this);
            if (e > -1) return e;
          }),
          enemyIndex: s.Ember.computed(
            "root.session.theirTeam.[]",
            function () {
              const e = (this.get("root.session.theirTeam") || []).indexOf(
                this,
              );
              if (e > -1) return e;
            },
          ),
          summonerIndex: s.Ember.computed(
            "enemyIndex",
            "allyIndex",
            function () {
              return void 0 !== this.get("enemyIndex")
                ? this.get("enemyIndex")
                : void 0 !== this.get("allyIndex")
                  ? this.get("allyIndex")
                  : void 0;
            },
          ),
          spell1: s.Ember.computed(
            "root.spells.@each.id",
            "spell1Id",
            function () {
              return (this.get("root.spells") || s.Ember.A()).findBy(
                "id",
                this.get("spell1Id"),
              );
            },
          ),
          spell2: s.Ember.computed(
            "root.spells.@each.id",
            "spell2Id",
            function () {
              return (this.get("root.spells") || s.Ember.A()).findBy(
                "id",
                this.get("spell2Id"),
              );
            },
          ),
          selectedWardSkin: s.Ember.computed(
            "root.wardSkins.@each.id",
            "wardSkinId",
            function () {
              return (this.get("root.wardSkins") || s.Ember.A()).findBy(
                "id",
                this.get("wardSkinId"),
              );
            },
          ),
          trade: s.Ember.computed(
            "cellId",
            "root.session.trades.@each.cellId",
            function () {
              return (this.get("root.session.trades") || s.Ember.A()).findBy(
                "cellId",
                this.get("cellId"),
              );
            },
          ),
          _preloadSelectedSkinSplash: s.Ember.observer(
            "selectedSkinId",
            function () {
              if (this.get("selectedSkinId") && this.get("champion.skins")) {
                const e = this.get("champion.skins").findBy(
                  "id",
                  this.get("selectedSkinId"),
                );
                if (e) {
                  new Image().src = e.get("splashPath");
                }
              }
            },
          ),
        });
        e.exports = i;
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        const i = n(1),
          { Ember: o, EmberAddons: a } = i,
          { EmberHelpers: r } = i,
          { RunMixin: l } = a.EmberLifeline,
          c = o.Object.extend(l, {
            timeRemaining: r.computedGate.immediate(
              "timeRemainingInMs",
              function () {
                const e = this.get("timeRemainingInMs");
                if (void 0 !== e) return Math.floor(e / 1e3);
              },
            ),
            timeRemainingInMs: o.computed(
              "internalNowInEpochMs",
              "adjustedTimeLeftInPhase",
              function () {
                if ((this.updateTimer(), this.get("internalNowInEpochMs"))) {
                  const e =
                    new Date().getTime() -
                    parseFloat(this.get("internalNowInEpochMs"));
                  return Math.max(this.get("adjustedTimeLeftInPhase") - e, 0);
                }
                return this.get("adjustedTimeLeftInPhase");
              },
            ),
            timerAvailable: o.computed.gt("timeRemaining", 0),
            updateTimer: function () {
              this.isDestroyed ||
                this.isDestroying ||
                this.timerRunning ||
                ((this.timerRunning = !0),
                this.get("timeRemainingInMs") > 0
                  ? (this.notifyPropertyChange("timeRemainingInMs"),
                    this.runTask(function () {
                      (this.timerRunning = !1), this.updateTimer();
                    }, 333))
                  : (this.timerRunning = !1));
            },
            inPlanningPhase: o.computed.equal("phase", s.TIMER_PHASES.planning),
            notInPlanningPhase: o.computed.not("inPlanningPhase"),
            inBanPickPhase: o.computed.equal("phase", s.TIMER_PHASES.banPick),
            notInBanPickPhase: o.computed.not("inBanPickPhase"),
            inFinalizationPhase: o.computed.equal(
              "phase",
              s.TIMER_PHASES.finalization,
            ),
            notInFinalizationPhase: o.computed.not("inFinalizationPhase"),
            inGameStartingPhase: o.computed.equal(
              "phase",
              s.TIMER_PHASES.gameStarting,
            ),
            notInGameStartingPhase: o.computed.not("inGameStartingPhase"),
            timerLessThan11Seconds: o.computed(
              "timeRemaining",
              "isInfinite",
              function () {
                return (
                  this.get("timeRemaining") < 11 && !this.get("isInfinite")
                );
              },
            ),
            exists: r.computedGate.immediate("timeRemaining", function () {
              return void 0 !== this.get("timeRemaining");
            }),
          });
        e.exports = c;
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        const i = n(1),
          { Ember: o } = i,
          { EmberHelpers: a } = i,
          r = i.Lodash,
          l = o.Object.extend({
            champion: o.computed(
              "root.inventory.@each.id",
              "championId",
              function () {
                return (this.get("root.inventory") || o.A()).findBy(
                  "id",
                  this.get("championId"),
                );
              },
            ),
            actor: o.computed(
              "actorCellId",
              "root.summoners.@each.cellId",
              function () {
                return (this.get("root.summoners") || o.A()).findBy(
                  "cellId",
                  this.get("actorCellId"),
                );
              },
            ),
            isOnLeftSide: o.computed.alias("actor.isOnLeftSide"),
            isCeremony: o.computed("type", function () {
              return Object.keys(s.CEREMONIES).some(
                (e) => s.CEREMONIES[e] === this.get("type"),
              );
            }),
            isBanShowcase: o.computed.equal("type", s.CEREMONIES.tenBansReveal),
            isPhaseTransition: o.computed("type", function () {
              return (
                this.get("type") === s.CEREMONIES.phaseTransition ||
                this.get("type") === s.CEREMONIES.voteTransition
              );
            }),
            isVoteReveal: o.computed.equal("type", s.CEREMONIES.voteReveal),
            isVoteTransition: o.computed.equal(
              "type",
              s.CEREMONIES.voteTransition,
            ),
            isBan: o.computed("type", function () {
              return "ban" === this.get("type");
            }),
            isPick: o.computed("type", function () {
              return "pick" === this.get("type");
            }),
            isVote: o.computed("type", function () {
              return "vote" === this.get("type");
            }),
            isPickOrBanOrVote: o.computed.or("isBan", "isPick", "isVote"),
            isActive: a.computedGate(
              "root.sessionActions.activeActions.@each.id",
              "id",
              function () {
                return !!this.get("root.sessionActions.activeActions").findBy(
                  "id",
                  this.get("id"),
                );
              },
            ),
            isCurrent: a.computedGate(
              "root.sessionActions.currentActions.@each.id",
              "id",
              function () {
                return !!this.get("root.sessionActions.currentActions").findBy(
                  "id",
                  this.get("id"),
                );
              },
            ),
            isNext: a.computedGate(
              "root.sessionActions.nextActions.@each.id",
              "id",
              function () {
                return !!this.get("root.sessionActions.nextActions").findBy(
                  "id",
                  this.get("id"),
                );
              },
            ),
            indexInActionSet: o.computed(
              "root.session.actions.[]",
              function () {
                const e = this.get("root.session.actions");
                return (r.find(e, (e) => e.contains(this)) || []).indexOf(this);
              },
            ),
            snipedPlayerPick: o.computed(
              "root.currentSummoner",
              "root.currentSummoner.lastPickSnipedChampion",
              "champion",
              "actor",
              function () {
                return (
                  this.get("actor") !== this.get("root.currentSummoner") &&
                  this.get("champion") ===
                    this.get("root.currentSummoner.lastPickSnipedChampion")
                );
              },
            ),
          });
        e.exports = l;
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = (s = n(150)) && s.__esModule ? s : { default: s };
        const a = n(1),
          { Ember: r } = a,
          { EmberHelpers: l } = (a.UiKitPlugin.getToastManager(), a);
        n(172);
        const c = r.Object.extend({
            summonerName: r.computed.alias(
              "parentComponent.computedDisplayName",
            ),
            tra: r.computed.alias("parentComponent.root.tra"),
            boostedSkinsMessage: r.computed.alias(
              "parentComponent.toastBodyText",
            ),
          }),
          u = r.Object.extend({
            _alreadySentChatMessagesChampionIds: [],
            _chatBinding: null,
            init() {
              this._super(...arguments),
                (this._chatBinding = (0, i.DataBinding)(
                  "/lol-chat",
                  (0, i.getProvider)().getSocket(),
                ));
            },
            computedDisplayName: r.computed(
              "root.session.myTeam.@each.gameName",
              "root.session.myTeam.@each.displayName",
              "root._playerNames",
              "summonerId",
              function () {
                const e = this.get("root.session.myTeam"),
                  t = this.get("root._playerNames");
                if (e && t) {
                  const n = e.findBy("summonerId", this.get("summonerId"));
                  return n ? t.formatPlayerName(n).playerNameFull : "";
                }
                return "";
              },
            ),
            onPhaseChange: l.observer(
              "root.session.timer.inFinalizationPhase",
              function () {
                this.get("root.session.timer.inFinalizationPhase") &&
                  ((this._showedTeamBoostNotification = !1),
                  (this._alreadySentChatMessagesChampionIds = []));
              },
            ),
            boostToastOpen: !1,
            boostToastData: null,
            boostToastClosed() {
              this.set("boostToastOpen", !1);
            },
            onTeamBoost: l.observer("boostedSkins.[]", "unlocked", function () {
              const e = this.get("unlocked");
              if (!e || !this.get("boostedSkins.length")) return;
              const t = this.get("conversationId"),
                n = e && !this._showedTeamBoostNotification;
              this._showedTeamBoostNotification ||
                (this.playTeamBoostSound(),
                this.displayBoostNotification(),
                (this._showedTeamBoostNotification = !0)),
                t &&
                  (n
                    ? this.displayBoostGeneralMessage(t).then(() => {
                        this.displayBoostIpMessage(t).then(() => {
                          this.displayBoostSkinMessages(t);
                        });
                      })
                    : this.displayBoostSkinMessages(t));
            }),
            displayBoostNotification: function () {
              this.setProperties({
                boostToastData: c.create({ parentComponent: this }),
                boostToastOpen: !0,
              });
            },
            boostPurchaserIsSelf: r.computed(
              "root.currentSummoner.summonerId",
              "summonerId",
              function () {
                return (
                  this.get("root.currentSummoner.summonerId") ===
                  this.get("summonerId")
                );
              },
            ),
            boostableSkinCount: r.computed.readOnly(
              "root.session.boostableSkinCount",
            ),
            boostedSkins: r.computed(
              "boostedSkinIds.[]",
              "root.currentSummoner.champion.skins.@each.id",
              function () {
                const e = this.get("boostedSkinIds"),
                  t = this.get("root.currentSummoner.champion.skins") || [];
                return r.A(
                  t.filter(function (t) {
                    return e.indexOf(r.get(t, "id")) >= 0;
                  }),
                );
              },
            ),
            boostedSkinIds: r.computed(
              "availableSkins.[]",
              "root.currentSummoner.champion.id",
              function () {
                return r.A(this.get("availableSkins"));
              },
            ),
            toastBodyText: r.computed(
              "boostedSkins.[]",
              "computedDisplayName",
              "ipAmount",
              "root.tra",
              "root.tra.boost_you_unlocked_message",
              "boostPurchaserIsSelf",
              function () {
                const e = this.get("boostPurchaserIsSelf")
                  ? "boost_you_unlocked_message"
                  : "boost_summoner_unlocked_message";
                return this.getTranslatedListMessage(e, !0);
              },
            ),
            skinsChatText: r.computed(
              "boostedSkins.[]",
              "computedDisplayName",
              "ipAmount",
              "root.tra",
              "root.tra.boost_success_skin_chat_message",
              function () {
                return this.getTranslatedListMessage(
                  "boost_success_skin_chat_message",
                  !1,
                );
              },
            ),
            getTranslatedListMessage(e, t) {
              const n = this.get("boostedSkins.length"),
                s = this.get("root.tra");
              return (0 === n && !t) || !s
                ? ""
                : n <= 1
                  ? ((e += 1 === n ? "_single" : "_noskins"),
                    s.formatString(e, {
                      summonerName: this.get("computedDisplayName"),
                      skinName: this.get("boostedSkins.firstObject.name"),
                      ip: this.get("ipAmount"),
                    }))
                  : 2 === n
                    ? ((e += "_double"),
                      s.formatString(e, {
                        summonerName: this.get("computedDisplayName"),
                        ip: this.get("ipAmount"),
                        skinName1: this.get("boostedSkins")[0].name,
                        skinName2: this.get("boostedSkins")[1].name,
                      }))
                    : ((e += "_multi"),
                      s.formatString(e, {
                        summonerName: this.get("computedDisplayName"),
                        ip: this.get("ipAmount"),
                        skinNameList: this.joinWithoutLast(
                          this.get("boostedSkins").map((e) => e.get("name")),
                          ", ",
                        ),
                        lastSkinName: this.get("boostedSkins.lastObject.name"),
                      }));
            },
            joinWithoutLast: function (e, t) {
              return e.splice(0, e.length - 1).join(t);
            },
            ipAmount: r.computed(
              "ipReward",
              "ipRewardForPurchaser",
              "boostPurchaserIsSelf",
              function () {
                return this.get("boostPurchaserIsSelf")
                  ? this.get(
                      "root.jmxSettings.TeamBuilderDraft.BattleBoostPurchaserRewardBE",
                    ) || 200
                  : this.get(
                      "root.jmxSettings.TeamBuilderDraft.BattleBoostedPlayerRewardBE",
                    ) || 100;
              },
            ),
            playSfxUISound: function (e) {
              const t = "/fe/lol-champ-select/sounds/" + e;
              o.default.playSound("sfx-notifications", t);
            },
            playTeamBoostSound: function () {
              this.playSfxUISound("sfx-cs-notif-boost-unlocked.ogg");
            },
            conversationId: r.computed(
              "root.conversations.@each.id",
              "root.conversations.@each.type",
              function () {
                if (!this.get("root.conversations.length")) return;
                const e = this.get("root.conversations").findBy(
                  "type",
                  "championSelect",
                );
                if (e) {
                  const t = e.get("id");
                  if (t) return encodeURIComponent(t);
                }
              },
            ),
            displayBoostGeneralMessage: function (e) {
              const t = this.get("root.tra");
              let n;
              n = this.get("boostPurchaserIsSelf")
                ? t.formatString("boost_success_general_chat_message_self")
                : t.formatString("boost_success_general_chat_message_other", {
                    summonerName: this.get("computedDisplayName"),
                  });
              const s = { body: n, type: "celebration" };
              return this._chatBinding.post(
                `/v1/conversations/${e}/messages`,
                s,
              );
            },
            displayBoostIpMessage: function (e) {
              const t = this.get("root.tra"),
                n = this.get("ipAmount"),
                s = {
                  body: t.formatString("boost_success_ip_chat_message", {
                    amount: n,
                  }),
                  type: "celebration",
                };
              return this._chatBinding.post(
                `/v1/conversations/${e}/messages`,
                s,
              );
            },
            displayBoostSkinMessages: function (e) {
              const t = this.get("boostedSkins.firstObject.championId");
              if (-1 !== this._alreadySentChatMessagesChampionIds.indexOf(t))
                return;
              const n = this.get("skinsChatText");
              if (!n) return;
              const s = { body: n, type: "celebration" };
              this._chatBinding.post(`/v1/conversations/${e}/messages`, s),
                this._alreadySentChatMessagesChampionIds.push(t);
            },
          });
        e.exports = u;
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var n = i(t);
          if (n && n.has(e)) return n.get(e);
          var s = {},
            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a in e)
            if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
              var r = o ? Object.getOwnPropertyDescriptor(e, a) : null;
              r && (r.get || r.set)
                ? Object.defineProperty(s, a, r)
                : (s[a] = e[a]);
            }
          (s.default = e), n && n.set(e, s);
          return s;
        })(n(1));
        function i(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (i = function (e) {
            return e ? n : t;
          })(e);
        }
        n(173);
        const o = s.Ember.Component.extend({
          classNames: ["boost-notification-container"],
          layout: n(174),
          bodyText: s.Ember.computed.alias("boostedSkinsMessage"),
        });
        e.exports = o;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "Yz8bVv62",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\boost-notification-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\boost-notification-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\boost-notification-component\\\\index.js\\" "],["text","\\n"],["open-element","lol-uikit-content-block",[]],["static-attr","type","notification"],["flush-element"],["text","\\n  "],["open-element","h4",[]],["static-attr","class","boost-notification-title"],["flush-element"],["append",["unknown",["tra","boost_unlocked_title"]],false],["close-element"],["text","\\n  "],["open-element","p",[]],["static-attr","class","boost-body"],["flush-element"],["append",["helper",["sanitize"],[["get",["bodyText"]]],null],false],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(152);
        const i = n(1),
          { Ember: o, EmberAddons: a } = i,
          r = i.Lodash,
          { RunMixin: l } = a.EmberLifeline,
          c = i
            .getProvider()
            .get("rcp-fe-audio")
            .getChannel("music-champ-selection"),
          u = i.getProvider().get("rcp-fe-audio").getChannel("sfx-ui"),
          m = [
            "/fe/lol-champ-select/sounds/music-cs-draft-pick-base-layer-01.ogg",
            "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-01.ogg",
            "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-02.ogg",
            "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-03.ogg",
            "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-04.ogg",
          ];
        var d = o.Mixin.create(l, {
          champSelectMusicFile: o.computed.alias(
            "map.assets.champ-select-background-sound",
          ),
          startMusicSyncedToEndOfChampSelect: function (e) {
            const t = this.get("champSelectMusic"),
              n = this.get("champSelectMusicFile"),
              s = () => {
                this.runTask(() => {
                  if (this.get("champSelectMusicFile") !== n || t.isPlaying())
                    return void this.removeObserver(
                      "session.timer.timeRemaining",
                      this,
                      s,
                    );
                  const i = this.get("session.timer.timeRemaining");
                  i &&
                    (this.removeObserver(
                      "session.timer.timeRemaining",
                      this,
                      s,
                    ),
                    t.play({
                      offset: Math.max(e / 1e3 - i, 0),
                      when: Math.max(i - e / 1e3, 0),
                    }));
                }, 1);
              };
            this.addObserver("session.timer.timeRemaining", this, s), s();
          },
          startDraftMusic: function () {
            const e = this.get("champSelectMusicFile");
            let t;
            this.draftMusicTracks || (this.draftMusicTracks = new Map()),
              this.draftPlayingTracks || (this.draftPlayingTracks = []);
            const n = function () {
              if (
                !this.isDestroying &&
                !this.isDestroyed &&
                this.draftMusicTracks
              )
                return this.get("champSelectMusicFile") === e &&
                  (this.get("isDraftMode") ||
                    this.get("isBlindWithBans") ||
                    this.get("isRandomWithBans"))
                  ? void this.processDraftMusicChange()
                  : (this.removeObserver(
                      "sessionActions.activeAction",
                      this,
                      t,
                    ),
                    this.removeObserver(
                      "sessionActions.numBanActionsCompleted",
                      this,
                      t,
                    ),
                    this.removeObserver(
                      "sessionActions.numPickActionsCompleted",
                      this,
                      t,
                    ),
                    void this.removeObserver("session.timer.phase", this, t));
            }.bind(this);
            (t = function () {
              o.run.once(this, n);
            }.bind(this)),
              this.addObserver("sessionActions.activeAction", this, t),
              this.addObserver(
                "sessionActions.numBanActionsCompleted",
                this,
                t,
              ),
              this.addObserver(
                "sessionActions.numPickActionsCompleted",
                this,
                t,
              ),
              this.addObserver("session.timer.phase", this, t),
              t();
          },
          isDraftMode: o.computed("queue.gameTypeConfig.pickMode", function () {
            return s.DRAFT_PICK_MODES.includes(
              this.get("queue.gameTypeConfig.pickMode"),
            );
          }),
          isBlindWithBans: o.computed(
            "sessionActions.hasBans",
            "sessionActions.allPlayersPickTogether",
            "sessionActions.allPlayersVoteTogether",
            function () {
              const e = this.get("sessionActions.hasBans"),
                t =
                  this.get("sessionActions.allPlayersPickTogether") ||
                  this.get("sessionActions.allPlayersVoteTogether");
              return e && t;
            },
          ),
          isRandomWithBans: o.computed(
            "sessionActions.hasBans",
            "sessionActions.hasPicksOrVotes",
            "gameflow.gameData.isCustomGame",
            function () {
              const e = this.get("sessionActions.hasBans"),
                t = !this.get("sessionActions.hasPicksOrVotes");
              return !this.get("gameflow.gameData.isCustomGame") && e && t;
            },
          ),
          preloadDraftPickPhaseMusicTracks: function () {
            this.draftMusicTracks &&
              m.forEach((e) => {
                if (!this.draftMusicTracks.get(e)) {
                  const t = c.createSound(e);
                  t.ready(), this.draftMusicTracks.set(e, t);
                }
              });
          },
          processDraftMusicChange: function () {
            const e = this.get("sessionActions.activeAction"),
              t =
                this.get("sessionActions.nextActions") &&
                this.get("sessionActions.nextActions.length") &&
                this.get("sessionActions.nextActions.firstObject"),
              n = e && t && e.get("isPhaseTransition"),
              s = this.get("sessionActions.isSimultaneousBans")
                ? 4
                : this.get("sessionActions.numBanActionsCompleted"),
              i = this.get("isBlindWithBans")
                ? 10
                : this.get("sessionActions.numPickActionsCompleted"),
              o =
                (e && (e.get("isBan") || e.get("isBanShowcase"))) ||
                (!e && 0 === i) ||
                (n && t.get("isBan")),
              a =
                (e && (e.get("isPick") || e.get("isVote"))) ||
                (!e && i > 0) ||
                (n && (t.get("isPick") || t.get("isVote"))),
              r =
                this.get("sessionActions.finalizationPhaseActions.length") > 0,
              l =
                this.get("session.timer.inFinalizationPhase") &&
                (!r || (r && !t)),
              c = [];
            if (this.get("session.timer.inPlanningPhase"))
              (this.planningToBanTransitionSoundPlayed = !1),
                s >= 0 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pickintent-01.ogg",
                    volume: 0.37,
                    isMasterTrack: !0,
                    delayBeforeStop: 1578,
                  }),
                window.setTimeout(() => {
                  this.preloadDraftPickPhaseMusicTracks();
                }, 8e3);
            else if (this.get("session.timer.inBanPickPhase") && o)
              if (
                (0 !== i ||
                  this.planningToBanTransitionSoundPlayed ||
                  (u.playSound(
                    "/fe/lol-champ-select/sounds/music-cs-draft-pickintent-to-ban-trans-01.ogg",
                  ),
                  (this.planningToBanTransitionSoundPlayed = !0)),
                (this.banToPickTransitionSoundPlayed = !1),
                (this.finalizationTransitionSoundPlayed = !1),
                this.get("isRandomWithBans"))
              ) {
                const e = this.get(
                  "map.assets.champ-select-banphase-background-sound",
                );
                c.push({ path: e, volume: 0.37, isMasterTrack: !0 });
              } else
                s >= 0 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-base-layer-01.ogg",
                    volume: 0.37,
                    delay: 1578,
                    isMasterTrack: !0,
                  }),
                  s >= 1 &&
                    c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-01.ogg",
                      volume: 0.185,
                    }),
                  s >= 2 &&
                    (c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-01.ogg",
                      volume: 0.27749999999999997,
                    }),
                    c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-02.ogg",
                      volume: 0.185,
                    })),
                  s >= 3 &&
                    (c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-01.ogg",
                      volume: 0.37,
                    }),
                    c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-02.ogg",
                      volume: 0.27749999999999997,
                    })),
                  s >= 4 &&
                    c.push({
                      path: "/fe/lol-champ-select/sounds/music-cs-draft-ban-intensity-layer-02.ogg",
                      volume: 0.37,
                    });
            else if (this.get("session.timer.inBanPickPhase") && a)
              (0 !== i && !this.get("isBlindWithBans")) ||
                this.banToPickTransitionSoundPlayed ||
                (u.playSound(
                  "/fe/lol-champ-select/sounds/music-cs-draft-ban-to-pick-trans-01.ogg",
                ),
                (this.banToPickTransitionSoundPlayed = !0)),
                i >= 0 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-base-layer-01.ogg",
                    volume: 0.37,
                    isMasterTrack: !0,
                  }),
                i >= 1 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-01.ogg",
                    volume: 0.185,
                  }),
                i >= 2 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-02.ogg",
                    volume: 0.185,
                  }),
                i >= 3 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-01.ogg",
                    volume: 0.27749999999999997,
                  }),
                i >= 4 &&
                  (c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-02.ogg",
                    volume: 0.27749999999999997,
                  }),
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-03.ogg",
                    volume: 0.185,
                  })),
                i >= 5 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-01.ogg",
                    volume: 0.37,
                  }),
                i >= 6 &&
                  (c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-02.ogg",
                    volume: 0.37,
                  }),
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-03.ogg",
                    volume: 0.27749999999999997,
                  }),
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-04.ogg",
                    volume: 0.185,
                  })),
                i >= 7 &&
                  (c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-03.ogg",
                    volume: 0.37,
                  }),
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-04.ogg",
                    volume: 0.27749999999999997,
                  })),
                i >= 8 &&
                  c.push({
                    path: "/fe/lol-champ-select/sounds/music-cs-draft-pick-intensity-layer-04.ogg",
                    volume: 0.37,
                  });
            else if (l) {
              const e =
                60 - this.get("session.timer.timeRemaining") < 0
                  ? 0
                  : 60 - this.get("session.timer.timeRemaining");
              !this.finalizationTransitionSoundPlayed &&
                e > 0 &&
                (u.playSound(
                  "/fe/lol-champ-select/sounds/music-cs-draft-ban-to-pick-trans-01.ogg",
                ),
                (this.finalizationTransitionSoundPlayed = !0));
              let t =
                "/fe/lol-champ-select/sounds/music-cs-draft-finalization-60sec-01.ogg";
              this.get("isRandomWithBans") &&
                (t = this.get("champSelectMusicFile")),
                c.push({
                  path: t,
                  volume: 0.37,
                  loop: !1,
                  offset: e,
                  isMasterTrack: !0,
                });
            }
            let m = [];
            return (
              c.length && (m = this.startOrContinueDraftMusicTracks(c)),
              this.stopDraftMusicTracks(m),
              c
            );
          },
          playMusicTrack: function (e, t) {
            return (
              this.draftMasterTrack && !t.isMasterTrack
                ? (e.audioElement.currentTime =
                    this.draftMasterTrack.audioElement.currentTime)
                : (e.audioElement.currentTime = 0),
              e.ready().then(() => {
                const n = e.play({ offset: t.offset || !1 });
                if (this.draftMasterTrack && !t.isMasterTrack) {
                  e.audioElement.currentTime =
                    this.draftMasterTrack.audioElement.currentTime;
                  const t = window.setInterval(() => {
                    if (
                      !(
                        e &&
                        e.audioElement &&
                        this.draftMasterTrack &&
                        this.draftMasterTrack.audioElement
                      )
                    )
                      return void window.clearInterval(t);
                    const n =
                      e.audioElement.currentTime -
                      this.draftMasterTrack.audioElement.currentTime;
                    (n > 0.05 || n < -0.05) &&
                      (e.audioElement.currentTime =
                        this.draftMasterTrack.audioElement.currentTime);
                  }, 1e3);
                }
                return (
                  t.fadeIn
                    ? e.fade(0, t.volume, t.fadeIn || 1e3)
                    : this.draftMasterTrack &&
                      !t.isMasterTrack &&
                      e.setVolume(t.volume),
                  n
                );
              })
            );
          },
          scheduleMusicTrackPlay: function (e, t) {
            const n = this.draftMasterTrack && !t.isMasterTrack;
            if (e && !e.playbackScheduled) {
              e.playbackScheduled = !0;
              const s = window.performance.now();
              let i = 0;
              if (
                (e.options.delayedUntilTime &&
                  (i = e.options.delayedUntilTime - s),
                n && this.draftMasterTrack.options.delayedUntilTime)
              ) {
                const e = this.draftMasterTrack.options.delayedUntilTime - s;
                e > i && (i = e);
              }
              if (!(i > 0)) return this.playMusicTrack(e, t);
              window.setTimeout(() => {
                if (e) return this.playMusicTrack(e, t);
              }, i);
            }
          },
          startOrContinueDraftMusicTracks: function (e) {
            const t = {};
            return (
              e.forEach((e) => {
                let n = this.draftMusicTracks.get(e.path);
                if (
                  (n && this.draftPlayingTracks.indexOf(e.path) >= 0) ||
                  void 0 !== t[e.path]
                )
                  t[e.path] = e.volume || 1;
                else {
                  const s = {
                    isLoop: void 0 === e.loop || e.loop,
                    fadeOut: void 0 === e.fadeOut ? 1263 : e.fadeOut,
                    delayedUntilTime: e.delay
                      ? window.performance.now() + e.delay
                      : void 0,
                    delayBeforeStop: e.delayBeforeStop,
                    offset: e.offset || !1,
                  };
                  n
                    ? (n.audioElement &&
                        (n.audioElement.loop = void 0 === e.loop || e.loop),
                      Object.assign(n.options, s))
                    : (n = c.createSound(e.path, s)),
                    (t[e.path] = e.volume);
                  ((this.draftMasterTrack && !e.isMasterTrack) || e.fadeIn) &&
                    (n.setVolume(0), (t[e.path] = 0)),
                    n
                      .ready()
                      .then(
                        () => (
                          (n.playbackScheduled = !1),
                          this.scheduleMusicTrackPlay(n, e)
                        ),
                      ),
                    this.draftMusicTracks.set(e.path, n),
                    e.isMasterTrack && (this.draftMasterTrack = n);
                }
              }),
              e.forEach((e) => {
                -1 === this.draftPlayingTracks.indexOf(e.path) &&
                  this.draftPlayingTracks.push(e.path);
              }),
              r.forEach(t, (e, t) => {
                const n = this.draftMusicTracks.get(t);
                n.ready().then(() => {
                  n.setVolume(e);
                });
              }),
              r.keys(t) || []
            );
          },
          stopDraftMusicTracks: function (e) {
            this.draftPlayingTracks &&
              (this.draftPlayingTracks = this.draftPlayingTracks.filter((t) => {
                if (-1 === e.indexOf(t)) {
                  const e = this.draftMusicTracks.get(t);
                  this.draftMusicTracks.delete(t);
                  const n = () => {
                      e.ready().then(
                        () => (
                          (e.audioElement.src = ""),
                          setTimeout(() => {
                            e && e.dispose();
                          }, 5e3),
                          null
                        ),
                      );
                    },
                    s = () => {
                      e.options.fadeOut
                        ? (e.fadeOut(e.options.fadeOut, { stop: !0 }),
                          e.on("stop", () => {
                            n();
                          }))
                        : (e.setVolume(0),
                          e
                            .ready()
                            .then(() => (e.stop(), null))
                            .then(() => (n(), null)));
                    };
                  return (
                    e.options.delayBeforeStop
                      ? window.setTimeout(() => {
                          s();
                        }, e.options.delayBeforeStop)
                      : s(),
                    this.draftMasterTrack === t &&
                      (this.draftMasterTrack = null),
                    !1
                  );
                }
                return !0;
              }));
          },
          startChampSelectMusic: o.observer(
            "champSelectMusicFile",
            "queue.gameTypeConfig.pickMode",
            "isDraftMode",
            "isBlindWithBans",
            "isShown",
            o.on("init", function () {
              o.run.once(this, function () {
                if (
                  !this.get("isShown") ||
                  !this.get("queue.gameTypeConfig.pickMode") ||
                  this.get("musicStarted")
                )
                  return;
                const e = this.get("champSelectMusicFile");
                this.get("isDraftMode") ||
                this.get("isBlindWithBans") ||
                this.get("isRandomWithBans")
                  ? (this.startDraftMusic(), this.set("musicStarted", !0))
                  : e &&
                    (this.set(
                      "champSelectMusic",
                      c.createSound(e, { fadeIn: !0 }),
                    ),
                    this.get("champSelectMusic")
                      .ready()
                      .then(
                        function () {
                          return this.get("champSelectMusicFile") === e &&
                            this.get("isShown")
                            ? ("AllRandomPickStrategy" ===
                              this.get("queue.gameTypeConfig.pickMode")
                                ? this.startMusicSyncedToEndOfChampSelect(76831)
                                : this.get("champSelectMusic").play(),
                              null)
                            : null;
                        }.bind(this),
                      ),
                    this.set("musicStarted", !0));
              });
            }),
          ),
          stopAllTracks: function () {
            this.draftPlayingTracks &&
              this.draftPlayingTracks.length &&
              (this.stopDraftMusicTracks([]),
              delete this.draftMusicTracks,
              delete this.draftPlayingTracks);
            const e = this.get("champSelectMusic");
            e && e.isPlaying() && e.stop(),
              e && (e.dispose(), this.set("champSelectMusic", null)),
              this.set("musicStarted", !1);
          },
          stopChampSelectMusicOnHide: o.observer("isShown", function () {
            this.get("isShown") || this.stopAllTracks();
          }),
        });
        t.default = d;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default =
            t.TRADE_STATES =
            t.TRADE_RESOLVED_STATES =
            t.TRADE_CREATED_STATES =
            t.TRADE_CLEAR_TIMEOUT_MS =
            t.TRADE_CANCEL_TIMEOUT_MS =
            t.ACCEPTED_TIMEOUT_MS =
              void 0);
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = r(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = a(n(158)),
          o = a(n(150));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function r(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (r = function (e) {
            return e ? n : t;
          })(e);
        }
        const { RunMixin: l } = s.EmberAddons.EmberLifeline;
        n(177);
        const c = {
          RECEIVED: "RECEIVED",
          AVAILABLE: "AVAILABLE",
          SENT: "SENT",
          BUSY: "BUSY",
          DECLINED: "DECLINED",
          ACCEPTED: "ACCEPTED",
          CANCELLED: "CANCELLED",
        };
        t.TRADE_STATES = c;
        const u = [c.ACCEPTED, c.DECLINED, c.CANCELLED, c.BUSY];
        t.TRADE_RESOLVED_STATES = u;
        const m = [c.RECEIVED, c.SENT, c.BUSY];
        t.TRADE_CREATED_STATES = m;
        t.TRADE_CANCEL_TIMEOUT_MS = 15e3;
        t.TRADE_CLEAR_TIMEOUT_MS = 1700;
        t.ACCEPTED_TIMEOUT_MS = 200;
        const d = "session/trades",
          p = "cancel",
          h = "accept",
          g = "decline",
          f = "clear";
        var S = s.Ember.Component.extend(l, {
          layout: n(178),
          init: function () {
            this._super(...arguments),
              (this.audioPool = o.default),
              this.set("isAnimated", !0);
          },
          didRender: function () {
            this._super(...arguments),
              this.cancelTask(this._tradeCancelTimeout),
              this.cancelTask(this._tradeClearTimeout);
            const e = this.get("trade");
            e.state === c.SENT && this.scheduleTradeCancel(e.id),
              m.includes(e.state) &&
                (this.set("isDisplayed", !0),
                this.setSummonerName(e.otherSummonerIndex),
                this.positionTradeDialog(e.otherSummonerIndex)),
              u.includes(e.state) && this.scheduleTradeClear(e.id, e.state),
              this.prevTradeState !== e.state && this.playTradeSfx(e.state),
              (this.prevTradeState = e.state);
          },
          positionTradeDialog: function (e) {
            const t = [
                ...document.querySelectorAll(
                  ".your-party .champion-icon-container",
                ),
              ][e].getBoundingClientRect(),
              n = this.element.querySelector(".trade-dialog");
            (n.style.top = t.top - 5 + "px"),
              (n.style.left = `${t.left + t.width + 15}px`);
          },
          setSummonerName: function (e) {
            const t = this.get("summoners");
            t &&
              e >= 0 &&
              t[e] &&
              t[e].displayName &&
              this.set("otherSummonerName", t[e].displayName);
          },
          playTradeSfx: function (e) {
            let t = "";
            switch (e) {
              case c.SENT:
              case c.RECEIVED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-traderequest-rcvd.ogg";
                break;
              case c.ACCEPTED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-traderequest-accepted.ogg";
                break;
              case c.DECLINED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-traderequest-declined.ogg";
            }
            t && this.audioPool.playSound("sfx-notifications", t);
          },
          scheduleTradeCancel: function (e) {
            this._tradeCancelTimeout = this.runTask(
              () => this.tradeServiceCall(e, d, p),
              15e3,
            );
          },
          scheduleTradeClear: function (e, t) {
            const n = t === c.ACCEPTED ? 200 : 1700;
            this._tradeClearTimeout = this.runTask(
              () => (
                this.set("isDisplayed", !1),
                this.tradeServiceCall(e, "ongoing-trade", f)
              ),
              n,
            );
          },
          showCancelTradeButton: s.Ember.computed.equal("trade.state", c.SENT),
          showAcceptTradeButton: s.Ember.computed.equal(
            "trade.state",
            c.RECEIVED,
          ),
          isCloseButtonDisabled: s.Ember.computed("trade.state", function () {
            return u.includes(this.get("trade.state"));
          }),
          tradeStateClass: s.Ember.computed("trade.state", function () {
            return this.get("trade.state").toLowerCase();
          }),
          isTradeInProgress: s.Ember.computed("trade.state", function () {
            const e = this.get("trade.state");
            return e === c.SENT || e === c.RECEIVED;
          }),
          tradeMessageString: s.Ember.computed(
            "trade.state",
            "tradeWaitingString",
            "tradeCanceledString",
            "tradeDeclinedString",
            "tradeErrorString",
            function () {
              switch (this.get("trade.state")) {
                case c.SENT:
                case c.RECEIVED:
                  return this.get("tradeWaitingString");
                case c.CANCELLED:
                  return this.get("tra.pregame_trade_canceled");
                case c.DECLINED:
                  return this.get("tra.pregame_trade_declined");
                case c.BUSY:
                  return this.get("tradeBusyString");
                case c.ACCEPTED:
                  return "";
                default:
                  return this.get("tra.pregame_trade_error");
              }
            },
          ),
          tradeWaitingString: s.Ember.computed(
            "trade.initiatedByLocalPlayer",
            "trade.requesterChampionName",
            "otherSummonerName",
            "tra.pregame_trade_requested",
            "tra.pregame_trade_waiting",
            function () {
              const e = this.get("trade.initiatedByLocalPlayer"),
                t = this.get("otherSummonerName");
              return e
                ? this.get("tra.service").formatString(
                    "pregame_trade_waiting",
                    { actor: t },
                  )
                : this.get("tra.service").formatString(
                    "pregame_trade_requested",
                    {
                      actor: t,
                      entity1: this.get("trade.requesterChampionName"),
                      entity2: this.get("trade.responderChampionName"),
                    },
                  );
            },
          ),
          tradeBusyString: s.Ember.computed(
            "otherSummonerName",
            "tra.pregame_trade_error",
            function () {
              return this.get("tra.service").formatString(
                "pregame_trade_busy",
                { actor: this.get("otherSummonerName") },
              );
            },
          ),
          tradeServiceCall: function (e, t, n) {
            const o = `/lol-champ-select/v1/${t}/${e}/${n}`;
            return i.default
              .ajax({
                type: "POST",
                url: o,
                errorMessage: "error_could_not_trade",
              })
              .then(() => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!0),
                  s.Telemetry.invokeWithLowProbability(function () {
                    switch (n) {
                      case h:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-trade-accept-success",
                          1,
                          "event",
                        );
                        break;
                      case p:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-trade-cancel-success",
                          1,
                          "event",
                        );
                        break;
                      case g:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-trade-decline-success",
                          1,
                          "event",
                        );
                        break;
                      case f:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-trade-clear-success",
                          1,
                          "event",
                        );
                    }
                  });
              })
              .catch((e) => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!1, e);
                s.DataBinding.bindTo(s.default.getProvider().getSocket())
                  .get("/lol-summoner/v1/current-summoner")
                  .then(function (t) {
                    const { accountId: i, puuid: o, summonerId: a } = t;
                    s.Telemetry.invokeWithLowProbability(function () {
                      const t = e && e.responseText ? e.responseText : "",
                        r = JSON.stringify({
                          accountId: i,
                          clientDateISOString: new Date().toISOString(),
                          puuid: o,
                          responseText: t,
                          summonerId: a,
                        });
                      switch (n) {
                        case h:
                          s.Telemetry.sendEvent("champ-trade-accept-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-trade-accept-fail",
                              1,
                              "event",
                            );
                          break;
                        case p:
                          s.Telemetry.sendEvent("champ-trade-cancel-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-trade-cancel-fail",
                              1,
                              "event",
                            );
                          break;
                        case g:
                          s.Telemetry.sendEvent("champ-trade-decline-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-trade-decline-fail",
                              1,
                              "event",
                            );
                          break;
                        case f:
                          s.Telemetry.sendEvent("champ-trade-clear-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-trade-clear-fail",
                              1,
                              "event",
                            );
                      }
                    });
                  });
              });
          },
          actions: {
            acceptTrade: function (e) {
              return (
                s.Telemetry.startTracingEvent("champ-select-trade-accept"),
                this.tradeServiceCall(e, d, h).finally(() => {
                  window.requestAnimationFrame(() => {
                    s.Telemetry.endTracingEvent("champ-select-trade-accept");
                  });
                })
              );
            },
            closeTrade: function (e, t) {
              return t === c.SENT
                ? this.tradeServiceCall(e, d, p)
                : t === c.RECEIVED
                  ? this.tradeServiceCall(e, d, g)
                  : void 0;
            },
          },
        });
        t.default = S;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "8mzmvAgC",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-dialog-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-dialog-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-dialog-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["trade-dialog animated ",["helper",["unless"],[["get",["showAcceptTradeButton"]],"not-received"],null]," ",["unknown",["tradeStateClass"]]," ",["helper",["if"],[["get",["isDisplayed"]],"active"],null]]]],["flush-element"],["text","\\n  "],["open-element","lol-uikit-flyout-frame",[]],["static-attr","orientation","right"],["dynamic-attr","show",["unknown",["isDisplayed"]],null],["dynamic-attr","animated",["unknown",["isAnimated"]],null],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","trade-wrapper"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","trade-container"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-bg-container"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","champion-bg"],["dynamic-attr","style",["concat",["background-image: url(",["unknown",["trade","requesterChampionSplashPath"]],");"]]],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-bg-overlay"],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","trade-content-container"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","trade-message"],["flush-element"],["append",["unknown",["tradeMessageString"]],false],["close-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","button-group"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showAcceptTradeButton"]]],null,2],["block",["if"],[["get",["showCancelTradeButton"]]],null,1],["text","          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n"],["block",["if"],[["get",["isTradeInProgress"]]],null,0],["text","    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","        "],["open-element","div",[]],["static-attr","class","trade-timer-wrapper"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","trade-timer"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","            "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"closeTrade",["get",["trade","id"]],["get",["trade","state"]]],null],null],["flush-element"],["text","\\n               "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","decline-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_trade_cancel"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","            "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"acceptTrade",["get",["trade","id"]]],null],null],["flush-element"],["text","\\n              "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_trade_accept"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n             "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"closeTrade",["get",["trade","id"]],["get",["trade","state"]]],null],null],["flush-element"],["text","\\n               "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","decline-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_trade_decline"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        "use strict";
        const s = n(1),
          { Ember: i } = s,
          o = i.Object.extend({
            iconPath: i.computed.alias("wardImagePath"),
            locked: i.computed.not("ownership.owned"),
          });
        e.exports = o;
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "4TsLqZg/",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["position-assignment-intro-container ",["helper",["if"],[["get",["showPositionAssignmentBackground"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["position-assignment-intro"],null,[["map","mapStaticPath","isShown","hidePins","shouldPlayVideos","showPositionAssignment","pinDropSummoners","mapSide","splashDefocus"],[["get",["map"]],["get",["champSelectBackground"]],["get",["isShown"]],["get",["isNexusBlitz"]],["get",["uxSettings","largeAreaAnimationsEnabled"]],["get",["showPositionAssignment"]],["get",["pinDropSummoners"]],["get",["pinDropNotification","mapSide"]],["get",["splashDefocus"]]]]],false],["text","\\n"],["close-element"],["text","\\n\\n"],["append",["helper",["champion-splash-background"],null,[["pickJustLockedIn","splashUnlocked","splashDefocus","hasBans","splashPath","showPositionAssignment","sessionActions","currentSummoner","champSelectScreen","isDraftMode","isShowingGrid","emblems","uxSettings","jmxSettings","isShowingVoteReveal","skinAguments"],[["get",["pickJustLockedIn"]],["get",["splashUnlocked"]],["get",["splashDefocus"]],["get",["sessionActions","hasBans"]],["get",["splashPath"]],["get",["showPositionAssignment"]],["get",["sessionActions"]],["get",["currentSummoner"]],["get",["champSelectScreen"]],["get",["isDraftMode"]],["get",["isShowingGrid"]],["get",["viewSkin","emblems"]],["get",["uxSettings"]],["get",["jmxSettings"]],["get",["isShowingVoteReveal"]],["get",["skinAguments"]]]]],false],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","top-darken"],["flush-element"],["close-element"],["text","\\n\\n"],["append",["helper",["champion-splash-ring"],null,[["currentActions","champSelectScreen","uxSettings","isHeaderExpanded","shouldPlayIntroAnimation"],[["get",["sessionActions","currentActions"]],["get",["champSelectScreen"]],["get",["uxSettings"]],["get",["isHeaderExpanded"]],["get",["shouldPlaySplashRingAnimation"]]]]],false],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-select-summoner-array-container ",["helper",["if"],[["get",["session","timer","inFinalizationPhase"]],"in-finalization"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["summoner-array"],null,[["summoners","sessionActions","isUILockedForGameStart","uxSettings","showPositionAssignment","isLeft","showFirstPick","timer","currentSummoner","subteamDataList","timerDisabledPickOrderSwap","activeSwap","activeTrade","formattedTime","isPlayingSimulBanOutro","team","viewSkin","championChestAvailabilityMap","shouldShowChestAvailability","showChestAvailabilityHintedPortraits","boosterSummonerId","jmxSettings","PickOrderSwappingTooltipEnabled","ChampTradingTooltipEnabled","isCustomGame","recordDidRequestSucceed"],[["get",["myTeamSummoners"]],["get",["sessionActions"]],["get",["isUILockedForGameStart"]],["get",["uxSettings"]],["get",["showPositionAssignment"]],true,["get",["showLeftSideFirstPick"]],["get",["session","timer"]],["get",["currentSummoner"]],["get",["subteamDataList"]],["get",["timerDisabledPickOrderSwap"]],["get",["activeSwap"]],["get",["activeTrade"]],["get",["formattedTime"]],["get",["isPlayingSimulBanOutro"]],["get",["session","myTeam"]],["get",["viewSkin"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]],["get",["showChestAvailabilityHintedPortraits"]],["get",["boosterSummonerId"]],["get",["jmxSettings"]],["get",["PickOrderSwappingTooltipEnabled"]],["get",["ChampTradingTooltipEnabled"]],["get",["gameflow","gameData","isCustomGame"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n\\n  "],["append",["helper",["summoner-array"],null,[["summoners","sessionActions","isUILockedForGameStart","uxSettings","showPositionAssignment","isLeft","showFirstPick","timer","currentSummoner","subteamDataList","timerDisabledPickOrderSwap","formattedTime","isPlayingSimulBanOutro","team","jmxSettings","isCustomGame","recordDidRequestSucceed"],[["get",["theirTeamSummoners"]],["get",["sessionActions"]],["get",["isUILockedForGameStart"]],["get",["uxSettings"]],["get",["showPositionAssignment"]],false,["get",["showRightSideFirstPick"]],["get",["session","timer"]],["get",["currentSummoner"]],["get",["subteamDataList"]],["get",["timerDisabledPickOrderSwap"]],["get",["formattedTime"]],["get",["isPlayingSimulBanOutro"]],["get",["session","theirTeam"]],["get",["jmxSettings"]],["get",["gameflow","gameData","isCustomGame"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","champion-select-main-container"],["flush-element"],["text","\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["showPositionAssignment"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n    "],["append",["helper",["bans-container"],null,[["hasSimultaneousBans","myTeamBanActions","theirTeamBanActions","numBans","gameMode"],[["get",["session","hasSimultaneousBans"]],["get",["sessionActions","myTeamBanActions"]],["get",["sessionActions","theirTeamBanActions"]],["get",["session","bans","numBans"]],["get",["gameMode"]]]]],false],["text","\\n    "],["append",["helper",["timer-status"],null,[["timer","summoner","isDraftMode","activeAction","enemyActiveAction","alliedActiveAction","allPlayersActTogether","currentActions","activeActions","champSelectScreen","isShowingPositionAssignment","isSpectating","isPlayingCeremony","inFinalizationPhase","isShowingVoteCeremonies","isTeamBuilderGame","formattedTime","displayTimeAsMinuteSecond","minuteSecondTime","isHeaderExpanded","showChampionBench","inventory","benchChampions","championChestAvailabilityMap","shouldShowChestAvailability","showChestAvailabilityHintedPortraits","allowBattleBoost","isUILockedForGameStart","jmxSettings","isShowingPerksModal","boostableSkinCount","recordDidRequestSucceed"],[["get",["session","timer"]],["get",["currentSummoner"]],["get",["isDraftMode"]],["get",["sessionActions","activeAction"]],["get",["sessionActions","enemyActiveAction"]],["get",["sessionActions","alliedActiveAction"]],["get",["sessionActions","allPlayersActTogether"]],["get",["sessionActions","currentActions"]],["get",["sessionActions","activeActions"]],["get",["champSelectScreen"]],["get",["showPositionAssignment"]],["get",["isSpectating"]],["get",["isPlayingCeremony"]],["get",["session","timer","inFinalizationPhase"]],["get",["isShowingVoteCeremonies"]],["get",["queue","isTeamBuilderManaged"]],["get",["formattedTime"]],["get",["displayTimeAsMinuteSecond"]],["get",["minuteSecondTime"]],["get",["isHeaderExpanded"]],["get",["showChampionBench"]],["get",["inventory"]],["get",["benchChampions"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]],["get",["showChestAvailabilityHintedPortraits"]],["get",["session","allowBattleBoost"]],["get",["isUILockedForGameStart"]],["get",["jmxSettings"]],["get",["isShowingPerksModal"]],["get",["boostableSkinCount"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["showPickPhaseComponent"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n      "],["append",["helper",["pick-phase"],null,[["summoner","sessionActions","actionWasJustCompleted","waitingForBanAnimation","waitingForPickAnimation","map","isDraftMode","isSpectating","isPlayingSimulBanOutro","isPlayingCeremony","showVoteShowcase","champSelectScreen","splashPath","splashDefocus","splashUnlocked","timer","myTeam","theirTeam","gameId","uxSettings","jmxSettings","updateIsShowingGrid","updatePickJustLockedIn","shouldShowChestFilter","isRandomChampionEnabled","randomChampionRateLimitConfig","transitioningToSelectedScreen","recordDidRequestSucceed","UseNewLoyaltyIcon"],[["get",["currentSummoner"]],["get",["sessionActions"]],["get",["actionWasJustCompleted"]],["get",["waitingForBanAnimation"]],["get",["waitingForPickAnimation"]],["get",["map"]],["get",["isDraftMode"]],["get",["isSpectating"]],["get",["isPlayingSimulBanOutro"]],["get",["isPlayingCeremony"]],["get",["showVoteShowcase"]],["get",["champSelectScreen"]],["get",["pickSplashPath"]],["get",["pickSplashDefocus"]],["get",["pickSplashUnlocked"]],["get",["session","timer"]],["get",["session","myTeam"]],["get",["session","theirTeam"]],["get",["session","gameId"]],["get",["uxSettings"]],["get",["jmxSettings"]],["helper",["action"],[["get",[null]],["helper",["mut"],[["get",["isShowingGrid"]]],null]],null],["helper",["action"],[["get",[null]],["helper",["mut"],[["get",["pickJustLockedIn"]]],null]],null],["get",["shouldShowChestFilter"]],["get",["isRandomChampionEnabled"]],["get",["randomChampionRateLimitConfig"]],["get",["transitioningToSelectedScreen"]],["get",["recordDidRequestSucceed"]],["get",["UseNewLoyaltyIcon"]]]]],false],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",["vote-showcase-visibility-wrapper ",["helper",["if"],[["get",["showVoteShowcase"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n    "],["append",["helper",["champion-showcase-team"],null,[["showcaseActions","introAnimation"],[["get",["sessionActions","myTeamVoteActions"]],["get",["localSummonerActionComplete"]]]]],false],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",["vote-reveal-visibility-wrapper ",["helper",["if"],[["get",["isShowingVoteReveal"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n      "],["append",["helper",["vote-reveal"],null,[["visible","activeAction","summoner"],[["get",["isShowingVoteReveal"]],["get",["sessionActions","activeAction"]],["get",["currentSummoner"]]]]],false],["text","\\n    "],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["shouldShowChestAvailability"]]],null,8],["text","\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["showSkinSelectComponent"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n      "],["append",["helper",["skin-select"],null,[["summoner","map","timeRemaining","inFinalization","rootViewSkin","selectViewSkin","allActions","rerollsDisabled","showRerollButton","tbAllowRerolling","tbRerollsRemaining","uxSettings","jmxSettings","rootComponentShown","allowSkinSelection","ip","rp","timer","isSkinSelectVisible","isShowingGrid","shouldShowChestAvailability","championChestAvailabilityMap","isUILockedForGameStart","recordDidRequestSucceed","UseNewLoyaltyIcon"],[["get",["currentSummoner"]],["get",["map"]],["get",["session","timer","timeRemaining"]],["get",["session","timer","inFinalizationPhase"]],["get",["viewSkin"]],"selectViewSkin",["get",["sessionActions","allActions"]],["get",["rerollsDisabled"]],["get",["showRerollButton"]],["get",["session","allowRerolling"]],["get",["session","rerollsRemaining"]],["get",["uxSettings"]],["get",["jmxSettings"]],["get",["isShown"]],["get",["session","allowSkinSelection"]],["get",["ip"]],["get",["rp"]],["get",["session","timer"]],["get",["showSkinSelectComponent"]],["get",["isShowingGrid"]],["get",["shouldShowChestAvailability"]],["get",["championChestAvailabilityMap"]],["get",["isUILockedForGameStart"]],["get",["recordDidRequestSucceed"]],["get",["UseNewLoyaltyIcon"]]]]],false],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",["loadouts-edit-wrapper ",["helper",["if"],[["get",["isSpectating"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n      "],["append",["helper",["loadouts-edit"],null,[["localSummonerLevel","currentSummoner","champOrPickIntent","isUILockedForGameStart","showingPerksModalChanged","currentPerksPage","perksPages","perksSettings","perksTutorialSettings","gameModeSupportsPerks","map","queue","timer","jmxSettings","recordDidRequestSucceed","uxSettings","showPositionAssignment","availableSpells","perPositionRequiredSummonerSpells","perPositionDisallowedSummonerSpells","wardSkins","selectedWardSkin","accountLoadout","isCompanionsEnabled","isRuneRecommenderEnabled","unlockAllRunePageFunctionality","useRuneRecommenderAutoSelect"],[["get",["localSummoner","summonerLevel"]],["get",["currentSummoner"]],["get",["currentSummoner","champion","id"]],["get",["isUILockedForGameStart"]],"showingPerksModalChanged",["get",["currentPerksPage"]],["get",["perksPages"]],["get",["perksSettings"]],["get",["tutorial"]],["get",["gameModeSupportsPerks"]],["get",["map"]],["get",["queue"]],["get",["session","timer"]],["get",["jmxSettings"]],["get",["recordDidRequestSucceed"]],["get",["uxSettings"]],["get",["showPositionAssignment"]],["get",["availableSpells"]],["get",["perPositionRequiredSummonerSpells"]],["get",["perPositionDisallowedSummonerSpells"]],["get",["wardSkins"]],["get",["selectedWardSkin"]],["get",["accountLoadout"]],["get",["isCompanionsEnabled"]],["get",["runeRecommenderEnabled"]],["get",["unlockAllRunePageFunctionality"]],["get",["useRuneRecommenderAutoSelect"]]]]],false],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",["game-info-container ",["helper",["if"],[["get",["isSpectating"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n        "],["append",["helper",["game-info"],null,[["teamSize","mutatorName"],[["get",["queue","numPlayersPerTeam"]],["get",["queue","gameTypeConfig","name"]]]]],false],["text","\\n        "],["append",["helper",["quit-button"],null,[["disabled","isSpectating","recordDidRequestSucceed"],[["get",["disableSpectatorQuitButton"]],["get",["isSpectating"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n      "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["showGameEventInfoCard"]]],null,7],["text","\\n"],["block",["if"],[["get",["showChatRoom"]]],null,6],["text","\\n"],["open-element","div",[]],["static-attr","class","bottom-right-buttons"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showQuitButton"]]],null,5,4],["text","  "],["open-element","lol-social-chat-toggle-button",[]],["static-attr","position","inside"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"clickChat"],[["on"],["click"]]],null],["flush-element"],["close-element"],["text","\\n  "],["append",["helper",["missions-tracker"],null,[["jmxSettings","entitlements"],[["get",["jmxSettings"]],["get",["entitlements"]]]]],false],["text","\\n  "],["open-element","div",[]],["static-attr","class","champ-select-voice-button-wrapper"],["flush-element"],["append",["unknown",["voiceButton"]],false],["close-element"],["text","\\n\\n  "],["open-element","lc-toast",[]],["dynamic-attr","open",["unknown",["boostToastOpen"]],null],["dynamic-attr","onHide",["helper",["action"],[["get",[null]],"closeBoostNotificationToast"],null],null],["flush-element"],["text","\\n    "],["open-element","lc-toast-content",[]],["flush-element"],["text","\\n      "],["append",["helper",["boost-notification"],null,[["boostedSkinsMessage"],[["get",["boostToastData","boostedSkinsMessage"]]]]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["activeTrade"]]],null,2],["text","\\n"],["block",["if"],[["get",["activeSwap"]]],null,1],["text","\\n"],["block",["if"],[["get",["shouldShowDisconnectNotification"]]],null,0],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["unknown",["disconnect-notification"]],false],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","lc-layer",[]],["static-attr","index","0"],["dynamic-attr","open",true,null],["flush-element"],["text","\\n      "],["open-element","lc-layer-content",[]],["flush-element"],["text","\\n        "],["append",["helper",["swap-dialog"],null,[["swap","summoners","subteamDataList","timeRemaining","inPlanningPhase","pickOrderSwapDisabledConfigurationInSeconds","recordDidRequestSucceed"],[["get",["activeSwap"]],["get",["myTeamSummoners"]],["get",["subteamDataList"]],["get",["session","timer","timeRemaining"]],["get",["session","timer","inPlanningPhase"]],["get",["pickOrderSwapDisabledConfigurationInSeconds"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","lc-layer",[]],["static-attr","index","0"],["dynamic-attr","open",true,null],["flush-element"],["text","\\n      "],["open-element","lc-layer-content",[]],["flush-element"],["text","\\n        "],["append",["helper",["trade-dialog"],null,[["trade","summoners","recordDidRequestSucceed"],[["get",["activeTrade"]],["get",["myTeamSummoners"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","div",[]],["static-attr","class","corner-game-info-container"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","team-size"],["flush-element"],["text","\\n        "],["append",["unknown",["teamSizeText"]],false],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","queue-name"],["flush-element"],["text","\\n        "],["append",["unknown",["queueNameText"]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "]],"locals":[]},{"statements":[["block",["if"],[["get",["queueNameText"]]],null,3]],"locals":[]},{"statements":[["text","    "],["append",["helper",["quit-button"],null,[["isSpectating","disabled","recordDidRequestSucceed"],[["get",["isSpectating"]],["get",["disableQuitButton"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",["pregame-chat-box ",["helper",["if"],[["get",["isSpectating"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n    "],["open-element","lol-social-chat-room",[]],["static-attr","type","championSelect"],["dynamic-attr","summoner-ids-to-name-overrides-json",["unknown",["myTeamSummonerIdsToNameOverridesJson"]],null],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","game-event-info-card-container"],["flush-element"],["text","\\n    "],["append",["helper",["game-event-info-card"],null,[["map","eventIndex","shiftedToSide"],[["get",["map"]],["get",["lockedEventIndex"]],["get",["shiftGameEventInfoCard"]]]]],false],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["append",["helper",["champion-chest-availability"],null,[["championId","championChestAvailabilityMap","updateChestAvailabilityHintedPortraits","isShowingPerksModal","myTeamSummoners","benchChampions"],[["get",["currentSummoner","championId"]],["get",["championChestAvailabilityMap"]],"updateChestAvailabilityHintedPortraits",["get",["isShowingPerksModal"]],["get",["myTeamSummoners"]],["get",["benchChampions"]]]]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        const i = n(1),
          { EmberHelpers: o } = i,
          { Ember: a } = i,
          r = i.Lodash,
          l = a.Object.extend({
            allActions: a.computed("root.session.actions.[]", function () {
              const e = [],
                t = this.get("root.session.actions");
              return (
                t &&
                  t.forEach(function (t) {
                    t.forEach(function (t) {
                      e.push(t);
                    });
                  }, this),
                a.A(e)
              );
            }),
            finalizationPhaseActions: a.computed("allActions", function () {
              const e = this.get("allActions").filter((e) =>
                s.FINALIZATION_PHASE_CEREMONIES.includes(e.get("type")),
              );
              return a.A(e);
            }),
            pickActionSet: a.computed(
              "root.session.actions.[]",
              "allActions.@each.isPick",
              function () {
                const e = this.get("root.session.actions");
                return e
                  ? r.find(e, function (e) {
                      return r.every(e, function (e) {
                        return e.get("isPick");
                      });
                    })
                  : [];
              },
            ),
            voteActionSet: a.computed(
              "root.session.actions.[]",
              "allActions.@each.isVote",
              function () {
                const e = this.get("root.session.actions");
                if (e)
                  return r.find(e, function (e) {
                    return r.every(e, function (e) {
                      return e.get("isVote");
                    });
                  });
              },
            ),
            lastCompletedActionSetIndex: -1,
            currentActionSetIndex: -1,
            currentActions: a.computed(
              "allActions.@each.completed",
              "root.session.actions.[]",
              "currentPhaseHasActions",
              function () {
                const e = this.get("root.session.actions"),
                  t = this.get("currentPhaseHasActions");
                let n = -1;
                if (e && t)
                  for (let t = 0; t < e.length; t++) {
                    const s = e[t];
                    if (s && s.length && !r.every(s.mapBy("completed")))
                      return (
                        this.set("lastCompletedActionSetIndex", n),
                        this.set("currentActionSetIndex", t),
                        s
                      );
                    n = t;
                  }
                return this.set("currentActionSetIndex", -1), a.A();
              },
            ),
            currentActingCells: a.computed(
              "currentActions.@each.actorCellId",
              function () {
                const e = this.get("currentActions");
                return e
                  ? [
                      ...e.reduce(
                        (e, t) => (e.add(t.get("actorCellId")), e),
                        new Set(),
                      ),
                    ]
                  : [];
              },
            ),
            nextActions: a.computed(
              "root.session.actions.[]",
              "currentActions",
              "currentActionSetIndex",
              function () {
                if (!this.get("root.session.actions")) return a.A();
                const e = this.get("currentActions")
                  ? this.get("currentActionSetIndex")
                  : -1;
                return -1 === e
                  ? a.A()
                  : this.get("root.session.actions")[e + 1] || a.A();
              },
            ),
            nextAction: a.computed(
              "nextActions.[]",
              "nextActions.@each.actor",
              function () {
                const e = this.get("nextActions");
                return e
                  ? e.findBy("actor.isSelf", !0) || e.get("firstObject")
                  : null;
              },
            ),
            activeActions: a.computed(
              "currentActions.@each.completed",
              "currentPhaseHasActions",
              function () {
                return this.get("currentPhaseHasActions")
                  ? a.A(this.get("currentActions").filterBy("completed", !1))
                  : a.A();
              },
            ),
            activeAction: a.computed(
              "activeActions.[]",
              "activeActions.@each.actor",
              function () {
                const e = this.get("activeActions");
                return e
                  ? e.findBy("actor.isSelf", !0) || e.get("firstObject")
                  : null;
              },
            ),
            enemyActiveAction: a.computed("activeActions.[]", function () {
              return this.get("activeActions").findBy(
                "actor.isOnPlayersTeam",
                !1,
              );
            }),
            alliedActiveAction: a.computed("activeActions.[]", function () {
              return this.get("activeActions").findBy(
                "actor.isOnPlayersTeam",
                !0,
              );
            }),
            completedActions: a.computed(
              "allActions.@each.completed",
              function () {
                return a.A(this.get("allActions").filterBy("completed", !0));
              },
            ),
            lastCompletedAction: a.computed("completedActions", function () {
              return this.get("completedActions.lastObject");
            }),
            banActions: a.computed(
              "allActions.@each.id",
              "allActions.@each.type",
              function () {
                return a.A(this.get("allActions").filterBy("type", "ban"));
              },
            ),
            completedBanActions: a.computed(
              "banActions.@each.completed",
              function () {
                return a.A(this.get("banActions").filterBy("completed", !0));
              },
            ),
            lastCompletedBanAction: a.computed(
              "completedBanActions.@each.id",
              function () {
                return this.get("completedBanActions.lastObject");
              },
            ),
            pickActions: a.computed(
              "allActions.@each.id",
              "allActions.@each.type",
              function () {
                return a.A(this.get("allActions").filterBy("type", "pick"));
              },
            ),
            completedPickActions: a.computed(
              "pickActions.@each.completed",
              function () {
                return a.A(this.get("pickActions").filterBy("completed", !0));
              },
            ),
            pickActionsHaveBegun: a.computed(
              "activeAction.type",
              "completedPickActions",
              function () {
                return (
                  "pick" === this.get("activeAction.type") ||
                  this.get("completedPickActions").length
                );
              },
            ),
            voteActions: a.computed(
              "allActions.@each.id",
              "allActions.@each.type",
              function () {
                return a.A(this.get("allActions").filterBy("type", "vote"));
              },
            ),
            voteRevealActions: a.computed("allActions.@each.id", function () {
              return a.A(this.get("allActions").filterBy("isVoteReveal", !0));
            }),
            completedVoteRevealActions: a.computed(
              "voteRevealActions.@each.completed",
              function () {
                return a.A(
                  this.get("voteRevealActions").filterBy("completed", !0),
                );
              },
            ),
            myTeamVoteActions: a.computed(
              "allActions.@each.id",
              "voteActions.@each.actor",
              function () {
                return a.A(
                  this.get("voteActions").filterBy("actor.isOnLeftSide", !0),
                );
              },
            ),
            enemyTeamVoteActions: a.computed(
              "allActions.@each.id",
              "voteActions.@each.actor",
              function () {
                return a.A(
                  this.get("voteActions").filterBy("actor.isOnLeftSide", !1),
                );
              },
            ),
            currentPhaseHasActions: a.computed(
              "root.session.timer.inBanPickPhase",
              "root.session.timer.inFinalizationPhase",
              "finalizationPhaseActions.length",
              function () {
                const e = this.get("root.session.timer.inBanPickPhase"),
                  t = this.get("root.session.timer.inFinalizationPhase"),
                  n = this.get("finalizationPhaseActions.length") > 0;
                return e || (t && n);
              },
            ),
            leftSideFirstPick: a.computed(
              "pickActions.@each.isOnLeftSide",
              function () {
                const e = this.get("pickActions");
                return !(!e || !e[0]) && e[0].get("isOnLeftSide");
              },
            ),
            myTeamBanActions: a.computed(
              "banActions.@each.id",
              "banActions.@each.actor",
              "root.queue.gameMode",
              "root.session.localPlayerCellId",
              function () {
                const e = this.get("banActions"),
                  t =
                    s.GAME_MODES_WITH_SUBTEAMS[this.get("root.queue.gameMode")];
                if (t) {
                  const n = this.get("root.session.localPlayerCellId"),
                    s = t.subteams.find((e) => e.cellIds.includes(n));
                  return a.A(
                    e.filter((e) => !!s && s.cellIds.includes(e.actorCellId)),
                  );
                }
                return a.A(e.filterBy("actor.isOnLeftSide", !0));
              },
            ),
            myTeamUncompletedBanActions: a.computed(
              "myTeamBanActions.@each.id",
              "myTeamBanActions.@each.completed",
              function () {
                return a.A(
                  this.get("myTeamBanActions").filterBy("completed", !1),
                );
              },
            ),
            theirTeamBanActions: a.computed(
              "banActions.@each.id",
              "banActions.@each.actor",
              "root.queue.gameMode",
              "root.session.localPlayerCellId",
              function () {
                const e = this.get("banActions"),
                  t =
                    s.GAME_MODES_WITH_SUBTEAMS[this.get("root.queue.gameMode")];
                if (t) {
                  const n = this.get("root.session.localPlayerCellId"),
                    s = t.subteams.find((e) => e.cellIds.includes(n));
                  return a.A(
                    e.filter((e) => !s || !s.cellIds.includes(e.actorCellId)),
                  );
                }
                return a.A(e.filterBy("actor.isOnLeftSide", !1));
              },
            ),
            hasBans: a.computed("allActions.@each.type", function () {
              return !!this.get("allActions").find(function (e) {
                return "ban" === e.get("type");
              });
            }),
            hasPicks: a.computed("allActions.@each.type", function () {
              return !!this.get("allActions").find(function (e) {
                return "pick" === e.get("type");
              });
            }),
            hasVotes: a.computed("allActions.@each.type", function () {
              return !!this.get("allActions").find(function (e) {
                return "vote" === e.get("type");
              });
            }),
            hasPicksOrVotes: a.computed.or("hasPicks", "hasVotes"),
            someoneIsBanning: o.computedGate(
              "activeActions.@each.type",
              function () {
                return (
                  this.get("activeActions") &&
                  !!this.get("activeActions").find(function (e) {
                    return "ban" === e.get("type");
                  })
                );
              },
            ),
            isSimultaneousBans: o.computedGate(
              "currentActions.@each.isBan",
              function () {
                const e = this.get("currentActions");
                return (
                  !(!e || !e.length || e.length <= 1) &&
                  e.filterBy("isBan", !0).length > 1
                );
              },
            ),
            areSimultaneousBans: a.computed(
              "root.sessionActions.allActions.[]",
              function () {
                const e = this.get("root.session.actions");
                let t;
                if (e)
                  for (let n = 0; n < e.length; n++)
                    if (
                      ((t = e[n]),
                      t &&
                        t.length > 1 &&
                        t.filter((e) => e.get("isBan")).length > 1)
                    )
                      return !0;
                return !1;
              },
            ),
            currentBanAction: a.computed(
              "currentActions.@each.type",
              "someoneIsBanning",
              function () {
                return this.get("someoneIsBanning")
                  ? this.get("currentActions").findBy("type", "ban")
                  : null;
              },
            ),
            numBanActionsCompleted: a.computed.readOnly(
              "completedBanActions.length",
            ),
            numPickActionsCompleted: a.computed.readOnly(
              "completedPickActions.length",
            ),
            allPlayersPickTogether: a.computed(
              "pickActionSet.length",
              "root.session.myTeam.length",
              "root.session.theirTeam.length",
              "root.queue.gameTypeConfig.pickMode",
              function () {
                const e = this.get("root.session.myTeam.length"),
                  t = this.get("root.session.theirTeam.length"),
                  n = this.get("pickActionSet.length"),
                  s = this.get("root.queue.gameTypeConfig.pickMode");
                return 1 === e && 0 === t
                  ? "SimulPickStrategy" === s
                  : e + t === n;
              },
            ),
            allPlayersVoteTogether: a.computed(
              "voteActionSet.length",
              "root.session.myTeam.length",
              "root.session.theirTeam.length",
              function () {
                return (
                  this.get("root.session.myTeam.length") +
                    this.get("root.session.theirTeam.length") ===
                  this.get("voteActionSet.length")
                );
              },
            ),
            allPlayersActTogether: a.computed(
              "currentActions.length",
              "root.session.myTeam.length",
              "root.session.theirTeam.length",
              function () {
                return (
                  this.get("currentActions.length") ===
                  this.get("root.session.myTeam.length") +
                    this.get("root.session.theirTeam.length")
                );
              },
            ),
            phaseTransitionStringsByActionId: a.computed(
              "allActions.[]",
              function () {
                const e = this.get("allActions");
                let t,
                  n = "",
                  s = "";
                const i = { pick: 0, ban: 0, vote: 0, team_vote_reveal: 0 },
                  o = { pick: 0, ban: 0 },
                  a = {};
                for (let o = 0; o < e.length; o++)
                  (t = e[o]),
                    (s = t.get("type")),
                    s !== n && ((n = s), (i[s] = i[s] + 1));
                let r,
                  l = "";
                for (let n = 0; n < e.length; n++)
                  if (((t = e[n]), t.get("isPhaseTransition"))) {
                    if (
                      ((l = ""),
                      (r = null),
                      n + 1 < e.length && (r = e[n + 1]),
                      !r || !r.get("type"))
                    ) {
                      a[t.get("id")] = "finalization";
                      break;
                    }
                    (l = r.get("type")),
                      1 === i[l]
                        ? (a[t.get("id")] = "one_" + l + "_phase")
                        : ((o[l] = o[l] + 1),
                          (a[t.get("id")] = l + "_" + o[l]));
                  }
                return a;
              },
            ),
          });
        e.exports = l;
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        const { Router: i } = s.Ember,
          o = i.extend({ location: "none" });
        o.map(function () {}), (e.exports = o);
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s };
        n(186);
        const o = n(1),
          { Ember: a } = o,
          r = "sfx-ui";
        e.exports = a.Component.extend({
          classNames: ["action-button-container"],
          layout: n(187),
          audioPool: i.default,
          mouseEnter: function () {
            this.get("disabled") ||
              this.audioPool.playSound(
                r,
                "/fe/lol-champ-select/sounds/sfx-cs-lockin-button-hover.ogg",
              );
          },
          click: function () {
            this.get("disabled") ||
              this.audioPool.playSound(
                r,
                "/fe/lol-champ-select/sounds/sfx-cs-lockin-button-click.ogg",
              );
          },
          actions: {
            click: function () {
              this.sendAction("click");
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "WJXy4uVj",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\action-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\action-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\action-button-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","action-button"],["dynamic-attr","disabled",["helper",["if"],[["get",["disabled"]],"true"],null],null],["modifier",["action"],[["get",[null]],"click"]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","action-button-background"],["flush-element"],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","action-button-inner"],["flush-element"],["yield","default"],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":["default"],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s };
        n(189);
        const o = n(1),
          { Ember: a, EmberAddons: r } = o,
          { DomMixin: l } = r.EmberLifeline;
        e.exports = a.Component.extend(l, {
          classNames: ["ban-showcase"],
          classNameBindings: [
            "visible::removed",
            "waitingForBans::enemy-team-visible",
            "hideWaitingForTheirBansLabel::waiting-for-their-team-bans",
            "enemyTeamBansWrappable:enemy-team-bans-wrappable",
          ],
          layout: n(190),
          waitingForBans: a.computed.or(
            "waitingForMyTeamBans",
            "waitingForTheirTeamBans",
          ),
          waitingForMyTeamBans: a.computed.and(
            "isSimultaneousBans",
            "myTeamIsBanning",
          ),
          waitingForTheirTeamBans: a.computed.and(
            "isSimultaneousBans",
            "theirTeamIsBanning",
          ),
          myTeamIsBanning: a.computed(
            "myTeamBans.@each.completed",
            function () {
              return (
                this.get("myTeamBans").filterBy("completed", !1).length > 0
              );
            },
          ),
          theirTeamIsBanning: a.computed(
            "theirTeamBans.@each.completed",
            function () {
              return (
                this.get("theirTeamBans").filterBy("completed", !1).length > 0
              );
            },
          ),
          hideWaitingForTheirBansLabel: a.computed(
            "waitingForMyTeamBans",
            "waitingForTheirTeamBans",
            function () {
              return (
                this.get("waitingForMyTeamBans") ||
                !this.get("waitingForTheirTeamBans")
              );
            },
          ),
          localSummonerActionComplete: a.computed(
            "myTeamBans.@each.completed",
            function () {
              const e = this.get("myTeamBans"),
                t = e && e.findBy("actor.isSelf");
              return !t || t.get("completed");
            },
          ),
          enemyTeamBansWrappable: a.computed("theirTeamBans", function () {
            return this.get("theirTeamBans.length") > 6;
          }),
          playAllBansLockedAudio: function (e) {
            "banShowcaseAnnouncementLabelZoomIntro" === e.animationName &&
              i.default.playSound(
                "sfx-notifications",
                "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-team-bans-locked.ogg",
              );
          },
          didInsertElement: function () {
            this._super(...arguments),
              this.addEventListener(
                this.element,
                "animationstart",
                this.playAllBansLockedAudio,
              );
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "8REtqXqV",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ban-showcase-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ban-showcase-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ban-showcase-component\\\\index.js\\" "],["text","\\n"],["append",["helper",["champion-showcase-team"],null,[["showcaseActions","enemyBansHidden","myTeamBanning","introAnimation"],[["get",["myTeamBans"]],["get",["waitingForBans"]],["get",["waitingForMyTeamBans"]],["get",["localSummonerActionComplete"]]]]],false],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","waiting-for-their-bans-label"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","waiting-for-their-bans-text"],["flush-element"],["text","\\n    "],["append",["unknown",["tra","ban_component_waiting_for_their_bans"]],false],["text","\\n    "],["open-element","div",[]],["static-attr","class","waiting-for-their-bans-glow"],["flush-element"],["text","\\n      "],["append",["unknown",["tra","ban_component_waiting_for_their_bans"]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["enemy-bans-wrapper ",["helper",["if"],[["get",["waitingForBans"]],"removed","visible"],null]]]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ban-announcement-label"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","ban-announcement-bg-glow"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","ban-announcement-text"],["flush-element"],["text","\\n      "],["append",["unknown",["tra","ban_component_ban_announcement"]],false],["text","\\n      "],["open-element","div",[]],["static-attr","class","ban-announcement-label-glow"],["flush-element"],["text","\\n        "],["append",["unknown",["tra","ban_component_ban_announcement"]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["append",["helper",["champion-showcase-team"],null,[["showcaseActions","theirTeam"],[["get",["theirTeamBans"]],true]]],false],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(192),
          (e.exports = s.Ember.Component.extend({
            classNames: ["bans-container-component"],
            classNameBindings: ["gameModeClass"],
            layout: n(193),
            showBanHeader: s.Ember.computed("gameMode", function () {
              return "CHERRY" === this.get("gameMode");
            }),
            gameModeClass: s.Ember.computed("gameMode", function () {
              return "CHERRY" === this.get("gameMode")
                ? "left-anchored-combined-bans"
                : null;
            }),
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "Qy81Yv+Q",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\bans-container-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\bans-container-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\bans-container-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["showBanHeader"]]],null,0],["append",["helper",["team-bans"],null,[["hasSimultaneousBans","banActions","numBans","isMyTeam","gameMode"],[["get",["hasSimultaneousBans"]],["get",["myTeamBanActions"]],["get",["numBans"]],true,["get",["gameMode"]]]]],false],["text","\\n"],["append",["helper",["team-bans"],null,[["hasSimultaneousBans","banActions","numBans","isMyTeam","gameMode"],[["get",["session","hasSimultaneousBans"]],["get",["theirTeamBanActions"]],["get",["numBans"]],false,["get",["gameMode"]]]]],false]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","bans-wrapper-header"],["flush-element"],["append",["unknown",["tra","bans_header"]],false],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n(195);
        const s = n(1),
          { Ember: i } = s;
        e.exports = i.Component.extend({
          classNames: ["ban-showcase-team"],
          classNameBindings: [
            "theirTeam:their-team:my-team",
            "enemyBansHidden::enemy-bans-visible",
            "introAnimation",
            "type",
            "myTeamBanning",
          ],
          layout: n(196),
          type: i.computed("showcaseActions.firstObject.type", function () {
            return this.get("showcaseActions.firstObject.type") || "";
          }),
          label: i.computed("type", "bansLabel", "voteLabel", function () {
            return "vote" === this.get("type")
              ? this.get("voteLabel")
              : this.get("bansLabel");
          }),
          voteLabel: i.computed.readOnly("tra.ban_component_your_team_votes"),
          bansLabel: i.computed(
            "theirTeam",
            "tra.ban_component_your_team_bans",
            "tra.ban_component_enemy_team_bans",
            function () {
              return this.get("theirTeam")
                ? this.get("tra.ban_component_enemy_team_bans")
                : this.get("tra.ban_component_your_team_bans");
            },
          ),
          bansListClass: i.computed("showcaseActions", function () {
            return this.get("showcaseActions").length > 6
              ? "bans-list-wrappable"
              : "bans-list";
          }),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "keK5Z2j6",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-showcase-team-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-showcase-team-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-showcase-team-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","bans-label"],["flush-element"],["append",["unknown",["label"]],false],["text","\\n  "],["open-element","div",[]],["static-attr","class","bans-label-glow"],["flush-element"],["text","\\n    "],["append",["unknown",["bansLabel"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",[["unknown",["bansListClass"]]]]],["flush-element"],["text","\\n"],["block",["each"],[["get",["showcaseActions"]]],null,0],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["helper",["champion-showcase-item"],null,[["type","showcaseAction","theirTeam"],[["get",["type"]],["get",["showcaseAction"]],["get",["theirTeam"]]]]],false],["text","\\n"]],"locals":["showcaseAction"]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s };
        n(195);
        const o = n(1),
          { Ember: a, EmberAddons: r } = o,
          { DomMixin: l } = r.EmberLifeline;
        e.exports = a.Component.extend(l, {
          classNames: ["ban-champion"],
          classNameBindings: [
            "showcaseAction.champion:selected",
            "showcaseAction.completed:locked-in",
            "showcaseAction.snipedPlayerPick:sniped-player-pick",
            "type",
          ],
          layout: n(198),
          showBanOverlays: a.computed("type", function () {
            return "ban" === this.get("type");
          }),
          didInsertElement: function () {
            this._super(...arguments),
              this.addEventListener(
                this.element,
                "animationstart",
                this.playBanLockInSound,
              );
          },
          playBanLockInSound: function (e) {
            this.get("theirTeam") &&
              "banChampionLockedInPositionShakeAndGlow" === e.animationName &&
              i.default.playSound(
                "sfx-notifications",
                "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-enemy-ban.ogg",
              );
          },
        });
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "nesoOHx1",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-showcase-item-component\\\\layout.hbs\\" style-path=\\"null\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-showcase-item-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["ban-champion-shake-container ",["unknown",["type"]]]]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ban-gradient-background"],["flush-element"],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ban-marching-border-background-container"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","ban-marching-border-background"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ban-champion-thumbnail"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showBanOverlays"]]],null,1],["text","    "],["open-element","img",[]],["dynamic-attr","class",["concat",["champion-background-image ",["helper",["unless"],[["get",["showcaseAction","champion"]],"hidden"],null]," ",["helper",["unless"],[["get",["showcaseAction","completed"]],"grayed-out"],null]]]],["dynamic-attr","src",["unknown",["showcaseAction","champion","squarePortraitPath"]],null],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["block",["if"],[["get",["showBanOverlays"]]],null,0],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","champion-name"],["flush-element"],["append",["unknown",["showcaseAction","champion","name"]],false],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["open-element","div",[]],["dynamic-attr","class",["concat",["circle-x-overlay ",["helper",["if"],[["get",["showcaseAction","champion"]],"visible","hidden"],null]," ",["helper",["unless"],[["get",["showcaseAction","completed"]],"red"],null]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","img",[]],["static-attr","class","thumbnail-circle-x-background"],["static-attr","src","/fe/lol-champ-select/images/ban-showcase/icon-ban.png"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var n = l(t);
          if (n && n.has(e)) return n.get(e);
          var s = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o in e)
            if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) {
              var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
              a && (a.get || a.set)
                ? Object.defineProperty(s, o, a)
                : (s[o] = e[o]);
            }
          (s.default = e), n && n.set(e, s);
          return s;
        })(n(1));
        n(200);
        var i = r(n(158)),
          o = n(152),
          a = r(n(150));
        function r(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function l(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (l = function (e) {
            return e ? n : t;
          })(e);
        }
        const { EmberHelpers: c } = s.default,
          { RunMixin: u } = s.EmberAddons.EmberLifeline;
        e.exports = s.Ember.Component.extend(u, {
          classNames: ["champion-bench"],
          classNameBindings: [
            "showChestAvailabilityHintedPortraits:show-chest-availability-hinted-portraits",
          ],
          layout: n(201),
          pendingRequest: !1,
          isPlayingSound: !1,
          benchChampionsSize: s.Ember.computed(function () {
            const e = [];
            for (let t = 0; t < o.CHAMPION_BENCH_SIZE; t++) e.push(t);
            return s.Ember.A(e);
          }),
          benchLabel: s.Ember.computed.alias("tra.champion_bench_label"),
          benchInfoTooltip: s.Ember.computed.alias(
            "tra.champion_bench_label_tooltip",
          ),
          playSoundOnAllySwap: c.observeMultiChange(
            "summoner.champion.id",
            "benchChampions.[]",
            function (e) {
              if (
                void 0 === e["summoner.champion.id"] &&
                void 0 !== e["benchChampions.[]"] &&
                e["benchChampions.[]"].length > 0 &&
                !this.get("benchSoundOnCooldown")
              ) {
                this.set("benchSoundOnCooldown", !0);
                a.default
                  .createSound(
                    "sfx-notifications",
                    "/fe/lol-champ-select/sounds/sfx-champ-select-bench-update.ogg",
                    { maxConcurrent: 1 },
                  )
                  .play(),
                  this.runTask(function () {
                    this.set("benchSoundOnCooldown", !1);
                  }, o.CHAMPION_BENCH_SOUND_COOLDOWN_MS);
              }
            },
          ),
          actions: {
            championClicked(e) {
              this.get("pendingRequest") ||
                this.get("benchSwapOnCooldown") ||
                (this.set("pendingRequest", !0),
                i.default
                  .ajax({
                    type: "POST",
                    url: "/lol-champ-select/v1/session/bench/swap/" + e,
                    errorMessage: "error_could_not_swap_bench_champion",
                  })
                  .then(() => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!0);
                  })
                  .catch((e) => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!1, e);
                  })
                  .finally(() => {
                    this.set("pendingRequest", !1),
                      this.set("benchSwapOnCooldown", !0),
                      this.runTask(function () {
                        this.set("benchSwapOnCooldown", !1);
                      }, o.CHAMPION_BENCH_SWAP_COOLDOWN_MS);
                  }));
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "atiwxYVY",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","bench-label"],["flush-element"],["text","\\n  "],["append",["unknown",["benchLabel"]],false],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["bottom","whole-window"]],1],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","bench-container"],["flush-element"],["text","\\n"],["block",["each"],[["get",["benchChampionsSize"]]],null,0],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["helper",["champion-bench-item"],null,[["benchChampions","index","championClicked","benchSwapOnCooldown","inventory","championChestAvailabilityMap","shouldShowChestAvailability"],[["get",["benchChampions"]],["get",["champIndex"]],"championClicked",["get",["benchSwapOnCooldown"]],["get",["inventory"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]]]]],false],["text","\\n"]],"locals":["champIndex"]},{"statements":[["text","    "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-small"],["static-attr","padding","small"],["flush-element"],["text","\\n      "],["open-element","p",[]],["flush-element"],["append",["unknown",["benchInfoTooltip"]],false],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = o(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var a in e)
              if (
                "default" !== a &&
                Object.prototype.hasOwnProperty.call(e, a)
              ) {
                var r = i ? Object.getOwnPropertyDescriptor(e, a) : null;
                r && (r.get || r.set)
                  ? Object.defineProperty(s, a, r)
                  : (s[a] = e[a]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = n(152);
        function o(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (o = function (e) {
            return e ? n : t;
          })(e);
        }
        n(203);
        const { EmberHelpers: a } = s.default,
          { RunMixin: r } = s.EmberAddons.EmberLifeline;
        e.exports = s.Ember.Component.extend(r, {
          classNames: ["champion-bench-item"],
          layout: n(204),
          classNameBindings: [
            "isEmpty:empty-bench-item",
            "benchSwapOnCooldown:on-cooldown",
            "onCooldownFromNonPrioritizedBenchPrefill:on-cooldown",
            "onCooldownFromNonPrioritizedBenchPrefill:from-non-prioritized-prefill",
            "canPlay::grayed-out",
          ],
          champSelectInventory: s.Ember.inject.service(),
          previousChampionId: -1,
          onCooldownFromAllySwap: !1,
          onCooldownFromNonPrioritizedBenchPrefill: !1,
          pickableChampionSet: s.Ember.computed.alias(
            "champSelectInventory.pickableChampionSet",
          ),
          init: function () {
            this._super(...arguments);
            const e = this.get("index"),
              t = this.get("benchChampions");
            e < t.length &&
              !t[e].isPriority &&
              (this.set("onCooldownFromNonPrioritizedBenchPrefill", !0),
              this.runTask(function () {
                this.set("onCooldownFromNonPrioritizedBenchPrefill", !1);
              }, i.CHAMPION_BENCH_NON_PRIORITISED_PREFILL_COOLDOWN_MS));
          },
          champion: a.computedGate(
            "inventory.length",
            "benchChampions.[]",
            function () {
              const e = this.get("index"),
                t = this.get("benchChampions");
              if (e < t.length)
                return this.get("inventory").findBy("id", t[e].championId);
            },
          ),
          allySwapCooldownObserver: a.observer("champion.id", function () {
            const e = this.get("previousChampionId"),
              t = this.get("champion.id");
            t &&
              t !== e &&
              (-1 !== e &&
                (this.set("onCooldownFromAllySwap", !0),
                this.runTask(function () {
                  this.set("onCooldownFromAllySwap", !1);
                }, i.CHAMPION_BENCH_ALLY_SWAP_COOLDOWN_MS)),
              this.set("previousChampionId", t));
          }),
          isEmpty: s.Ember.computed.not("champion.id"),
          canPlay: s.Ember.computed(
            "pickableChampionSet",
            "champion.id",
            function () {
              return (this.get("pickableChampionSet") || new Set()).has(
                this.get("champion.id"),
              );
            },
          ),
          championName: s.Ember.computed.alias("champion.name"),
          showTooltip: s.Ember.computed("isEmpty", "canPlay", function () {
            return !this.get("isEmpty") && this.get("canPlay");
          }),
          tooltipText: s.Ember.computed("championName", function () {
            return this.get("tra.service").formatString(
              "champion_bench_item_tooltip",
              { championName: this.get("championName") },
            );
          }),
          showChampionChestAvailable: s.Ember.computed(
            "shouldShowChestAvailability",
            "champion.id",
            "championChestAvailabilityMap",
            function () {
              const e = this.get("champion.id"),
                t = this.get("championChestAvailabilityMap");
              return (
                !!(this.get("shouldShowChestAvailability") && e && t) &&
                t.get(e + "")
              );
            },
          ),
          click() {
            this.get("isEmpty") ||
              !this.get("canPlay") ||
              this.get("onCooldownFromAllySwap") ||
              this.get("onCooldownFromNonPrioritizedBenchPrefill") ||
              this.sendAction("championClicked", this.get("champion.id"));
          },
          backgroundStyle: s.Ember.computed(
            "champion.squarePortraitPath",
            function () {
              return (
                "background-image: url('" +
                this.get("champion.squarePortraitPath") +
                "');"
              );
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "9uR0z43r",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\champion-bench-item\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\champion-bench-item\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-bench-component\\\\champion-bench-item\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,3],["open-element","div",[]],["static-attr","class","bench-champion-icon"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","bench-champion-background"],["dynamic-attr","style",["helper",["sanitize"],[["get",["backgroundStyle"]]],null],null],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["showTooltip"]]],null,2],["text","  "],["open-element","div",[]],["static-attr","class","cooldown-mask"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","cooldown"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","left-half-mask"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","left-half"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","right-half"],["flush-element"],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","          "],["open-element","div",[]],["static-attr","class","tooltip-champion-chest-available"],["flush-element"],["append",["unknown",["tra","tooltip_champion_chest_available"]],false],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["tooltipText"]],false],["close-element"],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,0],["text","      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["bottom","whole-window"]],1]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","bench-champion-icon-chest-available-glow"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(206),
          (e.exports = s.Ember.Component.extend({
            classNames: ["champion-chest-availability"],
            classNameBindings: [
              "chestAvailable:available:unavailable",
              "isShowingPerksModal:hidden",
            ],
            layout: n(207),
            mouseEnter: function () {
              this.sendAction("updateChestAvailabilityHintedPortraits", !0);
            },
            mouseLeave: function () {
              this.sendAction("updateChestAvailabilityHintedPortraits", !1);
            },
            chestAvailable: s.Ember.computed(
              "championId",
              "championChestAvailabilityMap",
              function () {
                const e = this.get("championId"),
                  t = this.get("championChestAvailabilityMap");
                return !(!e || !t) && t.get(e + "");
              },
            ),
            anyChampionsChestAvailable: s.Ember.computed(
              "myTeamSummoners.@each.championId",
              "benchChampions.[]",
              "championChestAvailabilityMap",
              function () {
                if (this.get("chestAvailable")) return !0;
                const e = this.get("championChestAvailabilityMap");
                for (let t = 0; t < this.get("myTeamSummoners.length"); t++)
                  if (e.get(this.get(`myTeamSummoners.${t}.championId`) + ""))
                    return !0;
                for (let t = 0; t < this.get("benchChampions.length"); t++)
                  if (e.get(this.get(`benchChampions.${t}.championId`) + ""))
                    return !0;
                return !1;
              },
            ),
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "ZhHO2Zxe",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-chest-availability-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-chest-availability-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-chest-availability-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","champion-chest-available-glow"],["flush-element"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","champion-chest-available-icon"],["flush-element"],["text","\\n  "],["open-element","svg",[]],["static-attr","width","16"],["static-attr","height","16"],["static-attr","viewBox","0 0 16 16"],["static-attr","fill","none"],["static-attr","xmlns","http://www.w3.org/2000/svg","http://www.w3.org/2000/xmlns/"],["flush-element"],["text","\\n    "],["open-element","path",[]],["static-attr","fill-rule","evenodd"],["static-attr","clip-rule","evenodd"],["static-attr","d","M15 16H1L0 15V1L1 0H15L16 1V15L15 16ZM10 5L8 3L6 5V7L8 9L10 7V5ZM14 2L12 4V8L8 12L4 8V4L2 2V14H14V2Z"],["static-attr","fill","#5B5A56"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["bottom","whole-window"]],2],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","        "],["open-element","p",[]],["flush-element"],["append",["unknown",["tra","tooltip_mastery_chest_no_champs_available_icon"]],false],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","        "],["open-element","p",[]],["flush-element"],["append",["unknown",["tra","tooltip_mastery_chest_available_icon"]],false],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-small"],["static-attr","padding","small"],["flush-element"],["text","\\n"],["block",["if"],[["get",["anyChampionsChestAvailable"]]],null,1,0],["text","    "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = d(n(150)),
          o = d(n(158)),
          a = n(152),
          r = n(209),
          l = n(210),
          c = n(212),
          u = d(n(164)),
          m = d(n(213));
        function d(e) {
          return e && e.__esModule ? e : { default: e };
        }
        const { RunMixin: p, DomMixin: h } = s.EmberAddons.EmberLifeline,
          g = "championFilterPreferenceKey";
        n(214),
          n(215),
          n(216),
          (e.exports = s.Ember.Component.extend(p, h, u.default, {
            classNames: ["champion-grid"],
            classNameBindings: [
              "visible:champion-grid-visible:champion-grid-hidden",
              "gridSoftSelected:champion-grid-selected",
              "hasChampionPicked:champion-grid-picked",
              "summoner.isBanningNow:champion-grid-banning",
              "sortByFavorites:sort-by-favorites",
              "isAnimating:champion-grid-animating",
            ],
            layout: n(217),
            gridEstimatedClientWidth: 622,
            gridEstimatedClientHeight: 440,
            largeAreaAnimationsEnabled: s.Ember.computed.bool(
              "uxSettings.largeAreaAnimationsEnabled",
            ),
            isNotPickIntenting: s.Ember.computed.not(
              "summoner.isPickIntenting",
            ),
            isNotVisible: s.Ember.computed.not("visible"),
            isChampionGridDisabled: s.Ember.computed.or(
              "requestInProgress",
              "isNotVisible",
            ),
            disabledTooltipElementByChampionId: {},
            rateLimitData: [],
            favoritesEnabled: s.Ember.computed.bool(
              "jmxSettings.LcuChampionSelect.EnableFavorites",
            ),
            gridSortDisabled: s.Ember.computed.bool(
              "jmxSettings.LcuChampionSelect.DisableGridSort",
            ),
            chestFilterDisabled: s.Ember.computed.bool(
              "jmxSettings.LcuChampionSelect.DisableChestFilter",
            ),
            hasChampionPicked: s.Ember.computed.alias(
              "summoner.pickAction.completed",
            ),
            hasSelectedChampion_: s.Ember.computed.or(
              "summoner.activeAction.championId",
              "summoner.requestedChampionId",
            ),
            hasSelectedChampion: s.EmberHelpers.computedGate(
              "hasSelectedChampion_",
              function () {
                return this.get("hasSelectedChampion_");
              },
            ),
            gridSoftSelected: s.Ember.computed.and(
              "hasSelectedChampion",
              "isNotPickIntenting",
            ),
            champSelectInventory: s.Ember.inject.service(
              "champ-select-inventory",
            ),
            pickableChampionSet: s.Ember.computed.alias(
              "champSelectInventory.pickableChampionSet",
            ),
            bannableChampionSet: s.Ember.computed.alias(
              "champSelectInventory.bannableChampionSet",
            ),
            init: function () {
              this._super(...arguments),
                this.set("isAnimating", !1),
                this.set("gridChampionLayout", new m.default(101, 96)),
                this.set(
                  "randomChampionConfiguration",
                  this.createRandomViewChampion(),
                ),
                (this.csBinding = (0, s.DataBinding)(
                  "/lol-champ-select",
                  (0, s.getProvider)().getSocket(),
                )),
                this.csBinding.observe(
                  "/v1/all-grid-champions",
                  this,
                  this.handleGridChampionsUpdated,
                ),
                this.getPreferredSortingMethod();
            },
            didInsertElement: function () {
              this._super(...arguments), this.bindChampIconSounds();
            },
            willDestroyElement() {
              this._super(...arguments),
                this._clearDebounceGridUpdateTimer(),
                this._resetAnimation(!1);
            },
            bindChampIconSounds: function () {
              const e = (e, t) => {
                !t.target.classList.contains(
                  "champion-grid-champion-thumbnail",
                ) ||
                  t.target.classList.contains("waiting") ||
                  t.target.getAttribute("disabled") ||
                  i.default.playSound(
                    a.SFX_CHANNEL,
                    a.SOUNDS_PATH + "/sfx-uikit-grid-" + e + ".ogg",
                  );
              };
              this.addEventListener(
                this.element,
                "mouseover",
                e.bind(this, "hover"),
              ),
                this.addEventListener(
                  this.element,
                  "mousedown",
                  e.bind(this, "click"),
                ),
                this.addEventListener(
                  this.element,
                  "mouseup",
                  e.bind(this, "release"),
                );
            },
            handleGridChampionsUpdated: function (e) {
              const t = this.createChampionConfigurations(e);
              this.set("championConfigurations", s.Ember.A(t));
            },
            createChampionConfigurations: function (e) {
              this.championConfigurationsCache ||
                (this.championConfigurationsCache = {});
              const t = [];
              return (
                (e || []).forEach((e) => {
                  this.championConfigurationsCache[e.id]
                    ? this.championConfigurationsCache[e.id].set("champion", e)
                    : (this.championConfigurationsCache[e.id] =
                        this.createChampionConfiguration(e)),
                    t.push(this.championConfigurationsCache[e.id]);
                }),
                t
              );
            },
            createChampionConfiguration: function (e) {
              return (
                this.csBinding.observe(
                  `/v1/grid-champions/${e.id}`,
                  this,
                  this.handleGridChampionUpdated,
                ),
                l.ViewChampionClass.create({
                  champion: e,
                  grid: this,
                  tra: this.get("tra"),
                })
              );
            },
            handleGridChampionUpdated: function (e) {
              if (e) {
                const t = this.championConfigurationsCache[e.id];
                t &&
                  (t.set("champion", e),
                  e.id === this.get("summoner.requestedChampionId") &&
                    e.selectionStatus.pickIntentedByMe &&
                    this._finishSelectChampionTelemetryTimer());
              }
            },
            createRandomViewChampion: function () {
              return l.ViewChampionClass.create({
                grid: this,
                tra: this.get("tra"),
                champion: s.Ember.Object.create({
                  id: a.RANDOM_CHAMP.championId,
                  name: this.get("tra.random_icon_label"),
                  positionsFavorited: [],
                  searchMatchingTerms: [
                    this.get("tra.random_icon_search_matching_terms"),
                  ],
                  squarePortraitPath:
                    "/fe/lol-champ-select/images/champion-grid/random-champion.png",
                }),
              });
            },
            clearChampionIdBetweenBans: s.EmberHelpers.observeMultiChange(
              "summoner.isBanningNow",
              "summoner.banActions.@each.completed",
              function () {
                this.clearChampionId();
              },
            ),
            clearChampionId: function () {
              this.get("summoner") &&
                this.set("summoner.requestedChampionId", void 0);
            },
            clearFiltersAfterPickOrBan: s.EmberHelpers.observeMultiChange(
              "summoner.banActions.@each.completed",
              "summoner.pickAction.completed",
              function () {
                this.clearFilters();
              },
            ),
            clearFilters: function () {
              this.get("filters").forEach((e) => {
                e.set("value", !1);
              }),
                this.set("searchText", "");
            },
            getPreferredSortingMethod: function () {
              (0, c.getAccountSetting)(g).then((e) => {
                "name" === e
                  ? this.set("sortByName", !0)
                  : "mastery" === e
                    ? this.set("sortByMastery", !0)
                    : this.set("sortByFavorite", !0);
              });
            },
            positionFilters: s.Ember.computed(function () {
              const e = a.POSITIONS.map((e) =>
                r.PositionFilter.create({ name: e, tra: this.get("tra") }),
              );
              return s.Ember.A(e);
            }),
            chestFilter: s.Ember.computed(function () {
              return s.Ember.Object.create({
                name: "chest",
                value: !1,
                displayName:
                  this.get("tra.service").formatString("filter_by_chest"),
                favoriteName:
                  this.get("tra.service").formatString("favorite_by_chest"),
                unfavoriteName: this.get("tra.service").formatString(
                  "unfavorite_by_chest",
                ),
                canFavorite: !1,
                matches: function (e) {
                  return (
                    !!e &&
                    (e.id === a.RANDOM_CHAMP.championId ||
                      (!e.masteryChestGranted && e.owned))
                  );
                },
              });
            }),
            filters: s.Ember.computed(
              "positionFilters",
              "chestFilter",
              "chestFilterDisabled",
              "shouldShowChestFilter",
              function () {
                const e = [].concat(this.get("positionFilters") || []);
                return (
                  !this.get("chestFilterDisabled") &&
                    this.get("shouldShowChestFilter") &&
                    e.push(this.get("chestFilter")),
                  s.Ember.A(e)
                );
              },
            ),
            activePositionFilter: s.Ember.computed(
              "positionFilters.@each.value",
              function () {
                return (this.get("positionFilters") || []).find((e) =>
                  e.get("value"),
                );
              },
            ),
            selectedFilter: s.Ember.computed(
              "filters.@each.value",
              function () {
                const e = (this.get("filters") || s.Ember.A()).filterBy(
                  "value",
                  !0,
                );
                return !e || e.length < 1
                  ? () => !0
                  : (t) => {
                      for (let n = 0; n < e.length; n++) {
                        if (!e[n].matches(t)) return !1;
                      }
                      return !0;
                    };
              },
            ),
            canPlayFilter: s.EmberHelpers.computedGate(
              "summoner.isBanningNow",
              "pickableChampionSet",
              "bannableChampionSet",
              function () {
                let e = this.get("summoner.isBanningNow")
                  ? this.get("bannableChampionSet")
                  : this.get("pickableChampionSet");
                return (e = e || new Set([])), (t) => e.has(t.id);
              },
            ),
            championFilters: s.Ember.computed.collect(
              "selectedFilter",
              "canPlayFilter",
            ),
            searchText: "",
            debouncedSearchText: s.EmberHelpers.customDebounce(
              "searchText",
              5,
              1500,
            ),
            currentLocale: s.Ember.computed(
              "tra.metadata.locale.id",
              function () {
                const e = this.get("tra.metadata.locale.id"),
                  t = e ? e.substr(0, 2).toLowerCase() : "en";
                return "cz" === t ? "en" : t;
              },
            ),
            sortCollator: s.Ember.computed("currentLocale", function () {
              return new Intl.Collator(this.get("currentLocale"));
            }),
            filterAndSortChampionConfigurations:
              s.EmberHelpers.observeMultiChange(
                "selectedFilter",
                "canPlayFilter",
                "debouncedSearchText",
                "currentLocale",
                "pickableChampionSet",
                "championConfigurations",
                "championConfigurations.@each.favorite",
                "isRandomChampionEnabled",
                function (e) {
                  const t = (e && Object.keys(e)) || [],
                    n = this.get("championConfigurations");
                  if (!n || 0 === t.length) return;
                  const s = t.some(
                    (e) =>
                      "selectedFilter" === e || "debouncedSearchText" === e,
                  );
                  this._filterAndSortChampionConfigurations(n.toArray(), s);
                },
              ),
            _filterAndSortChampionConfigurations: function (e, t) {
              const n = this.get("sortByMastery"),
                s = this.get("sortByFavorite"),
                i = this.get("sortCollator"),
                o = new Map(),
                r = new Map(),
                l = e.filter((e) => {
                  const t = e.get("searchScore");
                  return (
                    !(t < 0) && (o.set(e, t), r.set(e, e.get("champion")), !0)
                  );
                });
              if (
                (l.sort((e, t) => {
                  const l = o.get(e),
                    c = o.get(t),
                    u = r.get(e),
                    m = r.get(t);
                  if (l === c) {
                    if (l < 0) return 0;
                    if (u.id === a.NONE_CHAMP_ID) return -1;
                    if (m.id === a.NONE_CHAMP_ID) return 1;
                    if (s && e.get("favorite") !== t.get("favorite"))
                      return e.get("favorite") ? -1 : 1;
                    if (n) {
                      const e = (m.masteryLevel || 0) - (u.masteryLevel || 0);
                      if (0 !== e) return e > 0 ? 1 : -1;
                      {
                        const e =
                          (m.masteryPoints || 0) - (u.masteryPoints || 0);
                        if (0 !== e) return e > 0 ? 1 : -1;
                      }
                    }
                    return i.compare(u.name, m.name);
                  }
                  return l > c ? -1 : 1;
                }),
                this.get("isRandomChampionEnabled") && l.length > 1)
              ) {
                const e = this.get("randomChampionConfiguration");
                l.unshift(e);
              }
              return this._onDebounceGridUpdate(l, t), l;
            },
            _onDebounceGridUpdate: function (e, t) {
              this._clearDebounceGridUpdateTimer(),
                (this._onDebounceGridUpdateTimer = this.runTask(() => {
                  this._applyGridUpdate(e, t);
                }, 50));
            },
            _clearDebounceGridUpdateTimer: function () {
              this._onDebounceGridUpdateTimer &&
                (this.cancelTask(this._onDebounceGridUpdateTimer),
                (this._onDebounceGridUpdateTimer = null));
            },
            _applyGridUpdate: function (e, t) {
              this.set("gridScrollTop", void 0),
                this._resetAnimation(t),
                this.set("championConfigurationsSorted", e);
            },
            _resetAnimation: function (e) {
              this._onAnimatingUpdateTimer &&
                (this.cancelTask(this._onAnimatingUpdateTimer),
                (this._onAnimatingUpdateTimer = null));
              const t = e && this.get("largeAreaAnimationsEnabled");
              this.set("isAnimating", t),
                t &&
                  (this._onAnimatingUpdateTimer = this.runTask(() => {
                    this.set("isAnimating", !1);
                  }, 500));
            },
            hasChampionConfigurationsSorted: s.Ember.computed.notEmpty(
              "championConfigurationsSorted",
            ),
            scrollToPickIntent: s.EmberHelpers.observeChange(
              "summoner.isPickingNow",
              function () {
                if (
                  this.get("summoner.isPickingNow") &&
                  !this.get("gridRequested")
                ) {
                  const e =
                      this.championConfigurationsCache[
                        this.get("summoner.pickAction.champion.id")
                      ],
                    t = this.get("championConfigurationsSorted"),
                    n = t ? t.indexOf(e) : -1;
                  if (n < 0) return;
                  const s = 96 * Math.floor(n / 6);
                  this.set("gridScrollTop", void 0),
                    this.set("gridScrollTop", s);
                }
              },
            ),
            _createDisabledTooltip: function () {
              const e = document.createElement("lol-uikit-tooltip");
              e.setAttribute("type", "system");
              const t = document.createElement("lol-uikit-content-block");
              t.setAttribute("padding", "small"),
                t.setAttribute("type", "tooltip-system");
              const n = document.createElement("p");
              return (
                t.appendChild(n), e.appendChild(t), { tooltip: e, textNode: n }
              );
            },
            disabledTooltipRenderDelegate: function (e, t) {
              const n = t.gridComponent;
              n._cachedTooltipAndTextNode ||
                (n._cachedTooltipAndTextNode = n._createDisabledTooltip());
              const { tooltip: s, textNode: i } = n._cachedTooltipAndTextNode;
              return (
                (i.innerText =
                  t.championConfiguration.get("disabledReason") || ""),
                s
              );
            },
            _selectableRandomChampions: function (e) {
              const t = this.get("hasSelectedChampion")
                ? this.get("summoner.activeAction.championId") ||
                  this.get("summoner.requestedChampionId")
                : null;
              return e.filter(
                (e) =>
                  e.get("searchScore") > -1 &&
                  !e.get("champion.selectionStatus.pickedByOtherOrBanned") &&
                  !e.get("champion.disabled") &&
                  e.get("champion.id") !== a.RANDOM_CHAMP.championId &&
                  (!t || e.get("champion.id") !== t),
              );
            },
            _updateRandomChampionsRateLimit: function (e, t, n) {
              if (t && e.length > 0 && e.length >= t.get("maxActions")) {
                if (!(n - e[0] > t.get("interval"))) return !1;
                e.shift(), e.push(n);
              } else e.push(n);
              return !0;
            },
            _finishSelectChampionTelemetryTimer: function () {
              this._isRecordingSelectChampionTime &&
                window.requestAnimationFrame(() => {
                  window.requestAnimationFrame(() => {
                    s.Telemetry.endTracingEvent(
                      "champ-select-select-champion-v2",
                    ),
                      (this._isRecordingSelectChampionTime = !1);
                  });
                });
            },
            _findRandomChampion: function () {
              const e = this.get("rateLimitData"),
                t = this.get("randomChampionRateLimitConfig");
              if (t && !this._updateRandomChampionsRateLimit(e, t, Date.now()))
                return null;
              const n = this.get("championConfigurations"),
                s = this._selectableRandomChampions(n);
              if (s.length >= 1) {
                return s[Math.floor(Math.random() * s.length)];
              }
            },
            actions: {
              handleInputValueChanged() {
                this.get("filters").forEach((e) => {
                  e.set("value", !1);
                });
              },
              sort: function (e) {
                this.setProperties({
                  sortByMastery: "mastery" === e,
                  sortByFavorite: "favorite" === e,
                  sortByName: "name" === e,
                }),
                  ("mastery" !== e && "favorite" !== e) ||
                    s.Telemetry.sendEvent("champ-select-grid-sort", e),
                  (0, c.saveAccountSetting)(g, e),
                  this._filterAndSortChampionConfigurations(
                    this.get("championConfigurations").toArray(),
                    !0,
                  );
              },
              toggleFavorite: function (e, t) {
                if (!this.get("favoritesEnabled")) return;
                s.Telemetry.recordNonTimingTracingEvent(
                  "champ-select-favorite",
                  1,
                  "click",
                );
                const n = s.Ember.get(e, "id");
                return this.csBinding.post(`/v1/toggle-favorite/${n}/${t}`);
              },
              select: function (e) {
                if (
                  e.get("champion.id") === a.RANDOM_CHAMP.championId &&
                  !(e = this._findRandomChampion())
                )
                  return;
                const t = e.get("champion.id"),
                  n = e.get("champion.disabled");
                if (
                  e.get("champion.selectionStatus.pickedByOtherOrBanned") ||
                  n
                )
                  return;
                const i = this.get("summoner.changingAction");
                if (!i || void 0 === i.get("id") || t === i.get("championId"))
                  return;
                (!this._lastSelectChampionTelemetrySample ||
                  Date.now() - 1e4 > this._lastSelectChampionTelemetrySample) &&
                  (s.Telemetry.startTracingEvent(
                    "champ-select-select-champion-v2",
                  ),
                  s.Telemetry.startTracingEvent("champ-select-pick-intent"),
                  (this._isRecordingSelectChampionTime = !0),
                  (this._isRecordingPickIntentTime = !0),
                  (this._lastSelectChampionTelemetrySample = Date.now()));
                const r = o.default
                  .ajax({
                    url: "/lol-champ-select/v1/session/actions/" + i.get("id"),
                    contentType: "application/json",
                    data: JSON.stringify({ championId: t }),
                    errorMessage: "error_could_not_select_champion",
                    method: "PATCH",
                  })
                  .then(() => {
                    this._isRecordingPickIntentTime &&
                      window.requestAnimationFrame(() => {
                        s.Telemetry.endTracingEvent("champ-select-pick-intent"),
                          (this._isRecordingPickIntentTime = !1);
                      }),
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!0);
                  })
                  .catch((e) => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!1, e),
                      this.get("pendingRequest") === r &&
                        (this.set(
                          "summoner.requestedChampionId",
                          i.get("championId"),
                        ),
                        s.Telemetry.sendEvent(
                          "champ-select-could-not-select-champion",
                        ),
                        this._isRecordingSelectChampionTime &&
                          (s.Telemetry.endTracingEvent(
                            "champ-select-select-champion-v2",
                          ),
                          (this._isRecordingSelectChampionTime = !1)),
                        this._isRecordingPickIntentTime &&
                          (s.Telemetry.endTracingEvent(
                            "champ-select-pick-intent",
                          ),
                          (this._isRecordingPickIntentTime = !1)));
                  });
                this.set("pendingRequest", r),
                  this.set("summoner.requestedChampionId", t);
              },
              handleFilterMouseOver: function () {
                i.default.playSound(
                  a.SFX_CHANNEL,
                  a.SOUNDS_PATH + "/sfx-uikit-grid-hover.ogg",
                );
              },
              toggleFilter: function (e) {
                i.default.playSound(
                  a.SFX_CHANNEL,
                  a.SOUNDS_PATH + "/sfx-uikit-generic-click-small.ogg",
                ),
                  this.get("filters").forEach((t) => {
                    t === e
                      ? t.set("value", !t.get("value"))
                      : t.set("value", !1);
                  });
              },
              showDisabledTooltip: function (e) {
                const t = e.get("champion.id");
                if (!e || !t) return;
                const n = event.target,
                  i = this.get("disabledTooltipElementByChampionId");
                if (!e.get("disabledAttr"))
                  return void (
                    i &&
                    i.hasOwnProperty(t) &&
                    (s.TooltipManager.disable(i[t]), delete i[t])
                  );
                const o = { gridComponent: this, championConfiguration: e };
                s.TooltipManager.assign(
                  n,
                  this.disabledTooltipRenderDelegate,
                  o,
                  {
                    type: "system",
                    restrictArea: "whole-window",
                    targetAnchor: { x: "center", y: "top" },
                  },
                ),
                  (i[t] = n);
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.PositionFilter = void 0);
        var s = n(152);
        const i = n(1),
          { Ember: o } = i,
          a = i.ChampionStatistics.getPlayRates() || {},
          r = o.Object.extend({
            name: null,
            value: !1,
            canFavorite: !0,
            displayName: o.computed.apply(
              o,
              ["name"]
                .concat(
                  s.POSITIONS.map(function (e) {
                    return "tra.filter_by_position_" + e;
                  }),
                )
                .concat([
                  function () {
                    const e = this.get("tra.service"),
                      t = "filter_by_position_" + this.get("name");
                    return e.formatString(t);
                  },
                ]),
            ),
            favoriteName: o.computed.apply(
              o,
              ["name"]
                .concat(
                  s.POSITIONS.map(function (e) {
                    return "tra.favorite_by_position_" + e;
                  }),
                )
                .concat([
                  function () {
                    const e = this.get("tra.service"),
                      t = "favorite_by_position_" + this.get("name");
                    return e.formatString(t);
                  },
                ]),
            ),
            unfavoriteName: o.computed.apply(
              o,
              ["name"]
                .concat(
                  s.POSITIONS.map(function (e) {
                    return "tra.unfavorite_by_position_" + e;
                  }),
                )
                .concat([
                  function () {
                    const e = this.get("tra.service"),
                      t = "unfavorite_by_position_" + this.get("name");
                    return e.formatString(t);
                  },
                ]),
            ),
            matches: function (e) {
              if (!e) return !1;
              if (e.id === s.RANDOM_CHAMP.championId) return !0;
              const t = this.get("name"),
                n = a[t.toUpperCase()] || {};
              return e.id + "" in n || (e.positionsFavorited || []).includes(t);
            },
          });
        t.PositionFilter = r;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.ViewChampionClass = void 0);
        var s = n(1),
          i = n(152);
        const o = n(211),
          a = s.Ember.Object.extend({
            id: s.Ember.computed.alias("champion.id"),
            favoritesEnabled: s.Ember.computed.alias("grid.favoritesEnabled"),
            favorite: s.EmberHelpers.computedGate(
              "favoritesEnabled",
              "champion.positionsFavorited.length",
              "grid.activePositionFilter.name",
              function () {
                if (!this.get("favoritesEnabled")) return !1;
                const e = this.get("grid.activePositionFilter.name"),
                  t = this.get("champion.positionsFavorited");
                return e ? t.includes(e) : t.length > 0;
              },
            ),
            searchScore: s.Ember.computed(
              "champion",
              "_searchScore",
              "grid.championFilters",
              "grid.debouncedSearchText",
              function () {
                const e = this.get("champion"),
                  t = this.get("grid.championFilters");
                if (e.id === i.RANDOM_CHAMP.championId) return 90;
                return t.find((t) => {
                  if ("function" == typeof t) return !t(e);
                })
                  ? -1
                  : this.get("grid.debouncedSearchText").trim().length < 1
                    ? 0
                    : this.get("_searchScore");
              },
            ),
            _searchScore: s.Ember.computed(
              "grid.debouncedSearchText",
              "searchMatchingTerms",
              function () {
                let e = -1;
                const t = this.get("grid.debouncedSearchText").trim(),
                  n = this.get("searchMatchingTerms");
                if (!n || n.length < 1) return 0;
                const s = o.filter(t, n);
                return (
                  s.length > 0 &&
                    s[0].score &&
                    ((e += s[0].score), n.indexOf(t) >= 0 && (e += 100)),
                  e
                );
              },
            ),
            searchMatchingTerms: s.Ember.computed(
              "champion.id",
              "tra",
              function () {
                const e = this.get("tra"),
                  t = `champion_local_search_colloq_${this.get("id")}`;
                let n = [this.get("champion.name").toLocaleLowerCase()];
                return (
                  e.exists(t) &&
                    (n = s.Lodash.uniq(
                      n.concat(
                        (e.get(t) || "")
                          .split(";")
                          .filter((e) => e.length > 0)
                          .map((e) => e.toLocaleLowerCase()),
                      ),
                    )),
                  s.Lodash.uniq(n)
                );
              },
            ),
            disabledAttr: s.Ember.computed(
              "champion.selectionStatus.pickedByOtherOrBanned",
              "champion.disabled",
              function () {
                if (
                  this.get("champion.selectionStatus.pickedByOtherOrBanned") ||
                  this.get("champion.disabled")
                )
                  return !0;
              },
            ),
            hideDisabledTooltip: s.Ember.computed.not("disabledAttr"),
            disabledReason: s.Ember.computed(
              "champion.disabled",
              "champion.isBanned",
              "champion.pickedByOtherOrBanned",
              "tra.champion_unselectable_because_picked",
              "tra.champion_unselectable_because_disabled",
              "tra.champion_unselectable_because_banned",
              function () {
                return this.get("champion.disabled")
                  ? this.get("tra.champion_unselectable_because_disabled")
                  : this.get("champion.selectionStatus.isBanned")
                    ? this.get("tra.champion_unselectable_because_banned")
                    : this.get("champion.selectionStatus.pickedByOtherOrBanned")
                      ? this.get("tra.champion_unselectable_because_picked")
                      : void 0;
              },
            ),
          });
        t.ViewChampionClass = a;
      },
      (e) => {
        var t;
        (t = {}),
          (e.exports = t),
          (t.simpleFilter = function (e, n) {
            return n.filter(function (n) {
              return t.test(e, n);
            });
          }),
          (t.test = function (e, n) {
            return null !== t.match(e, n);
          }),
          (t.match = function (e, t, n) {
            n = n || {};
            var s,
              i = 0,
              o = [],
              a = t.length,
              r = 0,
              l = 0,
              c = n.pre || "",
              u = n.post || "",
              m = (n.caseSensitive && t) || t.toLowerCase();
            e = (n.caseSensitive && e) || e.toLowerCase();
            for (var d = 0; d < a; d++)
              (s = t[d]),
                m[d] === e[i]
                  ? ((s = c + s + u), (i += 1), (l += 1 + l))
                  : (l = 0),
                (r += l),
                (o[o.length] = s);
            return i === e.length
              ? ((r = m === e ? 1 / 0 : r), { rendered: o.join(""), score: r })
              : null;
          }),
          (t.filter = function (e, n, s) {
            return n && 0 !== n.length
              ? "string" != typeof e
                ? n
                : ((s = s || {}),
                  n
                    .reduce(function (n, i, o, a) {
                      var r = i;
                      s.extract && (r = s.extract(i));
                      var l = t.match(e, r, s);
                      return (
                        null != l &&
                          (n[n.length] = {
                            string: l.rendered,
                            score: l.score,
                            index: o,
                            original: i,
                          }),
                        n
                      );
                    }, [])
                    .sort(function (e, t) {
                      var n = t.score - e.score;
                      return n || e.index - t.index;
                    }))
              : [];
          });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.saveAccountSetting = t.getAccountSetting = void 0);
        var s = n(1);
        const i = "/v2/account/LCUPreferences/lol-champ-select";
        let o = 0;
        t.getAccountSetting = function (e) {
          return (0, s.DataBinding)("/lol-settings")
            .get(i)
            .then((t) => {
              const n = t && t.data && t.data[e];
              return (o = t && t.schemaVersion), n;
            });
        };
        t.saveAccountSetting = function (e, t) {
          if (void 0 === o || o < 0)
            return Promise.reject(
              "Schema version invalid, settings not updated.",
            );
          const n = { [e]: t };
          return (0, s.DataBinding)("/lol-settings").patch(i, {
            data: n,
            schemaVersion: o,
          });
        };
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        const s =
          n(1).SharedEmberComponents.EmberCollectionApi.Layouts.GridLayout;
        t.default = class extends s {
          constructor(e, t) {
            super(e, t),
              (this._csCellWidth = e),
              (this._csCellHeight = t),
              (this._animationEnabled = !1);
          }
          widthAt(e) {
            return this._csCellWidth;
          }
          heightAt(e) {
            return this._csCellHeight;
          }
        };
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "up/GDiEF",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-grid-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-grid-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-grid-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","champion-grid-header"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","filter-icons"],["flush-element"],["text","\\n"],["block",["each"],[["get",["filters"]]],null,5],["text","  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","spacer"],["flush-element"],["close-element"],["text","\\n"],["block",["unless"],[["get",["gridSortDisabled"]]],null,3],["text","  "],["open-element","lol-uikit-flat-input",[]],["flush-element"],["text","\\n    "],["append",["helper",["input"],null,[["class","type","maxlength","value","key-press","name","placeholder"],["champion-input","search",25,["get",["searchText"]],"handleInputValueChanged","searchText",["get",["tra","search"]]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["champions ",["helper",["if"],[["get",["isChampionGridDisabled"]],"champions-disabled"],null]]]],["flush-element"],["text","\\n"],["block",["if"],[["get",["hasChampionConfigurationsSorted"]]],null,1],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["append",["helper",["champion-grid-champion"],null,[["championConfiguration","isRGM","UseNewLoyaltyIcon","showDisabledTooltip","select","toggleFavorite"],[["get",["championConfiguration"]],["get",["isRGM"]],["get",["UseNewLoyaltyIcon"]],"showDisabledTooltip","select","toggleFavorite"]]],false],["text","\\n"]],"locals":["championConfiguration","index"]},{"statements":[["block",["ember-collection"],null,[["class","estimated-width","estimated-height","scroll-top","items","cell-layout"],["champion-container",["get",["gridEstimatedClientWidth"]],["get",["gridEstimatedClientHeight"]],["get",["gridScrollTop"]],["get",["championConfigurationsSorted"]],["get",["gridChampionLayout"]]]],0]],"locals":[]},{"statements":[["text","    "],["open-element","lol-uikit-dropdown-option",[]],["static-attr","slot","lol-uikit-dropdown-option"],["dynamic-attr","selected",["unknown",["sortByFavorite"]],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"sort","favorite"],null],null],["flush-element"],["text","\\n      "],["append",["unknown",["tra","sort_by_favorite"]],false],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","lol-uikit-framed-dropdown",[]],["static-attr","class","champ-select-sort-dropdown"],["flush-element"],["text","\\n"],["block",["if"],[["get",["favoritesEnabled"]]],null,2],["text","    "],["open-element","lol-uikit-dropdown-option",[]],["static-attr","slot","lol-uikit-dropdown-option"],["static-attr","class","sort-by-name"],["dynamic-attr","selected",["unknown",["sortByName"]],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"sort","name"],null],null],["flush-element"],["text","\\n      "],["append",["unknown",["tra","sort_by_name"]],false],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","lol-uikit-dropdown-option",[]],["static-attr","slot","lol-uikit-dropdown-option"],["dynamic-attr","selected",["unknown",["sortByMastery"]],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"sort","mastery"],null],null],["flush-element"],["text","\\n      "],["append",["unknown",["tra","sort_by_mastery"]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","          "],["open-element","lol-uikit-content-block",[]],["static-attr","padding","small"],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n            "],["open-element","p",[]],["static-attr","class","filter-label"],["flush-element"],["append",["unknown",["filter","displayName"]],false],["close-element"],["text","\\n          "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","div",[]],["dynamic-attr","class",["concat",["filter ",["unknown",["filter","name"]]," ",["helper",["if"],[["get",["filter","value"]],"active"],null]]]],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"toggleFilter",["get",["filter"]]],null],null],["dynamic-attr","onmouseover",["helper",["action"],[["get",[null]],"handleFilterMouseOver"],null],null],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea","type","offsetY"],["top","whole-window","system",-5]],4],["text","      "],["close-element"],["text","\\n"]],"locals":["filter"]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = n(152);
        const o = s.UiKitPlugin.getContextMenuManager();
        e.exports = s.Ember.Component.extend({
          classNames: ["grid-champion"],
          classNameBindings: [
            "championConfiguration.champion.selectionStatus.selectedByMe:grid-champion-selected",
            "championConfiguration.champion.selectionStatus.banIntentedByMe:grid-champion-ban-selected",
            "championConfiguration.champion.selectionStatus.banIntented",
            "championConfiguration.champion.selectionStatus.pickIntented",
            "championConfiguration.champion.selectionStatus.pickIntentedPosition",
            "championConfiguration.champion.selectionStatus.pickIntentedByMe:self-pick-intented",
            "favoriteIcon:grid-champion-favorite",
            "loyaltyIconClass",
            "championConfiguration.champion.freeToPlay:grid-champion-free-to-play",
            "freeToPlayForQueueClass",
            "championConfiguration.champion.rented:grid-champion-rented",
            "championConfiguration.champion.selectionStatus.isBanned:grid-champion-banned",
          ],
          attributeBindings: [
            "championConfiguration.champion.id:data-id",
            "championConfiguration.disabledAttr:disabled",
          ],
          layout: n(219),
          mouseEnter: function () {
            this.sendAction(
              "showDisabledTooltip",
              this.get("championConfiguration"),
            );
          },
          click: function () {
            const e = this.get("championConfiguration");
            this.sendAction("select", e);
          },
          contextMenu: function (e) {
            if ((e.preventDefault(), !this.get("favoritesEnabled"))) return;
            const t = this.get("contextMenuModel");
            t && t.length && (o.setMenuItems(t), o.openAtEvent(e));
          },
          favoritesEnabled: s.Ember.computed(
            "championConfiguration.favoritesEnabled",
            "championConfiguration.id",
            function () {
              const e = this.get("championConfiguration.favoritesEnabled"),
                t = this.get("championConfiguration.id");
              return (
                !(t === i.RANDOM_CHAMP.championId || t === i.NONE_CHAMP_ID) && e
              );
            },
          ),
          favoriteIcon: s.Ember.computed.alias(
            "championConfiguration.favorite",
          ),
          contextMenuModel: s.Ember.computed(
            "championConfiguration.champion",
            "championConfiguration.champion.positionsFavorited",
            "championConfiguration.grid.filters",
            "championConfiguration.grid.filters.@each.favoriteName",
            "championConfiguration.grid.filters.@each.canFavorite",
            "championConfiguration.grid.filters.@each.unfavoriteName",
            function () {
              const e =
                  this.get(
                    "championConfiguration.champion.positionsFavorited",
                  ) || [],
                t = [],
                n = this.get("championConfiguration.grid.filters");
              for (let s = 0; s < n.length; s++) {
                const i = n[s];
                if (!i.get("canFavorite")) continue;
                const o = i.get("name");
                t.push({
                  action: (function (e) {
                    return function () {
                      this.sendAction(
                        "toggleFavorite",
                        this.get("championConfiguration.champion"),
                        e,
                      );
                    };
                  })(o),
                  target: this,
                  label: e.includes(o)
                    ? i.get("unfavoriteName")
                    : i.get("favoriteName"),
                });
              }
              return t;
            },
          ),
          loyaltyIconClass: s.Ember.computed(
            "championConfiguration.champion.loyaltyReward",
            "championConfiguration.champion.xboxGPReward",
            "UseNewLoyaltyIcon",
            function () {
              const e = this.get(
                  "championConfiguration.champion.loyaltyReward",
                ),
                t = this.get("championConfiguration.champion.xboxGPReward"),
                n = this.get("UseNewLoyaltyIcon");
              return e || t
                ? n
                  ? "grid-champion-loyalty-reward-new"
                  : "grid-champion-loyalty-reward"
                : "";
            },
          ),
          freeToPlayForQueueClass: s.Ember.computed(
            "championConfiguration.champion.freeToPlayForQueue",
            "isRGM",
            function () {
              let e = "";
              return (
                this.get("championConfiguration.champion.freeToPlayForQueue") &&
                  this.get("isRGM") &&
                  (e = "grid-champion-free-to-play-rgm"),
                e
              );
            },
          ),
        });
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "W/dzp63C",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-grid-champion-component\\\\layout.hbs\\" style-path=\\"null\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-grid-champion-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","grid-champion-hitbox"],["flush-element"],["text","\\n  "],["open-element","div",[]],["dynamic-attr","disabled",["unknown",["championConfiguration","disabledAttr"]],null],["static-attr","class","champion-grid-champion-thumbnail"],["flush-element"],["text","\\n    "],["open-element","img",[]],["static-attr","class","champion-background-image"],["dynamic-attr","src",["unknown",["championConfiguration","champion","squarePortraitPath"]],null],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","lol-uikit-resizing-text-field",[]],["static-attr","class","champion-name"],["static-attr","data-max-width","100"],["flush-element"],["append",["unknown",["championConfiguration","champion","name"]],false],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","class","grid-champion-overlay"],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(152),
          i = n(221);
        const o = n(1),
          { Ember: a, EmberAddons: r } = o,
          { EmberHelpers: l } = o,
          { RunMixin: c } = r.EmberLifeline;
        n(222),
          (e.exports = a.Component.extend(c, {
            classNames: ["champion-splash-background"],
            classNameBindings: [
              "champSelectScreen",
              "largeAreaAnimationsEnabled:large-area-animations-enabled:large-area-animations-disabled",
              "isAnimating:is-animating:is-pending",
              "lastCompletedBanIsPlayerTeam:is-player-team:is-enemy-team",
              "isRotating:is-rotating:is-not-rotating",
              "isShowingGrid:is-showing-grid:is-not-showing-grid",
              "newOutroLeft:new-pick-outro-left",
              "newOutroRight:new-pick-outro-right",
              "isNotPickingAndNotSelectedScreen:mask-splash",
              "currentNotification",
            ],
            layout: n(223),
            animationDispatcher: a.inject.service("animation-dispatcher"),
            banLockedInAnimationState: a.computed.alias(
              "animationDispatcher.states.banLockedInAnimation",
            ),
            banRotationAnimationState: a.computed.alias(
              "animationDispatcher.states.banRotationAnimation",
            ),
            banOutroAnimationState: a.computed.alias(
              "animationDispatcher.states.banOutroAnimation",
            ),
            lowSpecBanLockedInAnimationState: a.computed.alias(
              "animationDispatcher.states.lowSpecBanLockedInAnimation",
            ),
            newOutroLeft: a.computed.equal("pickJustLockedIn", "left"),
            newOutroRight: a.computed.equal("pickJustLockedIn", "right"),
            isAnimating: a.computed.equal(
              "banLockedInAnimationState",
              i.ANIMATION_STATES.STARTED,
            ),
            isRotating: a.computed.equal(
              "banRotationAnimationState",
              i.ANIMATION_STATES.STARTED,
            ),
            lastSelectedSplash: "",
            lastCompletedBanSplash: a.computed.alias(
              "sessionActions.lastCompletedBanAction.champion.skins.firstObject.splashPath",
            ),
            lastCompletedBanIsPlayerTeam: a.computed.alias(
              "sessionActions.lastCompletedBanAction.actor.isOnLeftSide",
            ),
            throttledSplashPath: l.throttled("splashPath", 300),
            backgroundSwitcherClasses: a.computed(
              "splashUnlocked",
              function () {
                return (
                  "champ-select-bg " +
                  (this.get("splashUnlocked") ? "unlocked" : "locked")
                );
              },
            ),
            isNotPickingAndNotSelectedScreen: a.computed(
              "currentSummoner.isPickingNow",
              "champSelectScreen",
              function () {
                return (
                  !this.get("currentSummoner.isPickingNow") &&
                  this.get("champSelectScreen") !== s.SCREENS.selected
                );
              },
            ),
            isBanPhase: a.computed.or("hasBans", "isAnimating"),
            isNotBanPhase: a.computed.not("isBanPhase"),
            largeAreaAnimationsEnabled: a.computed.alias(
              "uxSettings.largeAreaAnimationsEnabled",
            ),
            isShowingSelectedScreen: a.computed.equal(
              "champSelectScreen",
              s.SCREENS.selected,
            ),
            showEmblems: a.computed(
              "champSelectScreen",
              "emblems",
              function () {
                return (
                  this.get("emblems") &&
                  this.get("champSelectScreen") === s.SCREENS.selected
                );
              },
            ),
            hideSplashBackground: a.computed(
              "throttledSplashPath",
              function () {
                return !this.get("throttledSplashPath");
              },
            ),
            startedInSelected: a.computed.not("isDraftMode"),
            hasShownVoteReveal: a.computed(
              "isShowingVoteReveal",
              "sessionActions.completedVoteRevealActions.length",
              function () {
                return (
                  this.get("isShowingVoteReveal") ||
                  this.get("sessionActions.completedVoteRevealActions.length") >
                    0
                );
              },
            ),
            selectedScreenTransitionType: a.computed(
              "hasShownVoteReveal",
              "startedInSelected",
              function () {
                return this.get("hasShownVoteReveal") ||
                  !this.get("startedInSelected")
                  ? "fade"
                  : "pop-in-fade";
              },
            ),
            transitionType: a.computed(
              "largeAreaAnimationsEnabled",
              "champSelectScreen",
              "isShowingVoteReveal",
              "selectedScreenTransitionType",
              function () {
                let e = "none";
                if (this.get("largeAreaAnimationsEnabled")) {
                  const t = this.get("champSelectScreen");
                  this.get("isShowingVoteReveal")
                    ? (e = "pop-in-fade")
                    : t === s.SCREENS.selected
                      ? (e = this.get("selectedScreenTransitionType"))
                      : (t !== s.SCREENS.pick && t !== s.SCREENS.banShowcase) ||
                        (e = "small-pop");
                }
                return e;
              },
            ),
            currentNotification: a.computed(
              "currentSummoner.lastPickSnipedChampion",
              function () {
                return this.get("currentSummoner.lastPickSnipedChampion")
                  ? "pick-snipe-notification"
                  : "";
              },
            ),
            pickSnipeBanEnemyActionIndexClass: a.computed(
              "sessionActions.theirTeamBanActions.@each",
              "currentSummoner.lastPickSnipedChampion.banAction.actor.isOnPlayersTeam",
              function () {
                const e = this.get(
                    "currentSummoner.lastPickSnipedChampion.banAction",
                  ),
                  t = (
                    this.get("sessionActions.theirTeamBanActions") || []
                  ).indexOf(e);
                return t ? "pick-snipe-banned-by-enemy-index-" + t : "";
              },
            ),
            playLowSpecBanAnimation: function () {
              let e;
              const t = this.get("lastCompletedBanSplash");
              this.set(
                "lastSelectedSplash",
                this.get("lastCompletedBanSplash"),
              ),
                new Promise((t) => (e = t)).then(() => {
                  this.isDestroying ||
                    this.isDestroyed ||
                    this.get("lastCompletedBanSplash") !== t ||
                    (this.get("animationDispatcher").stopAnimation(
                      "lowSpecBanLockedInAnimation",
                    ),
                    this.get("animationDispatcher").stopAnimation(
                      "fullBanAnimation",
                    ));
                });
              const n = this.$("#champion-splash-ban-image");
              n.one("animationend", e),
                n.addClass("champselect-ban-lowspec-animation"),
                this.runTask(e, 1270);
            },
            setSlashImageOnSVGComponent: function () {
              const e = this.get("lastSelectedSplash") || "",
                t = this.element.querySelector(
                  "#champion-splash-ban-component",
                ),
                n = t && t.querySelector("#champion-splash-image");
              n &&
                n.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "xlink:href",
                  e,
                );
            },
            playLowSpecBanLockedInAnimation: l.observeChange(
              "lowSpecBanLockedInAnimationState",
              function () {
                if (
                  this.get("lowSpecBanLockedInAnimationState") ===
                  i.ANIMATION_STATES.STARTED
                )
                  this.playLowSpecBanAnimation(
                    this.get("lastCompletedBanSplash"),
                  );
                else {
                  this.set("lastSelectedSplash", "");
                  this.$("#champion-splash-ban-image").removeClass(
                    "champselect-ban-lowspec-animation",
                  );
                }
              },
            ),
            playBanLockedInAnimation: l.observeChange(
              "banLockedInAnimationState",
              function () {
                this.get("banLockedInAnimationState") ===
                i.ANIMATION_STATES.STARTED
                  ? (this.scaleAnimation && this.scaleAnimation.cancel(),
                    this.fadeOutAnimation && this.fadeOutAnimation.cancel(),
                    this.set(
                      "lastSelectedSplash",
                      this.get("lastCompletedBanSplash"),
                    ),
                    this.setSlashImageOnSVGComponent())
                  : (this.set("lastSelectedSplash", ""),
                    this.setSlashImageOnSVGComponent(),
                    this.set(
                      "banLockedInAnimationState",
                      i.ANIMATION_STATES.STOPPED,
                    ),
                    this.set(
                      "banRotationAnimationState",
                      i.ANIMATION_STATES.STOPPED,
                    ));
              },
            ),
            playBanOutroAnimation: l.observeChange(
              "banOutroAnimationState",
              function () {
                if (
                  this.get("banOutroAnimationState") ===
                  i.ANIMATION_STATES.STARTED
                ) {
                  const e = this.element.querySelector(
                    "#champion-splash-ban-component",
                  );
                  e && this.get("largeAreaAnimationsEnabled")
                    ? ((this.fadeOutAnimation = this.fadeOutElement(e, 300, 0)),
                      (this.scaleAnimation = this.scaleDownElement(e, 400, 0)),
                      (this.scaleAnimation.onfinish =
                        this.banAnimationComplete.bind(this)))
                    : this.banAnimationComplete();
                }
              },
            ),
            banAnimationComplete: function () {
              this.set("banLockedInAnimationState", i.ANIMATION_STATES.STOPPED);
            },
            fadeOutElement: function (e, t, n) {
              if (!e) return;
              return e.animate(
                [
                  { opacity: 1, display: "block" },
                  { opacity: 0, display: "none" },
                ],
                { duration: t, delay: n, fill: "both" },
              );
            },
            scaleDownElement: function (e, t, n) {
              if (!e) return;
              const s = window.getComputedStyle(e);
              return e.animate(
                [
                  { transform: s.transform + " scale(1)" },
                  { transform: s.transform + " scale(0.8)" },
                ],
                { duration: t, delay: n, fill: "both" },
              );
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = t.ANIMATION_STATES = void 0);
        const s = n(1),
          { Ember: i } = s,
          o = { STOPPED: "stopped", STARTED: "started", DONE: "done" };
        t.ANIMATION_STATES = o;
        var a = i.Service.extend({
          states: i.Object.create(),
          playAnimation: function (e) {
            const t = "states." + e;
            let n = null;
            const s = new Promise((e) => {
                n = e;
              }),
              i = () => {
                const e = this.get(t);
                (e !== o.DONE && e !== o.STOPPED) ||
                  (n(), this.removeObserver(t, this, i));
              };
            return this.addObserver(t, this, i), this.set(t, o.STARTED), s;
          },
          stopAnimation: function (e) {
            const t = "states." + e;
            this.set(t, o.DONE);
          },
        });
        t.default = a;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "JiHWLktB",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-background-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-background-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-background-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["background-vignette-container\\n  ",["helper",["if"],[["get",["splashDefocus"]],"defocussed","focussed"],null],"\\n  ",["helper",["if"],[["get",["largeAreaAnimationsEnabled"]],"animated","static"],null],"\\n  ",["helper",["if"],[["get",["hideSplashBackground"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["uikit-background-switcher"],null,[["class","src","transitionType","overlays"],[["get",["backgroundSwitcherClasses"]],["get",["throttledSplashPath"]],["get",["transitionType"]],["get",["skinAguments"]]]]],false],["text","\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["throttledSplashPath"]],"champ-select-bg-darken"],null]]]],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["showEmblems"]]],null,1],["text","\\n"],["open-element","div",[]],["static-attr","id","champion-splash-ban-container"],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["isShowingSelectedScreen"]],"removed"],null]]]],["flush-element"],["text","\\n  "],["open-element","img",[]],["static-attr","id","champion-splash-ban-image"],["dynamic-attr","src",["unknown",["lastSelectedSplash"]],null],["flush-element"],["close-element"],["text","\\n  "],["open-element","svg",[]],["static-attr","xmlns","http://www.w3.org/2000/svg","http://www.w3.org/2000/xmlns/"],["static-attr","xmlns:xlink","http://www.w3.org/1999/xlink","http://www.w3.org/2000/xmlns/"],["static-attr","id","champion-splash-ban-component"],["static-attr","width","538"],["static-attr","height","538"],["static-attr","viewBox","0 0 538 538"],["flush-element"],["text","\\n    "],["open-element","defs",[]],["flush-element"],["text","\\n      "],["open-element","style",[]],["flush-element"],["text","\\n        @keyframes rotatePlayer {\\n          from { transform: rotate(0deg); }\\n          to { transform: rotate(45deg); }\\n        }\\n\\n        @keyframes rotateEnemy {\\n          from { transform: rotate(0deg); }\\n          to { transform: rotate(-45deg); }\\n        }\\n\\n        @keyframes fadeToGrayscale {\\n          from { -webkit-filter: grayscale(0); }\\n          to { -webkit-filter: grayscale(100%); }\\n        }\\n\\n        @keyframes sliceMaskPlayer {\\n          from { transform: translateX(-100%); }\\n          to { transform: translateX(0); }\\n        }\\n\\n        @keyframes sliceMaskEnemy {\\n          from { transform: translateX(100%); }\\n          to { transform: translateX(0); }\\n        }\\n\\n        @keyframes sliceRight {\\n          from { transform: translateX(0); }\\n          to { transform: translateX(35px); }\\n        }\\n\\n        @keyframes sliceLeft {\\n          from { transform: translateX(0); }\\n          to { transform: translateX(-35px); }\\n        }\\n      "],["close-element"],["text","\\n\\n      "],["open-element","mask",[]],["static-attr","id","slash-ban-circle-container-mask"],["static-attr","maskUnits","userSpaceOnUse"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","100%"],["static-attr","height","100%"],["flush-element"],["text","\\n        "],["open-element","circle",[]],["static-attr","cx","269"],["static-attr","cy","269"],["static-attr","r","269"],["static-attr","fill","#fff"],["flush-element"],["close-element"],["text","\\n        "],["open-element","g",[]],["static-attr","class","container-slice-rotation"],["flush-element"],["text","\\n          "],["open-element","rect",[]],["static-attr","id","rect-container-slice"],["static-attr","x","-2"],["static-attr","y","264"],["static-attr","width","542"],["static-attr","height","12"],["static-attr","fill","#000"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","mask",[]],["static-attr","id","rect-container-mask-top"],["static-attr","maskUnits","userSpaceOnUse"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","100%"],["static-attr","height","100%"],["flush-element"],["text","\\n        "],["open-element","g",[]],["static-attr","class","container-slice-rotation"],["flush-element"],["text","\\n          "],["open-element","rect",[]],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","100%"],["static-attr","height","50%"],["static-attr","fill","#fff"],["flush-element"],["close-element"],["text","\\n          "],["open-element","rect",[]],["static-attr","x","0"],["static-attr","y","50%"],["static-attr","width","100%"],["static-attr","height","50%"],["static-attr","fill","#000"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","mask",[]],["static-attr","id","rect-container-mask-bottom"],["static-attr","maskUnits","userSpaceOnUse"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","100%"],["static-attr","height","100%"],["flush-element"],["text","\\n        "],["open-element","g",[]],["static-attr","class","container-slice-rotation"],["flush-element"],["text","\\n          "],["open-element","rect",[]],["static-attr","x","0"],["static-attr","y","50%"],["static-attr","width","100%"],["static-attr","height","50%"],["static-attr","fill","#fff"],["flush-element"],["close-element"],["text","\\n          "],["open-element","rect",[]],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","100%"],["static-attr","height","50%"],["static-attr","fill","#000"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","image",[]],["static-attr","id","champion-splash-image"],["static-attr","xlink:href","","http://www.w3.org/1999/xlink"],["static-attr","x","-371"],["static-attr","y","-21"],["static-attr","width","1280"],["static-attr","height","720"],["flush-element"],["close-element"],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","g",[]],["static-attr","mask","url(#slash-ban-circle-container-mask)"],["flush-element"],["text","\\n      "],["open-element","g",[]],["static-attr","mask","url(#rect-container-mask-top)"],["flush-element"],["text","\\n        "],["open-element","use",[]],["static-attr","id","image-top"],["static-attr","xlink:href","#champion-splash-image","http://www.w3.org/1999/xlink"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","g",[]],["static-attr","mask","url(#rect-container-mask-bottom)"],["flush-element"],["text","\\n        "],["open-element","use",[]],["static-attr","id","image-bottom"],["static-attr","xlink:href","#champion-splash-image","http://www.w3.org/1999/xlink"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","ban-background-overlay-container"],["flush-element"],["close-element"],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["background-edge-backlight ",["unknown",["pickSnipeBanEnemyActionIndexClass"]]]]],["flush-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","img",[]],["dynamic-attr","src",["concat",[["unknown",["emblem","emblemPath","large"]]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":["emblem"]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","champion-splash-emblem-overlay"],["flush-element"],["text","\\n"],["block",["each"],[["get",["emblems"]]],null,0],["text","  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n(225);
        const s = n(1),
          { Ember: i } = s;
        e.exports = i.Component.extend({
          classNames: ["champion-splash-ring"],
          classNameBindings: [
            "champSelectScreen",
            "actingSummonerCellClass",
            "largeAreaAnimationsEnabled:animation-enabled",
            "shouldPlayIntroAnimation:should-play-intro",
            "isHeaderExpanded:expanded-header",
          ],
          layout: n(226),
          largeAreaAnimationsEnabled: i.computed.equal(
            "uxSettings.largeAreaAnimationsEnabled",
            !0,
          ),
          actingSummonerCellClass: i.computed(
            "actingSummonerCell",
            function () {
              return "summoner-acting-now-" + this.get("actingSummonerCell");
            },
          ),
          actingSummonerCell: i.computed(
            "currentActions.@each.type",
            "currentActions.@each.completed",
            function () {
              if (this.get("currentActions")) {
                const e = this.get("currentActions").findBy("completed", !1);
                if (e) return e.get("actorCellId");
              }
              return null;
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "XeIUd6hk",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-ring-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-ring-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\champion-splash-ring-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","ring-splash-dashed"],["flush-element"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","ring-splash-outer"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","left-ring"],["flush-element"],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","right-ring"],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","ring-splash-inner"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","left-ring"],["flush-element"],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","right-ring"],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(228);
        const i = s.Ember.Component.extend({
          classNames: ["champ-select-chroma-modal"],
          classNameBindings: ["baseSkin.chromaPreviewPath:chroma-view"],
          layout: n(229),
          didReceiveAttrs: function () {
            this._super(...arguments);
            const e = this.get("baseSkin"),
              t = this.get("hoverSkin");
            if (!t || !e) return;
            const n = t.id === e.id,
              s = t.championId === e.championId && t.parentSkinId === e.id;
            n || s || this.set("hoverSkin", void 0);
          },
          didRender: function () {
            this._super(...arguments);
            const e = this.get("selectedSkinId");
            this.element
              .querySelectorAll(".chroma-list-item")
              .forEach(function (t) {
                t.classList.contains(`id-${e}`)
                  ? t.classList.add("selected")
                  : t.classList.remove("selected");
              });
          },
          doesSkinHaveChromas: s.Ember.computed.bool(
            "baseSkin.chromaPreviewPath",
          ),
          doesSkinHaveForms: s.Ember.computed(
            "doesSkinHaveChromas",
            function () {
              return (
                !this.get("doesSkinHaveChromas") &&
                "kQuestSkin" === this.get("baseSkin.productType")
              );
            },
          ),
          displayedSkin: s.Ember.computed(
            "baseSkin.childSkins",
            "selectedSkinId",
            "hoverSkin",
            function () {
              const e = this.get("selectedSkinId"),
                t = (this.get("baseSkin.childSkins") || []).find(
                  (t) => t.id === e,
                ),
                n = this.get("hoverSkin");
              return n && !n.isDestroying ? n : t || this.get("baseSkin");
            },
          ),
          sortedChromas: s.Ember.computed(
            "baseSkin.childSkins.[]",
            "disabledChromas",
            function () {
              const e = this.get("disabledChromas") || [];
              return (this.get("baseSkin.childSkins") || [])
                .filter((t) => !e.includes(t.id))
                .sort((e, t) =>
                  e.ownership.owned === t.ownership.owned
                    ? e.id < t.id
                      ? -1
                      : 1
                    : e.ownership.owned
                      ? -1
                      : 1,
                );
            },
          ),
          actions: {
            setSkin: function (e) {
              this.sendAction("setSkinThroughChromaModal", e);
            },
            showPreview: function (e) {
              this.set("hoverSkin", e);
            },
            closePreview: function () {
              this.set("hoverSkin", void 0);
            },
          },
        });
        e.exports = i;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "fGl9gnob",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["doesSkinHaveChromas"]]],null,3],["text","\\n"],["block",["if"],[["get",["doesSkinHaveForms"]]],null,1]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["open-element","div",[]],["dynamic-attr","class",["concat",["chroma-list-item id-",["unknown",["chroma","id"]]," ",["helper",["unless"],[["get",["chroma","unlocked"]],"locked"],null]]]],["dynamic-attr","onmouseup",["helper",["action"],[["get",[null]],"setSkin",["get",["chroma"]]],null],null],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","chroma-list-item-highlight-container"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","chroma-list-item-highlight"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","chroma-list-item-content"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","chroma-list-item-name"],["flush-element"],["append",["unknown",["chroma","shortName"]],false],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","chroma-list-item-status-icon"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":["chroma"]},{"statements":[["block",["each"],[["get",["sortedChromas"]]],null,0]],"locals":[]},{"statements":[["text","      "],["append",["helper",["skin-button"],null,[["skin","selectedSkinId","baseSkin","onClick","onEnter","onLeave","setSkin","showPreview","closePreview","jmxSettings","timeRemaining","inFinalizationPhase"],[["get",["chroma"]],["get",["selectedSkinId"]],["get",["skin"]],["helper",["action"],[["get",[null]],"setSkin"],null],["helper",["action"],[["get",[null]],"showPreview"],null],["helper",["action"],[["get",[null]],"closePreview"],null],"setSkin","showPreview","closePreview",["get",["jmxSettings"]],["get",["timeRemaining"]],["get",["inFinalizationPhase"]]]]],false],["text","\\n"]],"locals":["chroma"]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","chroma-information"],["dynamic-attr","style",["concat",["background-image: url(\'",["unknown",["currentMapChromaPath"]],"\')"]]],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","chroma-information-image"],["dynamic-attr","style",["concat",["background-image: url(\'",["unknown",["displayedSkin","chromaPreviewPath"]],"\')"]]],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","child-skin-name"],["flush-element"],["text","\\n      "],["append",["unknown",["displayedSkin","name"]],false],["text","\\n      "],["open-element","div",[]],["static-attr","class","child-skin-disabled-notification"],["flush-element"],["append",["helper",["if"],[["get",["displayedSkin","disabled"]],["get",["tra","skin_unselectable_because_disabled"]]],null],false],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","lol-uikit-scrollable",[]],["static-attr","class","chroma-selection"],["static-attr","overflow-masks","enabled"],["flush-element"],["text","\\n    "],["append",["helper",["skin-button"],null,[["skin","selectedSkinId","onClick","onEnter","onLeave","setSkin","showPreview","closePreview","jmxSettings","timeRemaining","inFinalizationPhase"],[["get",["baseSkin"]],["get",["selectedSkinId"]],["helper",["action"],[["get",[null]],"setSkin"],null],["helper",["action"],[["get",[null]],"showPreview"],null],["helper",["action"],[["get",[null]],"closePreview"],null],"setSkin","showPreview","closePreview",["get",["jmxSettings"]],["get",["timeRemaining"]],["get",["inFinalizationPhase"]]]]],false],["text","\\n"],["block",["each"],[["get",["sortedChromas"]]],null,2],["text","  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(231),
          (e.exports = s.Ember.Component.extend({
            layout: n(232),
            classNames: ["disconnect-notification"],
            champSelectDisconnectService: s.Ember.inject.service(
              "champ-select-disconnect",
            ),
            init: function () {
              this._super(...arguments),
                this.get(
                  "champSelectDisconnectService",
                ).setDisconnectShouldExitCallback(
                  this._handleDisconnectShouldExit.bind(this),
                );
            },
            didInsertElement: function () {
              this._super(...arguments);
              const e = this.element.querySelector(
                ".champ-select-disconnect-notification-content",
              );
              e &&
                (this.set("disconnectNotificationContent", e),
                this._showDisconnectNotification());
            },
            willDestroyElement: function () {
              this._super(...arguments),
                this._hideDisconnectNotification(),
                this._hideDisconnectShouldExitDialog();
            },
            _showDisconnectNotification: function () {
              const e = this.get("disconnectNotificationContent");
              if (this.get("disconnectNotification") || !e) return;
              const t = s.ContextualNotificationManager.add(
                this.get("disconnectNotificationContent"),
                { dismissable: !1, position: { top: 40, right: 30 } },
              );
              this.set("disconnectNotification", t);
            },
            _hideDisconnectNotification: function () {
              const e = this.get("disconnectNotification");
              e &&
                (s.ContextualNotificationManager.remove(e),
                this.set("disconnectNotification", null));
            },
            _handleDisconnectShouldExit: function (e) {
              const t = !!this.get("disconnectNotification");
              e && t
                ? this._showDisconnectShouldExitDialog()
                : this._hideDisconnectShouldExitDialog();
            },
            _showDisconnectShouldExitDialog: function () {
              if (!this.get("disconnectShouldExitDialog")) {
                const e = s.ModalManager.add({
                  type: "DialogAlert",
                  data: {
                    contents: s.TemplateHelper.contentBlockDialog(
                      this.get("tra.disconnect_should_exit_dialog_title"),
                      this.get("tra.disconnect_should_exit_dialog_body"),
                      "dialog-small",
                    ),
                    okText: this.get(
                      "tra.disconnect_should_exit_dialog_button",
                    ),
                    dismissable: !1,
                  },
                });
                e.okPromise.then(() => {
                  window.riotInvoke &&
                    window.riotInvoke({
                      request: JSON.stringify({
                        name: "RiotClient.Exit",
                        params: [],
                      }),
                    });
                }),
                  this.set("disconnectShouldExitDialog", e);
              }
            },
            _hideDisconnectShouldExitDialog: function () {
              const e = this.get("disconnectShouldExitDialog");
              e &&
                (s.ModalManager.remove(e),
                this.set("disconnectShouldExitDialog", null));
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "5uQUlaUy",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\disconnect-notification-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\disconnect-notification-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\disconnect-notification-component\\\\index.js\\" "],["text","\\n"],["open-element","lol-uikit-content-block",[]],["static-attr","class","champ-select-disconnect-notification-content"],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","spinner-container"],["flush-element"],["text","\\n        "],["append",["helper",["uikit-spinner"],null,[["width","height"],["40px","40px"]]],false],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","text-container"],["flush-element"],["text","\\n        "],["open-element","h5",[]],["static-attr","class","title-text-container"],["flush-element"],["append",["unknown",["tra","disconnect_notification_title"]],false],["close-element"],["text","\\n        "],["open-element","p",[]],["static-attr","class","body-text-container"],["flush-element"],["append",["unknown",["tra","disconnect_notification_body"]],false],["close-element"],["text","\\n    "],["close-element"],["text","\\n"],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = (s = n(150)) && s.__esModule ? s : { default: s },
          a = n(234),
          r = n(155),
          l = n(152);
        n(236);
        const { DomMixin: c } = i.EmberAddons.EmberLifeline,
          u = i.UiKitPlugin.getLayerManager(),
          m = i.ViewportPlugin.fullScreen().getScreenRoot(
            "rcp-fe-lol-champ-select",
          );
        e.exports = i.Ember.Component.extend(c, {
          layout: n(237),
          classNames: ["emotes-edit-button-container"],
          classNameBindings: ["disabled", "showingEmotes"],
          showingEmotes: !1,
          _screenRootHideCallback: null,
          disabled: i.Ember.computed(
            "isDonePicking",
            "lockedAtEndOfChampSelect",
            "showingEmotes",
            function () {
              return (
                !this.get("isDonePicking") ||
                this.get("lockedAtEndOfChampSelect") ||
                this.get("showingEmotes")
              );
            },
          ),
          noWardSkins: i.Ember.computed.not("wardSkinsAvailable"),
          emotesButtonTooltipString: i.Ember.computed(
            "disabled",
            "tra.ready",
            "tra.emotes_edit_button",
            "tra.emotes_edit_button_disabled",
            function () {
              return this.get("disabled")
                ? this.get("tra.emotes_edit_button_disabled")
                : this.get("tra.emotes_edit_button");
            },
          ),
          actions: {
            onEmotesButtonHover: function () {
              this.get("disabled") ||
                o.default.playSound(
                  l.SFX_CHANNEL,
                  l.SOUNDS_PATH + "/sfx-uikit-grid-hover.ogg",
                );
            },
            openEmotesPanel: function () {
              this.get("disabled") ||
                this.get("showingEmotes") ||
                (o.default.playSound(
                  "sfx-ui",
                  "/fe/lol-champ-select/sounds/sfx-uikit-edit-click.ogg",
                ),
                i.Telemetry.recordNonTimingTracingEvent(
                  "emote-panel-opened",
                  1,
                  "click",
                ),
                this.set("emotesModalComponent", null),
                this.set("emotePanelApplication", null),
                this.initEmotePanel().then(
                  function () {
                    this.showEmoteModal();
                  }.bind(this),
                ));
            },
          },
          initEmotePanel: function () {
            return (0, r.useEmotesApi)((e) =>
              e.getCurrentPlayerEmotePanel().then((e) => {
                this.setEmotesModalComponent(e), this.addModalCloseListener();
              }),
            );
          },
          setEmotesModalComponent: function (e) {
            if (!this.get("emotesModalComponent")) {
              const t = (0, a.createFullScreenModal)(e.domNode, "emotes-modal");
              this.set("emotesModalComponent", t),
                this.set("emotePanelApplication", e);
            }
          },
          addModalCloseListener: function () {
            const e = function () {
              this.onEditEmoteModalClosing();
            }.bind(this);
            this.set("closingModalCallback", e),
              this.addEventListener(
                this.get("emotesModalComponent"),
                "closeButtonClick",
                e,
              );
          },
          onEditEmoteModalClosing: function () {
            this.hideEmoteModal(!1);
          },
          showEmoteModal: function () {
            this.get("showingEmotes") ||
              (u.addLayer(this.get("emotesModalComponent")),
              this.set("showingEmotes", !0),
              this.set("_screenRootHideCallback", () => {
                this.get("showingEmotes") &&
                  this.get("emotesModalComponent") &&
                  this.hideEmoteModal(!1),
                  m.off("hide", this.get("_screenRootHideCallback"));
              }),
              m.on("hide", this.get("_screenRootHideCallback")));
          },
          hideEmoteModal: function () {
            this.get("showingEmotes") && this._removeEmotesModalLayer();
          },
          _removeEmotesModalLayer: function () {
            if (this.get("emotesModalComponent")) {
              const e = this.get("emotePanelApplication");
              this.get("emotesModalComponent").removeEventListener(
                "closeButtonClick",
                this.get("closingModalCallback"),
              ),
                u.removeLayer(this.get("emotesModalComponent")),
                e && e.onRemove && e.onRemove(),
                this.isDestroyed ||
                  this.isDestroying ||
                  (this.set("showingEmotes", !1),
                  this.set("emotesModalComponent", null),
                  this.set("emotePanelApplication", null));
            }
          },
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.createFullScreenModal = function (e, t) {
            return s.ComponentFactory.create("FullScreenModal", {
              elementClassName: t,
              domNode: e,
            });
          });
        var s = n(1);
        n(235);
        s.ComponentFactory.setFactory("FullScreenModal", function (e) {
          const t = document.createElement("div");
          t.className = e.elementClassName;
          const n = document.createElement("lol-uikit-dialog-frame");
          return (
            n.setAttribute("dismissable", ""),
            n.setAttribute("dismissable-type", "outside"),
            t.appendChild(n),
            n.appendChild(e.domNode),
            t
          );
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "u4Jsk5PV",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\emotes-edit-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\emotes-edit-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\emotes-edit-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["emotes-edit-button ",["helper",["if"],[["get",["disabled"]],"disabled"],null]," ",["helper",["if"],[["get",["showingEmotes"]],"showing-emotes"],null]," ",["helper",["if"],[["get",["noWardSkins"]],"no-ward-skins"],null]]]],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"openEmotesPanel"],null],null],["dynamic-attr","onmouseover",["helper",["action"],[["get",[null]],"onEmotesButtonHover"],null],null],["flush-element"],["close-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","type","offsetY"],["top","system",16]],0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","class","champ-select-edit-emotes-button-tooltip"],["flush-element"],["text","\\n      "],["open-element","p",[]],["flush-element"],["append",["unknown",["emotesButtonTooltipString"]],false],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(239);
        const { RunMixin: i } = s.EmberAddons.EmberLifeline;
        let o;
        e.exports = s.Ember.Component.extend(i, {
          classNames: ["flyout-selector-button-container"],
          classNameBindings: [
            "item.locked:disabled",
            "isSelectedItem:selected-item",
          ],
          attributeBindings: ["data-id"],
          layout: n(240),
          isItemVisible: !1,
          "data-id": s.Ember.computed.alias("item.id"),
          isSelectedItem: s.Ember.computed("selectedItem", "item", function () {
            return (
              !!this.get("selectedItem") &&
              this.get("selectedItem.id") === this.get("item.id")
            );
          }),
          willDestroyElement() {
            this.cancelTask(o);
          },
          displayItemHoverInfo(e) {
            o && this.cancelTask(o), this.onFlyoutItemHover(e);
          },
          clearItemHoverInfo() {
            o = this.runTask(this._clearHover, 100);
          },
          _clearHover() {
            this.onFlyoutItemHover(null);
          },
          actions: {
            itemSelected: function (e) {
              this.onFlyoutItemSelected(e);
            },
            displayItemHoverInfo: function (e) {
              this.displayItemHoverInfo(e);
            },
            clearItemHoverInfo: function () {
              this.clearItemHoverInfo();
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "cs/Ob4pq",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-popup-button\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-popup-button\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-popup-button\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","flyout-selector-button-icon"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"itemSelected",["get",["item"]]],null],null],["dynamic-attr","onmouseover",["helper",["action"],[["get",[null]],"displayItemHoverInfo",["get",["item"]]],null],null],["dynamic-attr","onmouseout",["helper",["action"],[["get",[null]],"clearItemHoverInfo"],null],null],["flush-element"],["text","\\n  "],["open-element","button",[]],["static-attr","class","flyout-selector-button"],["flush-element"],["text","\\n    "],["open-element","img",[]],["dynamic-attr","src",["concat",[["unknown",["item","iconPath"]]]]],["static-attr","class","flyout-selector-button-image"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = n(152),
          a = (s = n(150)) && s.__esModule ? s : { default: s };
        const { RunMixin: r, DomMixin: l } = i.EmberAddons.EmberLifeline;
        n(242),
          (e.exports = i.Ember.Component.extend(r, l, {
            layout: n(243),
            classNames: ["flyout-selector-trigger-button"],
            classNameBindings: ["disabled:disabled:enabled", "animateButton"],
            disabled: !1,
            animateButton: !1,
            init() {
              this._super(...arguments),
                (this.onAnimationEnd = this.onAnimationEnd.bind(this));
            },
            didReceiveAttrs() {
              this._super(...arguments),
                this.get("lastSelectedItem") !== this.get("selectedItem") &&
                  (this.get("didUserChangeItem") &&
                    (this._runAfterRender = i.Ember.run.scheduleOnce(
                      "afterRender",
                      this,
                      () => {
                        this.set("animateButton", !0),
                          this.afterUserChangedItemAnimation();
                      },
                    )),
                  this.set("lastSelectedItem", this.get("selectedItem")));
            },
            didRender: function () {
              this._super(...arguments), this.initAnimationEnd();
            },
            willDestroyElement() {
              this._super(...arguments), this.cancelTask(this._runAfterRender);
            },
            onAnimationEnd: function () {
              this.isDestroying ||
                this.isDestroyed ||
                this.set("animateButton", !1);
            },
            initAnimationEnd: function () {
              if (this.animationEndEventHandled) return;
              const e = this.element.querySelector(".animated-border-overlay");
              e &&
                (this.addEventListener(e, "animationend", this.onAnimationEnd),
                (this.animationEndEventHandled = !0));
            },
            actions: {
              onHover: function () {
                this.get("disabled") ||
                  a.default.playSound(
                    o.SFX_CHANNEL,
                    `${o.SOUNDS_PATH}/sfx-uikit-grid-hover.ogg`,
                  );
              },
              toggleFlyout: function () {
                this.get("disabled") ||
                  this.get("temporarilyDisabled") ||
                  (this.set("animateButton", !0), this.toggleFlyout(this));
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "Co6+sx0/",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-trigger-button\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-trigger-button\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\flyout-selector-trigger-button\\\\index.js\\" "],["text","\\n"],["open-element","img",[]],["dynamic-attr","src",["concat",[["unknown",["selectedItem","iconPath"]]]]],["static-attr","class","selection-button-image"],["dynamic-attr","style",["unknown",["imageStyle"]],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"toggleFlyout"],null],null],["dynamic-attr","onmouseover",["helper",["action"],[["get",[null]],"onHover"],null],null],["flush-element"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","animated-border-overlay"],["flush-element"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","animated-gradient-overlay"],["flush-element"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0),
          n(245);
        const s = n(1),
          { Ember: i, EmberAddons: o } = s,
          { RunMixin: a } = o.EmberLifeline,
          { gsap: r } = s;
        var l = i.Component.extend(a, {
          classNames: ["game-event-info-card"],
          layout: n(246),
          animationTimeline: null,
          didInsertElement: function () {
            const e = this.get("element"),
              t = e.querySelector(".game-event-info-card-icon-subtext"),
              n = e.querySelector(".game-event-info-card-left"),
              s = e.querySelector(".game-event-info-card-icon"),
              i = e.querySelector(".game-event-info-card-title"),
              o = e.querySelector(".game-event-info-card-description");
            this.animationTimeline ||
              ((this.animationTimeline = new r.TimelineMax({ paused: !0 })),
              this.animationTimeline
                .to(e, 1, { x: 0, ease: r.Power3.easeInOut })
                .to(t, 0.3, { autoAlpha: 0, ease: r.Power3.easeOut }, "-=0.8")
                .to(s, 0.3, { autoAlpha: 0, ease: r.Power3.easeOut }, "-=0.8")
                .to(n, 0.3, { autoAlpha: 1, ease: r.Power3.easeOut }, "-=0.3")
                .to(s, 0.3, { autoAlpha: 1, ease: r.Power3.easeOut }, "-=0.3")
                .to(
                  i,
                  0.2,
                  { autoAlpha: 1, x: 0, ease: r.Power3.easeOut },
                  "-=0.25",
                )
                .to(
                  o,
                  0.2,
                  { autoAlpha: 1, x: 0, ease: r.Power3.easeOut },
                  "-=0.2",
                ));
          },
          didUpdateAttrs: function () {
            this._super(...arguments);
            const e = this.get("oldShiftedToSide"),
              t = this.get("shiftedToSide");
            e !== t &&
              this.runTask(function () {
                this.shiftElement(!this.get("shiftedToSide"));
              }, 0),
              this.set("oldShiftedToSide", t);
          },
          title: i.computed(
            "map.categorizedContentBundles.GameEventInfoCards",
            "eventIndex",
            function () {
              const e = this.get("eventIndex");
              return this.get(
                `map.categorizedContentBundles.GameEventInfoCards.${e}.header`,
              );
            },
          ),
          description: i.computed(
            "map.categorizedContentBundles.GameEventInfoCards",
            "eventIndex",
            function () {
              const e = this.get("eventIndex");
              return this.get(
                `map.categorizedContentBundles.GameEventInfoCards.${e}.body`,
              );
            },
          ),
          iconSubtext: i.computed(
            "map.categorizedContentBundles.GameEventInfoCards",
            function () {
              return this.get(
                "map.categorizedContentBundles.GameEventInfoCards.IconSubtext.header",
              );
            },
          ),
          iconSrc: i.computed(
            "map.categorizedContentBundles.GameEventInfoCards",
            "eventIndex",
            function () {
              const e = this.get("eventIndex");
              return this.get(
                `map.categorizedContentBundles.GameEventInfoCards.${e}.imagePath`,
              );
            },
          ),
          shiftElement: function (e) {
            e ? this.animationTimeline.pause(0) : this.animationTimeline.play();
          },
        });
        t.default = l;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "xcdRHkjg",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-event-info-card-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-event-info-card-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-event-info-card-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","game-event-info-card-left"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","game-event-info-card-title"],["flush-element"],["text","\\n    "],["append",["unknown",["title"]],false],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","game-event-info-card-description"],["flush-element"],["text","\\n    "],["append",["unknown",["description"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","game-event-info-card-right"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","game-event-info-card-icon"],["flush-element"],["text","\\n    "],["open-element","img",[]],["dynamic-attr","src",["unknown",["iconSrc"]],null],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","game-event-info-card-icon-subtext"],["flush-element"],["text","\\n    "],["append",["unknown",["iconSubtext"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        const s = n(1),
          { Ember: i } = s,
          o = {
            GAME_CFG_DRAFT_TOURNAMENT: "tournament_draft",
            GAME_CFG_PICK_RANDOM: "random",
            GAME_CFG_DRAFT_STD: "draft",
            GAME_CFG_PICK_BLIND: "blind",
            GAME_CFG_TEAM_BUILDER_BLIND: "blind",
            GAME_CFG_TEAM_BUILDER_DRAFT: "draft",
            GAME_CFG_COUNTER_PICK: "counter",
            GAME_CFG_PICK_SIMUL_TD: "simultaneous",
            GAME_CFG_PICK_SIMUL: "simultaneous",
            GAME_CFG_BLIND_DUPE: "all_for_one",
            GAME_CFG_BLIND_DRAFT_ST: "blind_draft",
            GAME_MUTATOR_OVERRIDE_SHOWDOWN: "showdown",
          };
        n(248),
          (e.exports = i.Component.extend({
            layout: n(249),
            classNameBindings: ["mutatorName::hidden"],
            teamSizeText: i.computed("teamSize", function () {
              return this.get("tra").formatString("map_size", {
                size: this.get("teamSize"),
              });
            }),
            pickModeText: i.computed("mutatorName", function () {
              const e = this.get("mutatorName");
              if (!e || !o[e]) return "";
              const t = "custom_game_mutator_type_" + o[e];
              return this.get("tra").formatString(t);
            }),
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "z61QklDd",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-info-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-info-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\game-info-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","team-size"],["flush-element"],["text","\\n  "],["append",["unknown",["teamSizeText"]],false],["text","\\n"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","pick-mode"],["flush-element"],["text","\\n  "],["append",["unknown",["pickModeText"]],false],["text","\\n"],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = a(n(150)),
          o = a(n(158));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        n(251);
        const r = "sfx-ui",
          l = i.default.createSound(
            r,
            "/fe/lol-champ-select/sounds/sfx-cs-draft-ban-button-hover.ogg",
          ),
          c = i.default.createSound(
            r,
            "/fe/lol-champ-select/sounds/sfx-cs-lockin-button-hover.ogg",
          ),
          u = [l, c],
          m = s.ViewportPlugin.fullScreen().getScreenRoot(
            "rcp-fe-lol-champ-select",
          );
        e.exports = s.Ember.Component.extend({
          classNames: ["lock-in"],
          classNameBindings: [
            "visible:visible:hidden",
            "summoner.isPickingNow:picking",
            "summoner.isVotingNow:picking",
            "summoner.isBanningNow:banning",
          ],
          layout: n(252),
          requestPending: !1,
          disabled: s.EmberHelpers.computedGate(
            "summoner.activeAction.championId",
            "requestPending",
            function () {
              if (
                !this.get("summoner.activeAction.championId") ||
                this.get("requestPending")
              )
                return !0;
            },
          ),
          shouldShowButtonText: s.Ember.computed.or(
            "summoner.isPickingOrVotingNow",
            "summoner.isBanningNow",
          ),
          buttonText: s.Ember.computed(
            "summoner.isPickingOrVotingNow",
            "summoner.isBanningNow",
            function () {
              return this.get("summoner.isPickingNow")
                ? this.get("tra.lock_in")
                : this.get("summoner.isVotingNow")
                  ? this.get("tra.vote_button")
                  : this.get("summoner.isBanningNow")
                    ? this.get("tra.ban_button")
                    : void 0;
            },
          ),
          mouseEnter: function () {
            !this.get("disabled") &&
              this.get("visible") &&
              (u.forEach(function (e) {
                e.stop().catch(function () {});
              }),
              this.get("summoner.isBanningNow") ? c.play() : l.play());
          },
          lockInCompletedObserver: s.Ember.observer(
            "summoner.isActingNow",
            function () {
              (!this._isRecordingLockInTime && !this._isRecordingBanTime) ||
                this.get("summoner.isActingNow") ||
                requestAnimationFrame(() => {
                  this.isDestroying ||
                    this.isDestroyed ||
                    (this._isRecordingBanTime
                      ? (s.Telemetry.endTracingEvent("champ-select-ban"),
                        (this._isRecordingBanTime = !1))
                      : this._isRecordingLockInTime &&
                        (s.Telemetry.endTracingEvent("champ-select-lock-in"),
                        (this._isRecordingLockInTime = !1)));
                });
            },
          ),
          sendLCUReqeust: function (e, t) {
            this.set("requestPending", !0);
            const n = this.get("summoner.isBanningNow");
            n
              ? (s.Telemetry.startTracingEvent("champ-select-ban"),
                (this._isRecordingBanTime = !0))
              : (s.Telemetry.startTracingEvent("champ-select-lock-in"),
                (this._isRecordingLockInTime = !0)),
              o.default
                .ajax({
                  type: "PATCH",
                  url: "/lol-champ-select/v1/session/actions/" + e.get("id"),
                  contentType: "application/json",
                  data: JSON.stringify({ completed: !0, championId: t }),
                  errorMessage: "error_could_not_lock_in",
                })
                .then(() => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0);
                })
                .catch((e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e);
                  const t = e && e.responseText ? e.responseText : "";
                  this._isRecordingLockInTime
                    ? (s.Telemetry.endTracingEvent("champ-select-lock-in"),
                      s.Telemetry.sendEvent("champ-select-lock-in-failure", t),
                      s.Telemetry.recordNonTimingTracingEvent(
                        "champ-select-lock-in-failure",
                        1,
                        "event",
                      ),
                      (this._isRecordingLockInTime = !1))
                    : this._isRecordingBanTime &&
                      (s.Telemetry.endTracingEvent("champ-select-ban"),
                      s.Telemetry.sendEvent("champ-select-ban-failure", t),
                      s.Telemetry.recordNonTimingTracingEvent(
                        "champ-select-ban-failure",
                        1,
                        "event",
                      ),
                      (this._isRecordingBanTime = !1));
                })
                .finally(
                  function () {
                    this.set("requestPending", !1);
                  }.bind(this),
                ),
              n
                ? i.default.playSound(
                    r,
                    "/fe/lol-champ-select/sounds/sfx-cs-draft-ban-button-click.ogg",
                  )
                : i.default.playSound(
                    r,
                    "/fe/lol-champ-select/sounds/sfx-cs-lockin-button-click.ogg",
                  );
          },
          summonerInfoService: s.Ember.inject.service("summoner-info"),
          buildBanIntentModal: function (e, t) {
            const n = s.UiKitPlugin.getModalManager(),
              i = s.UiKitPlugin.getTemplateHelper(),
              o = e.get("champion.selectedByMe"),
              a = o
                ? this.get("tra.ban_intent_modal_title_self")
                : this.get("tra.ban_intent_modal_title"),
              r = o
                ? this.get("tra.ban_intent_modal_description_self")
                : this.get("tra").formatString("ban_intent_modal_description", {
                    name: e.get("champion.selectedBy.displayName"),
                  }),
              l = n.add({
                type: "DialogConfirm",
                data: {
                  contents: i.contentBlockDialog(a, r),
                  acceptText: this.get("tra.ban_button"),
                  declineText: this.get("tra.ban_intent_modal_cancel_button"),
                  primaryButton: "accept",
                },
              });
            m.once("hide", () => {
              n.remove(l);
            });
            const c = () => {
              n.remove(l),
                this.removeObserver("summoner.isBanSniping", this, c);
            };
            this.addObserver("summoner.isBanSniping", this, c),
              l.acceptPromise
                .then(
                  () => {
                    this.sendLCUReqeust(e, t);
                    const n = this.get("summoner.summonerId"),
                      i = e.get("champion.selectedBy.summonerId");
                    let o, a;
                    this.get("summonerInfoService")
                      .getSummonerInfo(n)
                      .then(
                        (e) => (
                          (o = e.puuid),
                          this.get("summonerInfoService").getSummonerInfo(i)
                        ),
                      )
                      .then((e) => {
                        a = e.puuid;
                        const t = {
                          gameId: this.get("gameId"),
                          playerBanSniping: o,
                          playerBanSniped: a,
                        };
                        s.Telemetry.sendCustomData(
                          "champ-select-ban-intent-modal-confirm",
                          t,
                        );
                      });
                  },
                  () => {
                    s.Telemetry.sendEvent(
                      "champ-select-ban-intent-modal-cancel",
                    );
                  },
                )
                .finally(() => {
                  c();
                });
          },
          actions: {
            lockIn: function () {
              if (this.get("disabled")) return;
              const e = this.get("summoner.activeAction"),
                t = e.get("championId");
              this.get("summoner.isBanSniping")
                ? (s.Telemetry.sendEvent(
                    "champ-select-ban-intent-modal-generate",
                  ),
                  this.buildBanIntentModal(e, t))
                : this.sendLCUReqeust(e, t);
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "7a1le2hh",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\lock-in-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\lock-in-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\lock-in-button-component\\\\index.js\\" "],["text","\\n"],["block",["action-button"],null,[["disabled","click"],[["get",["disabled"]],"lockIn"]],0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["shouldShowButtonText"]],"visible","removed"],null]]]],["flush-element"],["text","\\n    "],["append",["unknown",["buttonText"]],false],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = n(212),
          o = n(155),
          a = n(152);
        n(254);
        const r = [11, 21];
        var l = s.Ember.Component.extend({
          layout: n(255),
          classNames: ["loadouts-edit-component"],
          init: function () {
            this._super(...arguments),
              this.retrieveRuneRecommenderTutorialSetting();
          },
          didUpdateAttrs: function () {
            this._super(...arguments),
              this.get("isPerkSelectionDisabled") && this.hidePerksModal();
          },
          willDestroyElement: function () {
            this._super(...arguments), this.hidePerksModal();
          },
          retrieveRuneRecommenderTutorialSetting: function () {
            return (0, i.getAccountSetting)(
              "runeRecommenderTutorialTipSeen",
            ).then((e) => {
              this.set("runeRecommenderTutorialTipSeen", e);
            });
          },
          showRuneRecommenderButton: s.Ember.computed.alias(
            "isRuneRecommenderEnabled",
          ),
          isRuneRecommenderButtonDisabled: s.Ember.computed(
            "champOrPickIntent",
            "isUILockedForGameStart",
            function () {
              return (
                !this.get("champOrPickIntent") ||
                this.get("isUILockedForGameStart")
              );
            },
          ),
          runeRecommenderButtonDisabledText: s.Ember.computed(
            "champOrPickIntent",
            function () {
              return this.get("champOrPickIntent")
                ? this.get("tra.perks_selection_disabled")
                : this.get(
                    "tra.rune_recommender_disabled_no_champion_selected",
                  );
            },
          ),
          showRuneRecommenderTutorialTooltip: s.Ember.computed(
            "isRuneRecommenderEnabled",
            "isPerkSelectionUnlocked",
            "champOrPickIntent",
            "runeRecommenderTutorialTipSeen",
            function () {
              const e = this.get("isPerkSelectionUnlocked"),
                t = this.get("isRuneRecommenderEnabled"),
                n = !!this.get("champOrPickIntent"),
                s = this.get("runeRecommenderTutorialTipSeen");
              return e && t && n && !s;
            },
          ),
          isPerkSelectionDisabled: s.Ember.computed.alias(
            "isUILockedForGameStart",
          ),
          showPerksSelectionControls: s.Ember.computed.and(
            "gameModeSupportsPerks",
            "isPerkSelectionUnlocked",
          ),
          isPerkSelectionUnlocked: s.Ember.computed(
            "localSummonerLevel",
            "unlockAllRunePageFunctionality",
            function () {
              const e = a.RUNES.minChooseRunesEnabledLevel,
                t = this.get("localSummonerLevel");
              return this.get("unlockAllRunePageFunctionality") || t >= e;
            },
          ),
          showWardSkinSelector: s.Ember.computed(
            "map.id",
            "jmxSettings.WardSkinConfig.WardSkinSelection",
            function () {
              const e = this.get(
                  "jmxSettings.WardSkinConfig.WardSkinSelection",
                ),
                t = parseInt(this.get("map.id"));
              return e && r.includes(t);
            },
          ),
          isWardSkinSelectionDisabled: s.Ember.computed(
            "isUILockedForGameStart",
            "currentSummoner.isDonePicking",
            function () {
              return (
                this.get("isUILockedForGameStart") ||
                !this.get("currentSummoner.isDonePicking")
              );
            },
          ),
          shouldShowEmoteButton: s.Ember.computed(
            "jmxSettings.LcuChampionSelect.ShowEmoteButton",
            "jmxSettings.Emotes.IsEmotePanelEnabled",
            function () {
              return (
                !!this.get("jmxSettings.LcuChampionSelect.ShowEmoteButton") &&
                !!this.get("jmxSettings.Emotes.IsEmotePanelEnabled")
              );
            },
          ),
          hidePerksModal() {
            (0, o.usePerksApi)((e) => e.hide()),
              this.isDestroyed ||
                this.isDestroying ||
                this.sendAction("showingPerksModalChanged", !1);
          },
          setRecommendedPage(e, t) {
            const [n, i] = t;
            return (0, s.DataBinding)("/lol-champ-select").patch(
              "v1/session/my-selection",
              { spell1Id: n, spell2Id: i },
            );
          },
          getRuneRecommenderContext() {
            const e =
                this.get("currentSummoner.assignedPosition") || a.POSITION_NONE,
              t = this.get("champOrPickIntent"),
              n = this.get("map.id") || 11,
              s = [
                this.get("currentSummoner.spell1Id"),
                this.get("currentSummoner.spell2Id"),
              ];
            return {
              position: e,
              champId: t,
              mapId: n,
              setRecommendedPage: this.setRecommendedPage.bind(this),
              spellIds: s,
            };
          },
          actions: {
            acknowledgeTutorialTooltip(e) {
              return (0, i.saveAccountSetting)(e, !0).then(() => {
                this.set("runeRecommenderTutorialTipSeen", !0);
              });
            },
            showPerksModal() {
              this._perksModalShownOnce ||
                ((this._perksModalShownOnce = !0),
                s.Telemetry.startTracingEvent("champ-select-runes-init"));
              const e = this.getRuneRecommenderContext(),
                t = this.get("currentPerksPage.id"),
                n = this.get("perksPages");
              let i = 0;
              if (Boolean(n) && n.length) {
                i = t;
                !n.find((e) => e.id === t) && n.length && (i = n[0].id);
              }
              (0, o.usePerksApi)((t) =>
                t.edit(i, !0, () => this.hidePerksModal(), e),
              ),
                this.sendAction("showingPerksModalChanged", !0);
            },
            showRuneRecommender: function () {
              const e = this.getRuneRecommenderContext();
              (0, o.usePerksApi)((t) =>
                t.runeRecommender(!0, () => this.hidePerksModal(), e),
              ),
                this.sendAction("showingPerksModalChanged", !0);
            },
          },
        });
        t.default = l;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "TZhSYMBx",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\loadouts-edit-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\loadouts-edit-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\loadouts-edit-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","loadout-edit-controls"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showPerksSelectionControls"]]],null,4],["close-element"],["text","\\n"],["append",["helper",["summoner-spell-select"],null,[["spells","spell1","spell2","disabled","uxSettings","queue","currentSummoner","timer","showPositionAssignment","assignedPosition","perPositionRequiredSummonerSpells","perPositionDisallowedSummonerSpells","recordDidRequestSucceed"],[["get",["availableSpells"]],["get",["currentSummoner","spell1"]],["get",["currentSummoner","spell2"]],["get",["isUILockedForGameStart"]],["get",["uxSettings"]],["get",["queue"]],["get",["currentSummoner"]],["get",["timer"]],["get",["showPositionAssignment"]],["get",["currentSummoner","assignedPosition"]],["get",["perPositionRequiredSummonerSpells"]],["get",["perPositionDisallowedSummonerSpells"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","loadoutsSpacer"],["flush-element"],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["showWardSkinSelector"]]],null,2,1],["open-element","div",[]],["dynamic-attr","class",["concat",["emotes-visibility-wrapper ",["helper",["if"],[["get",["shouldShowEmoteButton"]],"visible","removed"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["emotes-edit"],null,[["isDonePicking","lockedAtEndOfChampSelect","wardSkinsAvailable"],[["get",["currentSummoner","isDonePicking"]],["get",["isUILockedForGameStart"]],["get",["showWardSkinSelector"]]]]],false],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","lol-parties-cosmetics-picker",[]],["static-attr","type","companions"],["static-attr","set-name","default"],["static-attr","orientation","top"],["static-attr","show-none",""],["flush-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["if"],[["get",["isCompanionsEnabled"]]],null,0]],"locals":[]},{"statements":[["text","  "],["append",["helper",["ward-skin-select"],null,[["wardSkins","selectedWardSkin","disabled","isDonePicking","map","uxSettings","useLoadouts","accountLoadout","recordDidRequestSucceed"],[["get",["wardSkins"]],["get",["selectedWardSkin"]],["get",["isWardSkinSelectionDisabled"]],["get",["currentSummoner","isDonePicking"]],["get",["map"]],["get",["uxSettings"]],["get",["jmxSettings","WardSkinConfig","UseLoadouts"]],["get",["accountLoadout"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","        "],["append",["helper",["rune-recommender-button"],null,[["isDisabled","disabledTooltipText","handleClick","timedTooltipText","shouldShowTimedTooltip","acknowledgeTutorialTooltip"],[["get",["isRuneRecommenderButtonDisabled"]],["get",["runeRecommenderButtonDisabledText"]],"showRuneRecommender",["get",["tra","rune_recommender_tutorial_tooltip"]],["get",["showRuneRecommenderTutorialTooltip"]],["helper",["action"],[["get",[null]],"acknowledgeTutorialTooltip","runeRecommenderTutorialTipSeen"],null]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","div",[]],["static-attr","class","loadout-edit-controls-row"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showRuneRecommenderButton"]]],null,3],["text","      "],["append",["helper",["framed-icon-button"],null,[["disabled","iconPath","clickSfxPath","hoverSfxPath","onButtonClick"],[["get",["isPerkSelectionDisabled"]],"/fe/lol-champ-select/images/config/edit-perks-button.png","/fe/lol-champ-select/sounds/sfx-uikit-edit-click.ogg","/fe/lol-champ-select/sounds/sfx-uikit-grid-hover.ogg",["helper",["action"],[["get",[null]],"showPerksModal"],null]]]],false],["text","\\n      "],["open-element","div",[]],["static-attr","class","dropdowns"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","perks-dropdowns"],["flush-element"],["text","\\n          "],["append",["helper",["perks-page-dropdown"],null,[["perksPages","perksSettings","currentPerksPage","useRuneRecommenderAutoSelect","timer","isPerkSelectionUnlocked","showPerksSelectionControls","disabled","localSummonerLevel","tutorial","jmxSettings","recordDidRequestSucceed"],[["get",["perksPages"]],["get",["perksSettings"]],["get",["currentPerksPage"]],["get",["useRuneRecommenderAutoSelect"]],["get",["timer"]],["get",["isPerkSelectionUnlocked"]],["get",["showPerksSelectionControls"]],["get",["isPerkSelectionDisabled"]],["get",["localSummonerLevel"]],["get",["perksTutorialSettings"]],["get",["jmxSettings"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(152),
          o = (s = n(158)) && s.__esModule ? s : { default: s },
          a = n(155);
        const r = n(1),
          { DataBinding: l } = r,
          { Ember: c, EmberAddons: u } = r,
          { EmberHelpers: m } = r,
          { getProvider: d } = r,
          p = r.UiKitPlugin.getContextualNotificationManager(),
          h = r.ViewportPlugin.fullScreen().getScreenRoot(
            "rcp-fe-lol-champ-select",
          ),
          { RunMixin: g } = u.EmberLifeline,
          f = l("/lol-perks", d().getSocket());
        n(257),
          (e.exports = c.Component.extend(g, {
            layout: n(258),
            classNames: ["perks-page-dropdown-container"],
            classNameBindings: ["currentPerksPageInvalid"],
            shouldShowDropdownHighlight: !1,
            tutorialTooltipShown: !1,
            tutorial: {},
            sortedPages: c.computed(
              "perksPages.[]",
              "perksPages.@each.order",
              function () {
                const e = this.get("perksPages");
                return e ? e.sortBy("order") : null;
              },
            ),
            hasCustomPages: c.computed(
              "perksPages.@each.isPresetPage",
              function () {
                return this.get("perksPages").any(
                  (e) => !e.get("isPresetPage"),
                );
              },
            ),
            hasPages: c.computed.gte("perksPages.length", 1),
            showPresetPages: c.computed(
              "perksSettings.showPresetPages",
              "hasCustomPages",
              function () {
                const e = this.get("perksSettings.showPresetPages");
                return !this.get("hasCustomPages") || (null !== e && !1 !== e);
              },
            ),
            init: function () {
              this._super(...arguments),
                this.set("_screenRootHideHandler", () => {
                  this.get("tutorialTooltipNotification") &&
                    p.remove(this.get("tutorialTooltipNotification")),
                    this.set("tutorialTooltipShown", !1),
                    this.set("shouldShowDropdownHighlight", !1),
                    this.dropdownHighlightTimer &&
                      this.cancelTask(this.dropdownHighlightTimer);
                }),
                h.on("hide", this.get("_screenRootHideHandler"));
            },
            willDestroyElement: function () {
              this._super(...arguments),
                h.off("hide", this.get("_screenRootHideHandler"));
            },
            runesTutorialSeenCount: c.computed(
              "tutorial.data.championSelectRunesTooltipSeenCount",
              function () {
                return (
                  this.get(
                    "tutorial.data.championSelectRunesTooltipSeenCount",
                  ) || 0
                );
              },
            ),
            tutorialTooltip: c.computed(
              "runesTutorialSeenCount",
              "localSummonerLevel",
              function () {
                return this.get("runesTutorialSeenCount") >=
                  i.RUNES.maxTutorialHighlightSeenCount
                  ? null
                  : this.get("localSummonerLevel") ===
                      i.RUNES.minChooseRunesEnabledLevel
                    ? "runes_newly_unlocked_tooltip"
                    : "runes_existing_player_tutorial_tooltip";
              },
            ),
            setTooltipSeenCount: function (e) {
              c.$.ajax({
                url: "/lol-settings/v1/account/lol-tutorial",
                data: JSON.stringify({
                  data: { championSelectRunesTooltipSeenCount: e },
                  schemaVersion: 1,
                }),
                contentType: "application/json",
                type: "PATCH",
              });
            },
            displayRuneSwapNotification: function () {
              if (this.isDestroying || this.isDestroyed) return;
              const e = r.UiKitPlugin.getTemplateHelper();
              (0, a.usePerksApi)((t) => {
                const n = t.getRuneSwapAndNotifyString(),
                  s = e.contentBlockNotification(
                    n,
                    "champ-select-runes-tutorial-tooltip",
                  ),
                  i = p.add(s, {
                    target: {
                      domNode: this.element,
                      anchor: { x: "center", y: "top" },
                    },
                    orientation: "top",
                    anchor: { x: "center", y: "bottom" },
                    offset: { y: -18 },
                    dismissOnTargetHide: !0,
                  });
                i.onRemove.then(() => {
                  this.set("runeSwapNotification", null),
                    f.post("/v1/show-auto-modified-pages-notification", {});
                }),
                  this.set("runeSwapNotification", i);
              });
            },
            displayTutorialTooltipNotification: function (e) {
              if (
                this.isDestroying ||
                this.isDestroyed ||
                !this.element.offsetWidth
              )
                return;
              const t =
                  r.UiKitPlugin.getTemplateHelper().contentBlockNotification(
                    this.get("tra." + e),
                    "champ-select-runes-tutorial-tooltip",
                  ),
                n = p.add(t, {
                  target: {
                    domNode: this.element,
                    anchor: { x: "center", y: "top" },
                  },
                  orientation: "top",
                  anchor: { x: "center", y: "bottom" },
                  offset: { y: -18 },
                });
              this.set("tutorialTooltipNotification", n),
                n.onCloseButtonClick.then(() => {
                  this.set("shouldShowDropdownHighlight", !1),
                    this.setTooltipSeenCount(
                      this.get("runesTutorialSeenCount") +
                        i.RUNES.tutorialHighlightActionSeenCountIncrement,
                    );
                }),
                n.onRemove.then(() => {
                  this.set("tutorialTooltipNotification", null);
                });
            },
            shouldShowPerksTutorial: c.computed(
              "jmxSettings.Perks.TutorialPopupsEnabled",
              "runesTutorialSeenCount",
              function () {
                const e = this.get("jmxSettings.Perks.TutorialPopupsEnabled"),
                  t = this.get("runesTutorialSeenCount");
                return (null == e || e) && 0 === t;
              },
            ),
            restrictedPageNamesEnabled: c.computed.alias(
              "jmxSettings.Perks.RestrictedPageNamesEnabled",
            ),
            pageRenamingDisabled: c.computed.alias(
              "jmxSettings.Perks.PageRenamingDisabled",
            ),
            checkShouldShowNotifications: m.observer(
              "timer.inBanPickPhase",
              "timer.inFinalizationPhase",
              function () {
                if (
                  this.get("showPerksSelectionControls") &&
                  (this.get("timer.inBanPickPhase") ||
                    this.get("timer.inFinalizationPhase"))
                ) {
                  l("/lol-perks")
                    .get("/v1/show-auto-modified-pages-notification")
                    .then((e) => {
                      e &&
                        this.runTask(() => {
                          this.displayRuneSwapNotification();
                        }, 1e3);
                    });
                  const e = this.get("tutorialTooltip");
                  if (!this.get("tutorialTooltipShown") && e) {
                    this.set("tutorialTooltipShown", !0);
                    const t = this.get("runesTutorialSeenCount"),
                      n = this.get("shouldShowPerksTutorial");
                    (this.dropdownHighlightTimer = this.runTask(() => {
                      0 === this.$("lol-uikit-framed-dropdown.active").length &&
                        (this.set("shouldShowDropdownHighlight", !0),
                        n && this.displayTutorialTooltipNotification(e));
                    }, i.RUNES.tutorialHighlightDelay)),
                      this.setTooltipSeenCount(t + 1);
                  }
                }
              },
            ),
            selectedPageId: c.computed(
              "currentPerksPage.id",
              "useRuneRecommenderAutoSelect",
              function () {
                return this.get("useRuneRecommenderAutoSelect")
                  ? 1
                  : this.get("currentPerksPage.id");
              },
            ),
            currentPerksPageInvalid: c.computed.not("currentPerksPage.isValid"),
            haveRuneRecommenderPage: c.computed(
              "perksPages.@each.isTemporary",
              function () {
                return !!(this.get("perksPages") || []).find(
                  (e) => e.isTemporary,
                );
              },
            ),
            actions: {
              dropdownClicked: function () {
                this.get("shouldShowDropdownHighlight") &&
                  (this.set("shouldShowDropdownHighlight", !1),
                  this.setTooltipSeenCount(
                    this.get("runesTutorialSeenCount") +
                      i.RUNES.tutorialHighlightActionSeenCountIncrement,
                  )),
                  this.get("runeSwapNotification") &&
                    p.remove(this.get("runeSwapNotification")),
                  this.get("tutorialTooltipNotification") &&
                    p.remove(this.get("tutorialTooltipNotification"));
              },
              setRuneRecommenderAutoSelect: function () {
                return l("/lol-perks").post("/v1/rune-recommender-auto-select");
              },
              selectPage: function (e) {
                o.default
                  .ajax({
                    url: "/lol-perks/v1/currentpage",
                    contentType: "application/json",
                    data: JSON.stringify(e.get("id")),
                    dataType: "text",
                    method: "PUT",
                    errorMessage: "error_could_not_set_perks_page",
                  })
                  .then(() => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!0);
                  })
                  .catch((e) => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!1, e),
                      this.isDestroying ||
                        this.isDestroyed ||
                        (this.set("setSelectedError", !0),
                        this.set("parentComponent.requestInProgress", !0));
                  });
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "x+oPPWPY",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-component\\\\index.js\\" "],["text","\\n"],["open-element","lol-uikit-framed-dropdown",[]],["static-attr","stylablecontent",""],["static-attr","direction","upward"],["dynamic-attr","disabled",["unknown",["disabled"]],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"dropdownClicked"],null],null],["static-attr","class","perks-page-dropdown"],["flush-element"],["text","\\n"],["block",["unless"],[["get",["haveRuneRecommenderPage"]]],null,2],["text","  \\n"],["block",["each"],[["get",["sortedPages"]]],[["key"],["id"]],1],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["shouldShowDropdownHighlight"]]],null,0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","framed-highlight-overlay"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","framed-highlight-overlay-shadow"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","framed-highlight-overlay-border"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","framed-highlight-overlay-background"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["append",["helper",["perks-page-dropdown-option"],null,[["showPresetPages","page","currentPageId","index","restrictedPageNamesEnabled","pageRenamingDisabled","click"],[["get",["showPresetPages"]],["get",["page"]],["get",["selectedPageId"]],["get",["index"]],["get",["restrictedPageNamesEnabled"]],["get",["pageRenamingDisabled"]],["helper",["action"],[["get",[null]],"selectPage",["get",["page"]]],null]]]],false],["text","\\n"]],"locals":["page","index"]},{"statements":[["text","    "],["open-element","lol-uikit-dropdown-option",[]],["static-attr","slot","lol-uikit-dropdown-option"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"setRuneRecommenderAutoSelect"],null],null],["dynamic-attr","selected",["unknown",["useRuneRecommenderAutoSelect"]],null],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","perks-page-dropdown-option-content"],["flush-element"],["text","\\n        "],["append",["unknown",["tra","rune_recommender_auto_select_option"]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        const s = n(1),
          { Ember: i } = s;
        n(260);
        e.exports = i.Component.extend({
          layout: n(261),
          tagName: "lol-uikit-dropdown-option",
          classNames: ["perks-page-dropdown-option"],
          attributeBindings: ["isSelected:selected", "tagName:slot"],
          classNameBindings: ["isHidden:removed"],
          currentPageId: -1,
          tooltipConfig: {
            targetAnchor: { x: "right", y: "center" },
            tooltipAnchor: { x: "left", y: "center" },
            showDelay: 175,
          },
          index: 0,
          restrictedPageNamesEnabled: !1,
          pageRenamingDisabled: !1,
          isCustomPage: i.computed.alias("page.isEditable"),
          defaultCustomPageName: i.computed("tra", "index", function () {
            return this.get("tra").formatString(
              "runes_default_custom_page_name",
              { count: this.get("index") + 1 },
            );
          }),
          pageName: i.computed(
            "restrictedPageNamesEnabled",
            "pageRenamingDisabled",
            "isCustomPage",
            "defaultCustomPageName",
            "page.name",
            function () {
              return this.get("restrictedPageNamesEnabled") &&
                this.get("pageRenamingDisabled") &&
                this.get("isCustomPage")
                ? this.get("defaultCustomPageName")
                : this.get("page.name");
            },
          ),
          isSelected: i.computed("page.id", "currentPageId", function () {
            const e = this.get("page.id"),
              t = this.get("currentPageId");
            return t > 0 && e === t ? "true" : null;
          }),
          isHidden: i.computed(
            "showPresetPages",
            "isSelected",
            "page.isPresetPage",
            function () {
              const e = this.get("showPresetPages"),
                t = this.get("isSelected"),
                n = this.get("page.isPresetPage");
              return !t && n && !e;
            },
          ),
          iconClassName: i.computed(
            "page.isValid",
            "page.isTemporary",
            "page.autoModifiedSelections.length",
            function () {
              return this.get("page.isValid")
                ? this.get("page.isTemporary")
                  ? "recommended-page"
                  : this.get("page.autoModifiedSelections.length")
                    ? "modified"
                    : "removed"
                : "invalid";
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "c9gkch0v",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-option-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-option-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\perks-page-dropdown-option-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","perks-page-dropdown-option-content"],["flush-element"],["text","\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["perks-page-dropdown-option-icon ",["unknown",["iconClassName"]]]]],["flush-element"],["text","\\n    "],["open-element","lol-perks-glowing-dot",[]],["static-attr","class","perks-page-dropdown-option-dot"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","class","perks-page-name"],["flush-element"],["text","\\n    "],["append",["unknown",["pageName"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipConfig"],[["get",["tooltipConfig"]]]],0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["append",["helper",["perk-page-tooltip"],null,[["page"],[["get",["page"]]]]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s };
        n(263);
        const o = n(1),
          { Ember: a, EmberAddons: r } = o,
          { DomMixin: l } = r.EmberLifeline;
        e.exports = a.Component.extend(l, {
          classNames: ["phase-transition"],
          classNameBindings: ["visible:visible:removed"],
          layout: n(264),
          phaseTransitionLabel: a.computed(
            "ceremonyStringSuffix",
            "tra.phase_transition_finalization",
            "tra.phase_transition_one_ban_phase",
            "tra.phase_transition_one_pick_phase",
            "tra.phase_transition_one_vote_phase",
            "tra.phase_transition_ban_1",
            "tra.phase_transition_ban_2",
            "tra.phase_transition_pick_1",
            "tra.phase_transition_pick_2",
            function () {
              const e = `tra.phase_transition_${this.get("ceremonyStringSuffix")}`;
              return this.get(e);
            },
          ),
          ceremonyStringSuffix: a.computed(
            "phaseTransitionStringsByActionId",
            "activeAction.id",
            function () {
              const e = this.get("phaseTransitionStringsByActionId");
              return e ? e[this.get("activeAction.id")] : "";
            },
          ),
          playPhaseTransitionTextAudio: function (e) {
            "scaleDownTextIntro" === e.animationName &&
              i.default.playSound(
                "sfx-notifications",
                "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-team-bans-locked.ogg",
              );
          },
          didInsertElement: function () {
            this._super(...arguments),
              this.addEventListener(
                this.element,
                "animationstart",
                this.playPhaseTransitionTextAudio,
              );
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "qWneanv3",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\phase-transition-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\phase-transition-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\phase-transition-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","phase-transition-label"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","phase-transition-text"],["flush-element"],["text","\\n    "],["append",["unknown",["phaseTransitionLabel"]],false],["text","\\n    "],["open-element","div",[]],["static-attr","class","phase-transition-text-glow"],["flush-element"],["text","\\n      "],["append",["unknown",["phaseTransitionLabel"]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s },
          o = n(221),
          a = n(152);
        n(266);
        const r = n(1),
          { Ember: l, EmberAddons: c } = r,
          { EmberHelpers: u } = r,
          { RunMixin: m } = c.EmberLifeline;
        e.exports = l.Component.extend(m, {
          classNames: ["pick-ban-ring"],
          classNameBindings: [
            "champSelectScreen",
            "isInit:is-init:is-waiting",
            "isAnimating:is-animating:is-pending",
            "isTeamBan:is-player-team:is-enemy-team",
            "shouldShowExpandedRing:expanded-ring",
            "largeAreaAnimationsEnabled:large-area-animations-enabled:large-area-animations-disabled",
          ],
          layout: n(267),
          isAnimating: l.computed.equal(
            "banSlashAnimationState",
            o.ANIMATION_STATES.STARTED,
          ),
          banSlashAnimating: !1,
          isInit: !1,
          isTeamBan: l.computed.alias(
            "sessionActions.lastCompletedBanAction.actor.isOnLeftSide",
          ),
          slashRotationDegrees: 0,
          animationDispatcher: l.inject.service("animation-dispatcher"),
          banSlashAnimationState: l.computed.alias(
            "animationDispatcher.states.banSlashAnimation",
          ),
          banRotationAnimationState: l.computed.alias(
            "animationDispatcher.states.banRotationAnimation",
          ),
          largeAreaAnimationsEnabled: l.computed.equal(
            "uxSettings.largeAreaAnimationsEnabled",
            !0,
          ),
          isShowingSelectedScreen: l.computed.equal(
            "champSelectScreen",
            a.SCREENS.selected,
          ),
          listenForStateMachineState: u.observer(
            "largeAreaAnimationsEnabled",
            l.on("didInsertElement", function () {
              if (
                this.get("largeAreaAnimationsEnabled") &&
                !this.slashStateMachineListenerAttached
              ) {
                const e = this.element.querySelector(
                  ".ban-slash-state-machine",
                );
                e &&
                  e.subscribeParameterChanged &&
                  ((this.handleStateMachineAttributeChange = function (
                    e,
                    t,
                    n,
                  ) {
                    "state" !== e ||
                      "done" !== n ||
                      !this.get("banSlashAnimating") ||
                      this.isDestroying ||
                      this.isDestroyed ||
                      this.banAnimationComplete();
                  }.bind(this)),
                  (this.slashStateMachineListenerAttached = !0),
                  e.subscribeParameterChanged(
                    this.handleStateMachineAttributeChange,
                  ));
              }
            }),
          ),
          activeActionType: l.computed.alias("activeAction.type"),
          activeActionTypeChanged: u.observeChange(
            "activeActionType",
            function (e) {
              const t = this.get("sessionActions.banActions.firstObject");
              this.get("activeAction.id") === (t && t.get("id"))
                ? (this.get("isSimultaneousBans") ||
                    i.default.playSound(
                      "sfx-ui",
                      "/fe/lol-champ-select/sounds/sfx-cs-draft-ban-ring-intro.ogg",
                    ),
                  this.runTask(function () {
                    this.set("isInit", !0);
                  }, 400))
                : void 0 === e
                  ? this.set("isInit", !1)
                  : "pick" === e && this.set("isInit", !0);
            },
          ),
          actionsToPointTo: l.computed(
            "allPlayersActTogether",
            "activeAction.actor.isSelf",
            "activeAction",
            "activeActions.[]",
            function () {
              return this.get("allPlayersActTogether")
                ? this.get("activeAction.actor.isSelf")
                  ? l.A([this.get("activeAction")])
                  : l.A()
                : this.get("activeActions");
            },
          ),
          hideCurrentActionPointer: u.computedGate(
            "activeAction.actor.isSelf",
            "isPlayingCeremony",
            "allPlayersActTogether",
            function () {
              return (
                (this.get("allPlayersActTogether") &&
                  !this.get("activeAction.actor.isSelf")) ||
                this.get("isPlayingCeremony")
              );
            },
          ),
          hideNextActionPointer: u.computedGate(
            "allPlayersActTogether",
            "isPlayingCeremony",
            function () {
              return (
                this.get("allPlayersActTogether") ||
                this.get("isPlayingCeremony")
              );
            },
          ),
          playBanSlashAnimation: u.observeChange(
            "banSlashAnimationState",
            function () {
              this.get("banSlashAnimationState") === o.ANIMATION_STATES.STARTED
                ? this.runTask(function () {
                    this.set("banSlashAnimating", !0);
                  }, 400)
                : (this.set("banSlashAnimating", !1),
                  this.set("slashRotationDegrees", 0));
            },
          ),
          banAnimationComplete: function () {
            this.get("animationDispatcher").stopAnimation("banSlashAnimation");
          },
          slashRingRotation: l.computed("slashRotationDegrees", function () {
            return (
              "transform: rotate(" + this.get("slashRotationDegrees") + "deg);"
            );
          }),
          startRotationAnimation: u.observeChange(
            "banRotationAnimationState",
            function () {
              this.get("banRotationAnimationState") ===
                o.ANIMATION_STATES.STARTED &&
                this.setRotation("slashRotationDegrees");
            },
          ),
          setRotation: function (e) {
            let t = this.get(e);
            (t += this.get("isTeamBan") ? 45 : -45), this.set(e, t);
          },
          animatedActiveActions: u.delayed("actionsToPointTo", 800),
          animatedNextActions: u.delayed("nextActions", 800),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "BWCVlj3v",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-ban-ring-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-ban-ring-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-ban-ring-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","ring-inner-mask"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ring-inner-container"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","ring-gear-component-container"],["flush-element"],["text","\\n      "],["append",["helper",["ring-gear"],null,[["lastCompletedBanAction","activeAction","shouldShowExpandedRing","uxSettings"],[["get",["sessionActions","lastCompletedBanAction"]],["get",["animatedActiveAction"]],["get",["shouldShowExpandedRing"]],["get",["uxSettings"]]]]],false],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["dynamic-attr","style",["unknown",["slashRingRotation"]],null],["dynamic-attr","class",["concat",["ban-slash-wrapper ",["helper",["if"],[["get",["isShowingSelectedScreen"]],"removed"],null]]]],["flush-element"],["text","\\n      "],["open-element","uikit-state-machine",[]],["static-attr","class","ban-slash-state-machine"],["static-attr","state","unloaded"],["dynamic-attr","animation-team",["helper",["if"],[["get",["isTeamBan"]],"player-team","enemy-team"],null],null],["dynamic-attr","is-visible",["helper",["if"],[["get",["banSlashAnimating"]],"visible","hidden"],null],null],["dynamic-attr","style",["unknown",["slashRingRotation"]],null],["flush-element"],["text","\\n        "],["open-element","uikit-states",[]],["flush-element"],["text","\\n          "],["open-element","uikit-state",[]],["static-attr","name","unloaded"],["flush-element"],["text","\\n            "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".slash-video.red"],["static-attr","preloading",""],["flush-element"],["close-element"],["text","\\n            "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".slash-video.blue"],["static-attr","preloading",""],["flush-element"],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","blue-ban-video"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-media",[]],["static-attr","selector",".blue-ban-video"],["static-attr","can-play",""],["flush-element"],["close-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","is-visible"],["static-attr","value","visible"],["flush-element"],["close-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","animation-team"],["static-attr","value","player-team"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","red-ban-video"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-media",[]],["static-attr","selector",".red-ban-video"],["static-attr","can-play",""],["flush-element"],["close-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","is-visible"],["static-attr","value","visible"],["flush-element"],["close-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","animation-team"],["static-attr","value","enemy-team"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n\\n          "],["open-element","uikit-state",[]],["static-attr","name","blue-ban-video"],["flush-element"],["text","\\n            "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".blue-ban-video"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","done"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-media",[]],["static-attr","selector",".blue-ban-video"],["static-attr","ended",""],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","unloaded"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","is-visible"],["static-attr","value","hidden"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n\\n          "],["open-element","uikit-state",[]],["static-attr","name","red-ban-video"],["flush-element"],["text","\\n            "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".red-ban-video"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","done"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-media",[]],["static-attr","selector",".red-ban-video"],["static-attr","ended",""],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","unloaded"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","is-visible"],["static-attr","value","hidden"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n\\n          "],["open-element","uikit-state",[]],["static-attr","name","done"],["flush-element"],["text","\\n            "],["open-element","uikit-transition",[]],["static-attr","next-state","unloaded"],["flush-element"],["text","\\n              "],["open-element","uikit-condition-parameter",[]],["static-attr","name","is-visible"],["static-attr","value","hidden"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n\\n        "],["open-element","user-experience-perf-switch",[]],["static-attr","class","blue-ban-video"],["static-attr","visible-state","blue-ban-video"],["static-attr","default-visibility","hidden"],["flush-element"],["text","\\n          "],["open-element","uikit-video",[]],["static-attr","src","/fe/lol-champ-select/video/champion-ring/ban-circle-slash-blue.webm"],["static-attr","cache-name","rcp-fe-lol-champ-select"],["static-attr","class","slash-video blue"],["static-attr","perf-flags","largeAreaAnimationsEnabled"],["flush-element"],["close-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","hidden"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n        "],["open-element","user-experience-perf-switch",[]],["static-attr","visible-state","red-ban-video"],["static-attr","default-visibility","hidden"],["static-attr","class","red-ban-video"],["flush-element"],["text","\\n          "],["open-element","uikit-video",[]],["static-attr","src","/fe/lol-champ-select/video/champion-ring/ban-circle-slash-red.webm"],["static-attr","cache-name","rcp-fe-lol-champ-select"],["static-attr","class","slash-video red"],["static-attr","perf-flags","largeAreaAnimationsEnabled"],["flush-element"],["close-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","hidden"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        n(269);
        const i = n(1),
          { Ember: o, EmberAddons: a } = i,
          { EmberHelpers: r } = i,
          { RunMixin: l } = a.EmberLifeline,
          c = "/fe/lol-champ-select/sounds";
        e.exports = o.Component.extend(l, {
          classNames: ["pick-phase"],
          classNameBindings: [
            "shouldShow:pick-phase-visible:pick-phase-hidden",
            "shouldShowGrid:champion-grid-visible:champion-grid-hidden",
          ],
          layout: n(270),
          gridRequested: void 0,
          shouldShowExpandedRing: o.computed.or(
            "shouldShowGrid",
            "shouldShowBanShowcase",
            "isPlayingCeremony",
            "showVoteShowcase",
          ),
          myTeamSize: o.computed.readOnly("myTeam.length"),
          theirTeamSize: o.computed.readOnly("theirTeam.length"),
          isRGM: o.computed.alias("map.isRGM"),
          largeAreaAnimationsEnabled: o.computed.equal(
            "uxSettings.largeAreaAnimationsEnabled",
            !0,
          ),
          selectedChampSplash: o.computed(
            "sessionActions.activeAction.champion",
            "sessionActions.activeAction.champion.skins.firstObject.splashPath",
            function () {
              const e = this.get("sessionActions.activeAction.champion");
              return e ? e.get("skins.firstObject.splashPath") : null;
            },
          ),
          inSelectedScreen: o.computed.equal(
            "champSelectScreen",
            s.SCREENS.selected,
          ),
          notInSelectedScreen: o.computed.not("inSelectedScreen"),
          lastActionNotVote: o.computed.not(
            "sessionActions.lastCompletedAction.isVote",
          ),
          shouldShowLockedName: o.computed.and(
            "actionWasJustCompleted",
            "notShowingGrid",
            "notInSelectedScreen",
            "notShowingBanShowcase",
            "lastActionNotVote",
          ),
          shouldShowLockedSplash: o.computed.and(
            "shouldShowLockedName",
            "sessionActions.lastCompletedAction.isPick",
          ),
          lockedInSplash: o.computed(
            "shouldShowLockedSplash",
            "sessionActions.lastCompletedAction.champion.skins.firstObject.splashPath",
            function () {
              return this.get("shouldShowLockedSplash")
                ? this.get(
                    "sessionActions.lastCompletedAction.champion.skins.firstObject.splashPath",
                  )
                : null;
            },
          ),
          currentBackground: o.computed(
            "selectedChampSplash",
            "lockedInSplash",
            "shouldShowSplashBackground",
            "summoner.isPickingNow",
            function () {
              if (this.get("shouldShowSplashBackground")) {
                const e = this.get("lockedInSplash");
                if (e) return e;
                if (this.get("summoner.isPickingNow")) {
                  const e = this.get("selectedChampSplash");
                  if (e) return e;
                }
              }
              return null;
            },
          ),
          shouldShowSplashBackground: o.computed(
            "largeAreaAnimationsEnabled",
            "summoner.isActingNow",
            "notShowingGrid",
            "shouldShowBanShowcase",
            function () {
              return (
                (!this.get("shouldShowBanShowcase") ||
                  this.get("summoner.isActingNow")) &&
                (this.get("largeAreaAnimationsEnabled") ||
                  this.get("notShowingGrid"))
              );
            },
          ),
          shouldShowChampionName: o.computed(
            "shouldShowLockedSplash",
            "notShowingGrid",
            "sessionActions.lastCompletedAction.isBan",
            "shouldShowBanShowcase",
            function () {
              return (
                this.get("shouldShowLockedSplash") ||
                (this.get("notShowingGrid") &&
                  this.get("sessionActions.lastCompletedAction.isBan") &&
                  !this.get("shouldShowBanShowcase"))
              );
            },
          ),
          shouldShowGrid: o.computed(
            "shouldShow",
            "summoner.isActingNow",
            "sessionActions.isSimultaneousBans",
            "isPlayingCeremony",
            "waitingForBanAnimation",
            "gridRequested",
            "timer.inPlanningPhase",
            "timer.inFinalizationPhase",
            function () {
              const e = !this.get("timer.inFinalizationPhase");
              if (!this.get("shouldShow") && e) return !0;
              const t = this.get("summoner.isActingNow"),
                n = this.get("sessionActions.isSimultaneousBans"),
                s = this.get("isPlayingCeremony"),
                i = this.get("waitingForBanAnimation"),
                o = this.get("gridRequested"),
                a = this.get("timer.inPlanningPhase");
              return (
                (t && !s && !i) || (t && n) || (!1 !== o && a) || (!!o && e)
              );
            },
          ),
          notShowingGrid: o.computed.not("shouldShowGrid"),
          shouldShowBanShowcase: o.computed.equal(
            "champSelectScreen",
            s.SCREENS.banShowcase,
          ),
          notShowingBanShowcase: o.computed.not("shouldShowBanShowcase"),
          shouldShowPhaseTransition: o.computed(
            "sessionActions.activeAction.isPhaseTransition",
            "waitingForBanAnimation",
            "waitingForPickAnimation",
            "champSelectScreen",
            function () {
              return (
                this.get("sessionActions.activeAction.isPhaseTransition") &&
                !this.get("waitingForBanAnimation") &&
                !this.get("waitingForPickAnimation") &&
                (this.get("champSelectScreen") !== s.SCREENS.selected ||
                  this.get("sessionActions.activeAction.isVoteTransition"))
              );
            },
          ),
          dispatchLockinEvent: r.observeChange(
            "shouldShowLockedSplash",
            function () {
              const e = this.get("shouldShowLockedSplash")
                ? this.get(
                    "sessionActions.lastCompletedAction.actor.isOnLeftSide",
                  )
                  ? "left"
                  : "right"
                : null;
              this.get("updatePickJustLockedIn")(e);
            },
          ),
          dispatchGridEvent: r.observeChange("shouldShowGrid", function () {
            this.get("updateIsShowingGrid")(this.get("shouldShowGrid"));
          }),
          shouldShowLockIn: r.computedGate.immediate(
            "summoner.isActingNow",
            "shouldShowGrid",
            function () {
              return (
                this.get("summoner.isActingNow") && this.get("shouldShowGrid")
              );
            },
          ),
          notShowingLockIn: o.computed.not("shouldShowLockIn"),
          isNotSpectating: o.computed.not("isSpectating"),
          shouldShowFooter: o.computed.and(
            "shouldShowGrid",
            "notShowingLockIn",
            "isNotSpectating",
          ),
          shouldShow: r.computedGate.immediate(
            "champSelectScreen",
            "timer.inFinalizationPhase",
            function () {
              const e = this.get("champSelectScreen");
              return (
                e === s.SCREENS.pick ||
                e === s.SCREENS.banShowcase ||
                (e === s.SCREENS.selected &&
                  !this.get("timer.inFinalizationPhase"))
              );
            },
          ),
          gridIsToggleable: o.computed(
            "summoner.isActingNow",
            "timer.inFinalizationPhase",
            "isPlayingCeremony",
            "isNotSpectating",
            "transitioningToSelectedScreen",
            "showVoteShowcase",
            function () {
              return (
                !this.get("summoner.isActingNow") &&
                !this.get("timer.inFinalizationPhase") &&
                !this.get("isPlayingCeremony") &&
                this.get("isNotSpectating") &&
                !this.get("transitioningToSelectedScreen") &&
                !this.get("showVoteShowcase")
              );
            },
          ),
          setPropertiesForMediaFader: r.observeMultiChange(
            "shouldShow",
            "activeAction.champion",
            "activeAction.champion.skins.firstObject.splashPath",
            "currentBackground",
            "shouldShowGrid",
            "shouldShowPhaseTransition",
            "showVoteShowcase",
            function () {
              this.get("shouldShow") &&
                (this.set("splashPath", this.get("currentBackground")),
                this.set("splashUnlocked", !0),
                this.set(
                  "splashDefocus",
                  this.get("shouldShowGrid") ||
                    this.get("shouldShowPhaseTransition") ||
                    this.get("showVoteShowcase"),
                ));
            },
          ),
          untoggleGridOnBanPick: o.observer("timer.phase", function () {
            this.runTask(function () {
              const e = this.get("previousPhase"),
                t = this.get("timer.phase");
              t !== e && this.set("gridRequested", void 0),
                this.set("previousPhase", t);
            }, 1);
          }),
          untoggleGridOnCeremony: o.observer("isPlayingCeremony", function () {
            this.get("isPlayingCeremony") && this.set("gridRequested", void 0);
          }),
          gridToggleClickSfx: o.computed("shouldShowGrid", function () {
            return this.get("shouldShowGrid")
              ? `${c}/sfx-cs-champgrid-button-close.ogg`
              : `${c}/sfx-cs-champgrid-button-open.ogg`;
          }),
          onActiveActionChanged: r.observeMultiChange(
            "sessionActions.activeAction",
            function (e, t) {
              if ("sessionActions.activeAction" in e) {
                const e = t ? t["sessionActions.activeAction"] : void 0;
                this.untoggleGridAfterActing(e);
              }
            },
          ),
          untoggleGridAfterActing: function (e) {
            e &&
              e.get("actor.isSelf") &&
              e.get("completed") &&
              this.set("gridRequested", void 0);
          },
          actions: {
            toggleGrid: function () {
              const e = !this.get("shouldShowGrid");
              this.set("gridRequested", e);
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "hIG9foKL",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-phase-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-phase-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\pick-phase-component\\\\index.js\\" "],["text","\\n\\n"],["append",["helper",["pick-ban-ring"],null,[["sessionActions","activeActions","activeAction","nextActions","allActions","currentActions","isSimultaneousBans","champSelectScreen","shouldShowExpandedRing","isPlayingCeremony","allPlayersActTogether","isShowingBanShowcase","uxSettings","myTeamSize","theirTeamSize"],[["get",["sessionActions"]],["get",["sessionActions","activeActions"]],["get",["sessionActions","activeAction"]],["get",["sessionActions","nextActions"]],["get",["sessionActions","allActions"]],["get",["sessionActions","currentActions"]],["get",["sessionActions","isSimultaneousBans"]],["get",["champSelectScreen"]],["get",["shouldShowExpandedRing"]],["get",["isPlayingCeremony"]],["get",["sessionActions","allPlayersActTogether"]],["get",["shouldShowBanShowcase"]],["get",["uxSettings"]],["get",["myTeamSize"]],["get",["theirTeamSize"]]]]],false],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["ban-showcase-visibility-wrapper ",["helper",["if"],[["get",["shouldShowGrid"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["ban-showcase"],null,[["visible","myTeamBans","theirTeamBans","isSimultaneousBans"],[["get",["shouldShowBanShowcase"]],["get",["sessionActions","myTeamBanActions"]],["get",["sessionActions","theirTeamBanActions"]],["get",["sessionActions","isSimultaneousBans"]]]]],false],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["phase-transition-visibility-wrapper ",["helper",["if"],[["get",["shouldShowGrid"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["phase-transition"],null,[["visible","activeAction","nextActions","phaseTransitionStringsByActionId","allActions"],[["get",["shouldShowPhaseTransition"]],["get",["sessionActions","activeAction"]],["get",["sessionActions","nextActions"]],["get",["sessionActions","phaseTransitionStringsByActionId"]],["get",["sessionActions","allActions"]]]]],false],["text","\\n"],["close-element"],["text","\\n\\n"],["append",["helper",["champion-grid"],null,[["requestInProgress","summoner","isRGM","visible","gridRequested","uxSettings","jmxSettings","shouldShowChestFilter","isRandomChampionEnabled","randomChampionRateLimitConfig","recordDidRequestSucceed","UseNewLoyaltyIcon"],[["get",["requestInProgress"]],["get",["summoner"]],["get",["isRGM"]],["get",["shouldShowGrid"]],["get",["gridRequested"]],["get",["uxSettings"]],["get",["jmxSettings"]],["get",["shouldShowChestFilter"]],["get",["isRandomChampionEnabled"]],["get",["randomChampionRateLimitConfig"]],["get",["recordDidRequestSucceed"]],["get",["UseNewLoyaltyIcon"]]]]],false],["text","\\n"],["append",["helper",["lock-in-button"],null,[["requestInProgress","summoner","visible","gameId"],[["get",["requestInProgress"]],["get",["summoner"]],["get",["shouldShowLockIn"]],["get",["gameId"]]]]],false],["text","\\n"],["block",["if"],[["get",["shouldShowFooter"]]],null,0],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-name-wrapper ",["helper",["if"],[["get",["shouldShowLockedName"]],"visible","hidden"],null]," ",["helper",["if"],[["get",["shouldShowLockedName"]],"just-locked"],null]]]],["flush-element"],["text","\\n    "],["append",["helper",["skin-name"],null,[["skin"],[["get",["sessionActions","lastCompletedAction","champion","baseSkin"]]]]],false],["text","\\n"],["close-element"],["text","\\n"],["open-element","lol-uikit-flat-button",[]],["dynamic-attr","class",["concat",["champion-grid-toggle ",["helper",["unless"],[["get",["gridIsToggleable"]],"hidden"],null]]]],["dynamic-attr","click-sfx-src",["concat",[["unknown",["gridToggleClickSfx"]]]]],["static-attr","remove-min-height",""],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"toggleGrid"],null],null],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","toggle-button-content"],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","champion-grid-footer"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = n(152);
        e.exports = s.Ember.Component.extend({
          layout: n(272),
          classNames: ["player-name-wrapper"],
          classNameBindings: [],
          summonerInfoService: s.Ember.inject.service("summoner-info"),
          didReceiveAttrs: function () {
            this._super(...arguments);
          },
          isNameUnhidden: s.Ember.computed("nameVisibilityType", function () {
            return (
              this.get("nameVisibilityType") === i.NAME_VISIBILITY_TYPE.UNHIDDEN
            );
          }),
          shouldShowDisplayName: s.Ember.computed(
            "isSummonerInMyTeam",
            "nameVisibilityType",
            function () {
              return (
                !this.get("isSummonerInMyTeam") ||
                this.get("nameVisibilityType") === i.NAME_VISIBILITY_TYPE.HIDDEN
              );
            },
          ),
        });
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "NVWzt5Rk",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\player-name-wrapper-component\\\\layout.hbs\\" style-path=\\"null\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\player-name-wrapper-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["shouldShowDisplayName"]]],null,2,1]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    ("],["append",["unknown",["hiddenName"]],false],["text",")\\n"]],"locals":[]},{"statements":[["text","  "],["append",["helper",["player-name"],null,[["format","puuid"],["tooltip",["get",["puuid"]]]]],false],["text","\\n"],["block",["if"],[["get",["isNameUnhidden"]]],null,0]],"locals":[]},{"statements":[["text","  "],["append",["unknown",["displayName"]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(158)) && s.__esModule ? s : { default: s };
        const o = n(1),
          { Ember: a } = o;
        n(274),
          (e.exports = a.Component.extend({
            classNameBindings: [
              "isSpectating:quit-spectate-button:quit-button",
            ],
            layout: n(275),
            actions: {
              quitCustom: function () {
                i.default
                  .ajax({
                    type: "POST",
                    url: "/lol-lobby/v1/lobby/custom/cancel-champ-select",
                  })
                  .then(() => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!0);
                  })
                  .catch((e) => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!1, e);
                  });
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "Bj7701J/",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\quit-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\quit-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\quit-button-component\\\\index.js\\" "],["text","\\n"],["open-element","lol-uikit-flat-button",[]],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"quitCustom"],null],null],["dynamic-attr","disabled",["unknown",["disabled"]],null],["flush-element"],["text","\\n"],["block",["if"],[["get",["isSpectating"]]],null,1,0],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["unknown",["tra","quit"]],false],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["append",["unknown",["tra","quit_spectating"]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = a(n(158)),
          o = a(n(150));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        n(277);
        const r = s.ViewportPlugin.fullScreen().getScreenRoot(
            "rcp-fe-lol-champ-select",
          ),
          l = "sfx-ui";
        e.exports = s.Ember.Component.extend({
          layout: n(278),
          classNameBindings: [":reroll-button"],
          didInsertElement() {
            this._super(...arguments), this.setupResetHandler();
          },
          willDestroyElement() {
            this._super(...arguments), r.off("show", this.get("showHandler"));
          },
          setupResetHandler: function () {
            this.set("showHandler", () => {
              this.isDestroyed ||
                this.isDestroying ||
                this.set("rerollInProgress", !1);
            }),
              r.on("show", this.get("showHandler"));
          },
          rerolls: s.Ember.computed(
            "tbAllowRerolling",
            "tbRerollsRemaining",
            function () {
              if (this.get("tbAllowRerolling"))
                return this.get("tbRerollsRemaining");
            },
          ),
          rerollInProgress: !1,
          rerollsDisabled: s.Ember.computed(
            "rerollInProgress",
            "rerolls",
            "disabled",
            function () {
              const e =
                this.get("disabled") ||
                0 === this.get("rerolls") ||
                this.get("rerollInProgress");
              return e || void 0;
            },
          ),
          championUpdated: s.Ember.observer("summoner.champion", function () {
            if (this.get("rerollInProgress")) {
              const e = this.get("rerollId");
              setTimeout(
                function () {
                  this.isDestroyed ||
                    this.isDestroying ||
                    (this.get("rerollId") === e &&
                      (this.set("rerollInProgress", !1),
                      s.Telemetry.sendEvent("champ-select-reroll"),
                      s.Telemetry.stopAndRecordTimer(this.get("timerId")),
                      this.set("timerId", null)));
                }.bind(this),
                1e3,
              );
            }
          }),
          rerollTooltipText: s.Ember.computed("rerolls", function () {
            return this.get("tra").formatString("reroll_tooltip", {
              rerolls: this.get("rerolls"),
            });
          }),
          mouseEnter: function () {
            this.get("rerollsDisabled") ||
              o.default.playSound(
                l,
                "/fe/lol-champ-select/sounds/sfx-cs-button-reroll-hover.ogg",
              );
          },
          actions: {
            reroll: function () {
              if (
                !this.get("rerollInProgress") &&
                !this.get("rerollsDisabled")
              ) {
                o.default.playSound(
                  l,
                  "/fe/lol-champ-select/sounds/sfx-cs-button-reroll-click.ogg",
                ),
                  this.set("rerollInProgress", !0);
                const e = Date.now();
                this.set("rerollId", e),
                  this.get("timerId") &&
                    s.Telemetry.cancelTimer(this.get("timerId")),
                  this.set(
                    "timerId",
                    s.Telemetry.startTimer("champ-select-reroll"),
                  ),
                  i.default
                    .ajax({
                      type: "POST",
                      url: "/lol-champ-select/v1/session/my-selection/reroll",
                      errorMessage: "error_could_not_reroll",
                    })
                    .then(() => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!0);
                    })
                    .catch((t) => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!1, t),
                        this.isDestroyed ||
                          this.isDestroying ||
                          (this.get("rerollId") === e &&
                            this.set("rerollInProgress", !1));
                    });
              }
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "MOu1gOw9",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\reroll-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\reroll-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\reroll-button-component\\\\index.js\\" "],["text","\\n"],["block",["action-button"],null,[["disabled","click"],[["get",["rerollsDisabled"]],"reroll"]],0],["text","\\n\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","h4",[]],["flush-element"],["append",["unknown",["rerolls"]],false],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(221);
        n(280);
        const i = n(1),
          { Ember: o } = i,
          { EmberHelpers: a } = i;
        e.exports = o.Component.extend({
          classNames: ["ring-gear-component"],
          classNameBindings: [
            "champSelectScreen",
            "isInit:is-init:is-waiting",
            "shouldShowExpandedRing:expanded-ring:default-ring",
            "isAnimating:is-animating:is-pending",
            "isTeamBan:is-player-team:is-enemy-team",
            "isActive:is-active",
            "isRotating:is-rotating:is-not-rotating",
            "isBanCompleted:is-ban-completed",
            "largeAreaAnimationsEnabled:large-area-animations-enabled:large-area-animations-disabled",
          ],
          layout: n(281),
          animationDispatcher: o.inject.service("animation-dispatcher"),
          isAnimating: o.computed.equal(
            "banLockedInAnimationState",
            s.ANIMATION_STATES.STARTED,
          ),
          isRotating: o.computed.equal(
            "banRotationAnimationState",
            s.ANIMATION_STATES.STARTED,
          ),
          isBanCompleted: o.computed.equal(
            "banOutroAnimationState",
            s.ANIMATION_STATES.STARTED,
          ),
          isTeamBan: o.computed.alias(
            "lastCompletedBanAction.actor.isOnLeftSide",
          ),
          ringRotationDegress: 0,
          banLockedInAnimationState: o.computed.alias(
            "animationDispatcher.states.banLockedInAnimation",
          ),
          banRotationAnimationState: o.computed.alias(
            "animationDispatcher.states.banRotationAnimation",
          ),
          banOutroAnimationState: o.computed.alias(
            "animationDispatcher.states.banOutroAnimation",
          ),
          largeAreaAnimationsEnabled: o.computed.equal(
            "uxSettings.largeAreaAnimationsEnabled",
            !0,
          ),
          startRotationAnimation: a.observeChange(
            "banRotationAnimationState",
            function () {
              this.get("isRotating") &&
                (this.setRotation("ringRotationDegress"),
                this.element.style.removeProperty("--rotatePrimaryDeg"),
                this.element.style.setProperty(
                  "--rotatePrimaryDeg",
                  this.get("ringRotationDegress") + "deg",
                ));
            },
          ),
          activeActionType: o.computed.alias("activeAction.type"),
          activeActionTypeChanged: a.observeChange(
            "activeActionType",
            function (e) {
              const t = this.get("sessionActions.banActions.firstObject");
              this.get("activeAction.id") === (t && t.get("id"))
                ? this.set("isInit", !0)
                : void 0 === e
                  ? this.set("isInit", !1)
                  : "pick" === e && this.set("isInit", !0);
            },
          ),
          setRotation: function (e) {
            let t = this.get(e);
            (t += this.get("isTeamBan") ? 45 : -45), this.set(e, t);
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "ealLghsh",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ring-gear-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ring-gear-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ring-gear-component\\\\index.js\\" "],["text","\\n"],["open-element","svg",[]],["static-attr","width","0"],["static-attr","height","0"],["static-attr","xmlns:xlink","http://www.w3.org/1999/xlink","http://www.w3.org/2000/xmlns/"],["flush-element"],["text","\\n  "],["open-element","defs",[]],["flush-element"],["text","\\n    "],["open-element","linearGradient",[]],["static-attr","id","linear-gradient"],["static-attr","x1","0"],["static-attr","y1","0"],["static-attr","x2","0"],["static-attr","y2","550"],["static-attr","gradientUnits","userSpaceOnUse"],["flush-element"],["text","\\n      "],["open-element","stop",[]],["static-attr","offset","0.18"],["static-attr","stop-color","#785a28"],["flush-element"],["close-element"],["text","\\n      "],["open-element","stop",[]],["static-attr","offset","0.213"],["static-attr","stop-color","#785a28"],["flush-element"],["close-element"],["text","\\n      "],["open-element","stop",[]],["static-attr","offset","0.467"],["static-attr","stop-color","#765c29"],["flush-element"],["close-element"],["text","\\n      "],["open-element","stop",[]],["static-attr","offset","0.547"],["static-attr","stop-color","#6b5424"],["flush-element"],["close-element"],["text","\\n      "],["open-element","stop",[]],["static-attr","offset","0.82"],["static-attr","stop-color","#463714"],["flush-element"],["close-element"],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","symbol",[]],["static-attr","id","dashed-ring-symbol"],["static-attr","viewBox","0 0 550 550"],["flush-element"],["text","\\n      "],["open-element","circle",[]],["static-attr","id","svg-ring-dashed-circle"],["static-attr","fill","none"],["static-attr","stroke","#cdbe91"],["static-attr","stroke-width","15"],["static-attr","stroke-miterlimit","10"],["static-attr","stroke-dasharray","1.002,6.011"],["static-attr","cx","275"],["static-attr","cy","275"],["static-attr","r","234.5"],["flush-element"],["close-element"],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","symbol",[]],["static-attr","id","ban-gear-ring-symbol"],["static-attr","viewBox","0 0 550 550"],["flush-element"],["text","\\n      "],["open-element","g",[]],["flush-element"],["text","\\n        "],["open-element","path",[]],["static-attr","id","svg-ring-gear-inner-path"],["static-attr","fill","none"],["static-attr","stroke","#685c41"],["static-attr","stroke-width","2"],["static-attr","stroke-miterlimit","10"],["static-attr","d","M546.432,290.565\\n            v-31.131l-6.086,6.09c-1.457-41.448-12.401-80.471-30.741-114.972l8.246,2.21L502.286,125.8l-2.217,8.274\\n            c-21.334-33.995-50.145-62.815-84.148-84.145l8.279-2.216l-26.959-15.565l2.21,8.247\\n            c-34.511-18.34-73.528-29.289-114.972-30.742l6.086-6.09h-31.131l6.09,6.09c-41.448,1.453-80.471,12.402-114.972,30.742\\n            l2.21-8.247L125.8,47.714l8.274,2.216C100.08,71.26,71.26,100.08,49.93,134.075l-2.216-8.274l-15.565,26.963l8.247-2.21\\n            c-18.34,34.501-29.289,73.524-30.742,114.972l-6.09-6.09v31.131l6.09-6.086c1.453,41.443,12.402,80.461,30.742,114.972\\n            l-8.247-2.21L47.714,424.2l2.216-8.279c21.33,34.004,50.15,62.814,84.145,84.148l-8.274,2.217l26.963,15.564l-2.21-8.246\\n            c34.501,18.34,73.524,29.284,114.972,30.742l-6.09,6.085h31.131l-6.086-6.085c41.443-1.458,80.461-12.402,114.972-30.742\\n            l-2.21,8.246l26.959-15.564l-8.279-2.217c34.004-21.334,62.814-50.145,84.148-84.148l2.217,8.279l15.564-26.959l-8.246,2.21\\n            c18.34-34.511,29.284-73.528,30.741-114.972L546.432,290.565z"],["flush-element"],["close-element"],["text","\\n        "],["open-element","circle",[]],["static-attr","cx","275"],["static-attr","cy","275"],["static-attr","r","273"],["static-attr","fill","none"],["static-attr","stroke","#685c41"],["static-attr","stroke-width","4"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","main-ring-container"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","id","center-ring"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","id","center-ring-container"],["flush-element"],["text","\\n      "],["open-element","svg",[]],["static-attr","id","ban-bar-svg"],["static-attr","width","550"],["static-attr","height","550"],["static-attr","class","slash-line-rotation"],["flush-element"],["text","\\n        "],["open-element","defs",[]],["flush-element"],["text","\\n          "],["open-element","clipPath",[]],["static-attr","id","circle-container-mask"],["flush-element"],["text","\\n            "],["open-element","circle",[]],["static-attr","cx","275"],["static-attr","cy","275"],["static-attr","r","275"],["static-attr","fill","#000"],["flush-element"],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n        "],["open-element","g",[]],["static-attr","class","ban-bar-container"],["static-attr","clip-path","url(#circle-container-mask)"],["flush-element"],["text","\\n          "],["open-element","line",[]],["static-attr","class","ban-line top"],["static-attr","fill","none"],["static-attr","stroke","#685c41"],["static-attr","stroke-width","4"],["static-attr","stroke-miterlimit","10"],["static-attr","x1","10"],["static-attr","y1","270"],["static-attr","x2","546"],["static-attr","y2","270"],["flush-element"],["close-element"],["text","\\n          "],["open-element","line",[]],["static-attr","class","ban-line bottom"],["static-attr","fill","none"],["static-attr","stroke","#685c41"],["static-attr","stroke-width","4"],["static-attr","stroke-miterlimit","10"],["static-attr","x1","4"],["static-attr","y1","282"],["static-attr","x2","540"],["static-attr","y2","282"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","main-gear-container"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","ring-position"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","dashed-ring-rotation"],["flush-element"],["text","\\n            "],["open-element","svg",[]],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["text","\\n              "],["open-element","use",[]],["static-attr","xlink:href","#dashed-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","dashed-ring-circle"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","ring-position"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","slash-ring-rotation"],["flush-element"],["text","\\n            "],["open-element","div",[]],["static-attr","class","gear-ring-rotation"],["flush-element"],["text","\\n              "],["open-element","svg",[]],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["text","\\n                "],["open-element","use",[]],["static-attr","xlink:href","#ban-gear-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","ban-gear-ring-symbol"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","id","intro-ring"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","id","intro-dashed-container"],["static-attr","class","ring-position"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","dashed-ring-rotation"],["flush-element"],["text","\\n        "],["open-element","svg",[]],["static-attr","id","dashed-ring-intro"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["text","\\n          "],["open-element","use",[]],["static-attr","xlink:href","#dashed-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","dashed-ring-circle"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","id","intro-gear-container"],["static-attr","class","ring-position"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","slash-ring-rotation"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","gear-ring-rotation"],["flush-element"],["text","\\n          "],["open-element","svg",[]],["static-attr","id","ban-gear-ring-intro"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["text","\\n            "],["open-element","use",[]],["static-attr","xlink:href","#ban-gear-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","ban-gear-ring-symbol"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","expanded-ring-container"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","id","left-ring"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","clip-box"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","ring-position ring-offset"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","dashed-ring-rotation"],["flush-element"],["text","\\n          "],["open-element","svg",[]],["static-attr","width","600"],["static-attr","height","600"],["static-attr","viewBox","0 0 600 600"],["flush-element"],["text","\\n            "],["open-element","circle",[]],["static-attr","class","dashed-ring-circle"],["static-attr","fill","none"],["static-attr","stroke","#cdbe91"],["static-attr","stroke-width","15"],["static-attr","stroke-miterlimit","10"],["static-attr","stroke-dasharray","1.002,6.011"],["static-attr","cx","300"],["static-attr","cy","300"],["static-attr","r","234.5"],["flush-element"],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","ring-position ring-offset"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","slash-ring-rotation"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","gear-ring-rotation"],["flush-element"],["text","\\n            "],["open-element","svg",[]],["static-attr","width","550"],["static-attr","height","550"],["static-attr","viewBox","0 0 550 550"],["flush-element"],["text","\\n              "],["open-element","use",[]],["static-attr","xlink:href","#ban-gear-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","ban-gear-ring-symbol left"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","id","right-ring"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","clip-box"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","ring-position ring-offset"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","dashed-ring-rotation"],["flush-element"],["text","\\n          "],["open-element","svg",[]],["static-attr","width","600"],["static-attr","height","600"],["static-attr","viewBox","0 0 600 600"],["flush-element"],["text","\\n            "],["open-element","circle",[]],["static-attr","class","dashed-ring-circle"],["static-attr","fill","none"],["static-attr","stroke","#cdbe91"],["static-attr","stroke-width","15"],["static-attr","stroke-miterlimit","10"],["static-attr","stroke-dasharray","1.002,6.011"],["static-attr","cx","300"],["static-attr","cy","300"],["static-attr","r","234.5"],["flush-element"],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","ring-position ring-offset"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","slash-ring-rotation"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","gear-ring-rotation"],["flush-element"],["text","\\n            "],["open-element","svg",[]],["static-attr","width","550"],["static-attr","height","550"],["static-attr","viewBox","0 0 550 550"],["flush-element"],["text","\\n              "],["open-element","use",[]],["static-attr","xlink:href","#ban-gear-ring-symbol","http://www.w3.org/1999/xlink"],["static-attr","class","ban-gear-ring-symbol left"],["static-attr","x","0"],["static-attr","y","0"],["static-attr","width","550"],["static-attr","height","550"],["flush-element"],["close-element"],["text","\\n            "],["close-element"],["text","\\n          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1);
        const { RunMixin: i } = s.EmberAddons.EmberLifeline,
          o = s.UiKitPlugin.getTemplateHelper();
        var a = s.Ember.Component.extend(i, {
          layout: n(283),
          classNames: ["rune-recommender-button-component"],
          didUpdateAttrs: function () {
            this._super(...arguments);
            const e = this._showTimedTooltip,
              t = this.get("shouldShowTimedTooltip");
            !e && t && this.showTimedTooltip(), (this._showTimedTooltip = t);
          },
          showTimedTooltip: function () {
            const e = this.get("timedTooltipText"),
              t = document.createElement("lol-uikit-tooltip");
            t.appendChild(o.contentBlockTooltipAttention(e));
            const n = 1e3 * (this.get("timedTooltipDurationSeconds") || 7);
            s.TooltipManager.assign(this.element, t, null, {
              type: "attention",
              targetAnchor: { x: "center", y: "top" },
              tooltipAnchor: { x: "center", y: "bottom" },
            }),
              this.sendAction("acknowledgeTutorialTooltip"),
              this.runTask(() => {
                s.TooltipManager.unassign(this.element);
              }, n);
          },
          actions: {
            onButtonClick: function () {
              this.sendAction("handleClick");
            },
          },
        });
        t.default = a;
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "9tcTbcV7",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\rune-recommender-button-component\\\\layout.hbs\\" style-path=\\"null\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\rune-recommender-button-component\\\\index.js\\" "],["text","\\n"],["append",["helper",["framed-icon-button"],null,[["disabled","disabledTooltipText","iconPath","clickSfxPath","hoverSfxPath","onButtonClick"],[["get",["isDisabled"]],["get",["disabledTooltipText"]],"/fe/lol-champ-select/images/perks/rune-recommender-icon.png","/fe/lol-champ-select/sounds/sfx-uikit-edit-click.ogg","/fe/lol-champ-select/sounds/sfx-uikit-grid-hover.ogg",["helper",["action"],[["get",[null]],"onButtonClick"],null]]]],false],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(150)) && s.__esModule ? s : { default: s };
        const o = n(1),
          { Ember: a } = o,
          { EmberHelpers: r } = o;
        n(285);
        const l = o.EmberDataBinding({
          Ember: a,
          websocket: o.getProvider().getSocket(),
          boundProperties: { skinInfo: "/lol-store/v1/skins/{{skin.id}}" },
        });
        e.exports = a.Component.extend(l, {
          tagName: "div",
          layout: n(286),
          skinPurchaseService: a.inject.service("skin-purchase"),
          meetsChampionRequirement: a.computed.alias("skin.isChampionUnlocked"),
          isSelected: a.computed("skin.id", "selectedSkinId", function () {
            return this.get("skin.id") === this.get("selectedSkinId");
          }),
          meetsBaseSkinRequirement: a.computed(
            "baseSkin",
            "baseSkin.ownership.owned",
            function () {
              const e = this.get("baseSkin"),
                t = this.get("baseSkin.ownership.owned");
              return !e || t;
            },
          ),
          invalidPriceData: a.computed(
            "skin.id",
            "skinInfo",
            "skinInfo.itemId",
            "skinInfo.prices",
            "skinInfo.sale",
            "skinInfo.sale.prices",
            function () {
              const e = this.get("skinInfo"),
                t = this.get("skin.id");
              if (!e || e.get("itemId") !== t) return !0;
              const n = this._getPricesFromSkinInfo(e);
              return !n || 0 === Object.getOwnPropertyNames(n).length;
            },
          ),
          purchaseDisabled: r.computedGate(
            "jmxSettings.LcuChampionSelect.SkinPurchaseEnabled",
            "meetsChampionRequirement",
            "meetsBaseSkinRequirement",
            "timeRemaining",
            "jmxSettings.LcuChampionSelect.SkinPurchaseTime",
            "inFinalizationPhase",
            "skinInfo.active",
            "invalidPriceData",
            function () {
              return (
                !this.get(
                  "jmxSettings.LcuChampionSelect.SkinPurchaseEnabled",
                ) ||
                !(
                  this.get("meetsChampionRequirement") &&
                  this.get("meetsBaseSkinRequirement") &&
                  !(
                    this.get("timeRemaining") <
                      this.get(
                        "jmxSettings.LcuChampionSelect.SkinPurchaseTime",
                      ) && this.get("inFinalizationPhase")
                  ) &&
                  this.get("skinInfo.active") &&
                  !this.get("invalidPriceData")
                )
              );
            },
          ),
          color: a.computed("skin.colors.[]", function () {
            const e = this.get("skin.colors");
            if (e)
              return 1 !== e.length && e[1]
                ? "linear-gradient(135deg, " +
                    e[0] +
                    " 0%, " +
                    e[0] +
                    " 50%, " +
                    e[1] +
                    " 50%, " +
                    e[1] +
                    " 100%)"
                : e[0];
          }),
          actions: {
            onEnter() {
              i.default.playSound(
                "sfx-ui",
                "/fe/lol-champ-select/sounds/sfx-uikit-grid-hover.ogg",
              ),
                this.get("onEnter")(this.get("skin"));
            },
            onLeave() {
              this.get("onLeave")(this.get("skin"));
            },
            onClick() {
              if (this.get("skin.unlocked"))
                i.default.playSound(
                  "sfx-ui",
                  "/fe/lol-champ-select/sounds/sfx-uikit-grid-click.ogg",
                ),
                  this.get("onClick")(this.get("skin"));
              else if (!this.get("purchaseDisabled")) {
                i.default.playSound(
                  "sfx-ui",
                  "/fe/lol-champ-select/sounds/sfx-uikit-grid-click.ogg",
                );
                const e = this.get("skinInfo");
                this.get("skinPurchaseService").openPAWModal(
                  e,
                  this.recordDidRequestSucceed,
                );
              }
            },
          },
          _getPricesFromSkinInfo: function (e) {
            if (!e) return {};
            const t = (e.sale && e.sale.prices) || [],
              n = (e, t) => (
                e.cost && e.cost > 0 && e.currency && (t[e.currency] = e.cost),
                t
              ),
              s = (e.prices || []).reduce(n, {});
            return t.reduce(n, s);
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "CzG7/HIE",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\skin-button\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\skin-button\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\chroma-modal-component\\\\skin-button\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["chroma-skin-button \\n\\t",["helper",["unless"],[["get",["skin","unlocked"]],"locked"],null]," \\n\\t",["helper",["if"],[["get",["purchaseDisabled"]],"purchase-disabled"],null]," \\n\\t",["helper",["if"],[["get",["isSelected"]],"selected"],null]]]],["dynamic-attr","onmouseover",["helper",["action"],[["get",[null]],"onEnter"],null],null],["dynamic-attr","onmouseout",["helper",["action"],[["get",[null]],"onLeave"],null],null],["dynamic-attr","onmouseup",["helper",["action"],[["get",[null]],"onClick"],null],null],["flush-element"],["text","\\n"],["block",["if"],[["get",["skin","unlocked"]]],null,2,1],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","\\t"],["open-element","div",[]],["static-attr","class","contents"],["dynamic-attr","style",["concat",["background:",["unknown",["color"]]]]],["flush-element"],["close-element"],["text","\\n\\t"]],"locals":[]},{"statements":[["block",["if"],[["get",["isSelected"]]],null,0]],"locals":[]},{"statements":[["text","\\t"],["open-element","div",[]],["static-attr","class","contents"],["dynamic-attr","style",["concat",["background:",["unknown",["color"]]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = (s = n(150)) && s.__esModule ? s : { default: s },
          a = n(152);
        const r = i.UiKitPlugin.getFlyoutManager(),
          { RunMixin: l } = i.EmberAddons.EmberLifeline;
        n(227), n(288);
        const c = i.Ember.Object.extend({
            containerStyle: i.Ember.computed("offset", "faded", function () {
              const e = this.get("offset");
              let t = 37.5;
              return (
                e < 2
                  ? (t = 37.5 - 18.5 * (2 - e))
                  : e > 2 && (t = 47.5 + 18.5 * (e - 2)),
                "left: " +
                  t +
                  "%;opacity: " +
                  (this.get("faded") ? "0;" : "1;") +
                  (this.get("unclickable") ? "pointer-events: none;" : "")
              );
            }),
            isCentered: i.Ember.computed("offset", function () {
              return 2 === this.get("offset");
            }),
            selectedChildSkin: i.Ember.computed(
              "selectedChildSkinId",
              "skin.childSkins.[]",
              function () {
                return (this.get("skin.childSkins") || []).find(
                  (e) => e.id === this.get("selectedChildSkinId"),
                );
              },
            ),
            showSelected: i.Ember.computed(
              "skin.id",
              "skinCarousel.selectedSkinId",
              "selectedChildSkin",
              function () {
                return (
                  this.get("skinCarousel.selectedSkinId") ===
                    this.get("skin.id") || this.get("selectedChildSkin")
                );
              },
            ),
            selectedChromaStyle: i.Ember.computed(
              "selectedChildSkin.colors",
              function () {
                const e = this.get("selectedChildSkin.colors");
                if (e && 0 !== e.length)
                  return 1 !== e.length && e[1]
                    ? "linear-gradient(135deg, " +
                        e[0] +
                        " 0%, " +
                        e[0] +
                        " 50%, " +
                        e[1] +
                        " 50%, " +
                        e[1] +
                        " 100%)"
                    : e[0];
              },
            ),
          }),
          u = i.Ember.Object.extend({
            skin: null,
            skinCarousel: null,
            isViewed: i.Ember.computed(
              "skin.id",
              "skinCarousel.viewSkin.id",
              "skinCarousel.viewSkin.parentSkinId",
              function () {
                return (
                  this.get("skin.id") ===
                    this.get("skinCarousel.viewSkin.id") ||
                  this.get("skin.id") ===
                    this.get("skinCarousel.viewSkin.parentSkinId")
                );
              },
            ),
          });
        e.exports = i.Ember.Component.extend(l, {
          layout: n(289),
          classNames: ["skin-carousel"],
          classNameBindings: ["willTransition"],
          willTransition: !1,
          maxSkinsToDisplay: 5,
          skinCarouselItems: null,
          isFlyoutOpen: !1,
          init: function () {
            this._super(...arguments),
              this.set("skinCarouselItems", new i.Ember.A());
            for (let e = 0; e < this.maxSkinsToDisplay + 4; e++)
              this.get("skinCarouselItems").pushObject(
                c.create({ placeholder: !0, skinCarousel: this, skin: {} }),
              );
            this.get("isShowingGrid") && this.setSkinCarouselItems();
            const e = {
              targetAnchor: { x: "center", y: "top" },
              tooltipAnchor: { x: "center", y: "bottom" },
              offset: { x: -1, y: 44 },
              orientation: "top",
              animated: this.get("largeAreaAnimationsEnabled"),
              backdropCutout: !1,
            };
            this.set("flyoutSettings", e);
          },
          didReceiveAttrs: function () {
            this._super(...arguments);
            const e = this.get("isSkinGrantedFromBoost");
            if (e && e !== this._prevSkinGrantedFromBoost) {
              const e = this.get("viewSkinIndex"),
                t = this.getIndexBySkinId(
                  this.get("carouselSkins"),
                  this.get("selectedSkinId"),
                );
              this.scroll(e, t);
            }
            this._prevSkinGrantedFromBoost = e;
          },
          timeRemaining: i.Ember.computed.alias("timer.timeRemaining"),
          inFinalizationPhase: i.Ember.computed.alias(
            "timer.inFinalizationPhase",
          ),
          currentMapChromaPath: i.Ember.computed.alias(
            "map.assets.champ-select-flyout-background",
          ),
          largeAreaAnimationsEnabled: i.Ember.computed.readOnly(
            "uxSettings.largeAreaAnimationsEnabled",
          ),
          skinPips: i.Ember.computed("carouselSkins.[]", function () {
            const e = this.get("carouselSkins");
            return e && e.length
              ? i.Ember.A(
                  e.map((e) => u.create({ skin: e, skinCarousel: this })),
                )
              : [];
          }),
          disabled: !1,
          disabledAttr: i.Ember.computed("disabled", function () {
            return !!this.get("disabled") || null;
          }),
          handleDisabledState: i.Ember.observer("disabled", function () {
            this.get("disabled") && this.hideChromaFlyout();
          }),
          sanitizedSkinName: i.Ember.computed(
            "viewSkin",
            "championName",
            function () {
              let e = this.get("viewSkin.name") || "";
              const t = this.get("championName");
              return (e = e.replace(" " + t, "")), (e = e.replace(t, "")), e;
            },
          ),
          viewSkinIndex: i.Ember.computed(
            "carouselSkins.[]",
            "viewSkin.parentSkinId",
            "viewSkin.id",
            function () {
              const e =
                  this.get("viewSkin.parentSkinId") || this.get("viewSkin.id"),
                t = this.get("carouselSkins") || [];
              return this.getIndexBySkinId(t, e);
            },
          ),
          disabledChromas: i.Ember.computed.readOnly(
            "jmxSettings.DisabledChampionSkins.DisabledChromas",
          ),
          _isOffsetHidden: function (e, t, n) {
            let s = Math.min(
              this.maxSkinsToDisplay,
              this.get("carouselSkins.length") || 0,
            );
            if ((4 === s && (s = 5), 2 === s && 2 !== e)) {
              if (t && 0 === n && e < 2) return !0;
              if (!t && 1 === n && e < 2) return !0;
              if (t && 1 === n && e > 2) return !0;
              if (!t && 0 === n && e > 2) return !0;
            }
            const i = Math.floor(s / 2);
            return e < 2 - i || e > 2 + i;
          },
          setSkinCarouselItems: i.Ember.observer(
            "viewSkin.id",
            "isShowingGrid",
            "carouselSkins.@each.unlocked",
            "disabledChromas",
            function () {
              if (this.get("isShowingGrid")) return;
              const e = this.get("viewSkinIndex"),
                t = i.Ember.A(this.get("carouselSkins") || void 0);
              if (t && e > -1) {
                let n = t.get("length"),
                  s = this.get("carouselTransitionOffset") || 0;
                4 === n &&
                  (n++, -1 === s && 3 === e ? s-- : 1 === s && 0 === e && s++);
                const o = (n + e - 2) % n;
                for (let r = -2; r < this.maxSkinsToDisplay + 2; r++) {
                  const l = r + 2,
                    c = (r + o + n) % n;
                  let u = t.objectAt(c),
                    m = !1;
                  u || ((m = !0), (u = {}));
                  const d = r + s,
                    p = this.get("disabledChromas");
                  let h,
                    g,
                    f = !m && i.Ember.get(u, "childSkins.length");
                  f &&
                    p &&
                    (f =
                      void 0 !== u.childSkins.find((e) => !p.includes(e.id))),
                    u?.productType === a.skinProductTypes.kTieredSkin &&
                      ((h = u.childSkins?.reduce(
                        (e, t) => (t.ownership.owned ? t : e),
                        u.childSkins[0],
                      )),
                      (g = h?.tilePath)),
                    this.get("skinCarouselItems")
                      .objectAt(l)
                      .setProperties({
                        placeholder: m,
                        offsetClass: "skin-carousel-offset-" + d,
                        offset: d,
                        hasChildSkins: f,
                        alternativeTilePath: g,
                        isTieredSkin:
                          u?.productType === a.skinProductTypes.kTieredSkin,
                        skin: u,
                        selectedChildSkinId:
                          this.parentSkinIdToSelectedChromaIdMap[u.id],
                        unlocked: u.unlocked,
                        unclickable: this._isOffsetHidden(r, !0, e),
                        faded: this._isOffsetHidden(d, !s, e),
                      });
                }
                s &&
                  (this.set("willTransition", !0),
                  this.runTask(() => {
                    this._resolveSkinCarouselTransition(e);
                  }, 1));
              }
            },
          ),
          _resolveSkinCarouselTransition: function (e) {
            this.set("willTransition", !1),
              (this.get("skinCarouselItems") || i.Ember.A()).forEach(function (
                t,
                n,
              ) {
                const s = n - 2;
                t.set("offsetClass", "skin-carousel-offset-" + s),
                  t.set("offset", s),
                  t.set("faded", this._isOffsetHidden(s, !0, e));
              }, this),
              this.set("carouselTransitionOffset", 0);
          },
          playSfxUISound: function (e) {
            const t = "/fe/lol-champ-select/sounds/" + e;
            o.default.playSound("sfx-ui", t);
          },
          playSkinCarouselSound: function (e) {
            const t =
              e > 0 ? "sfx-cs-splash-forward.ogg" : "sfx-cs-splash-back.ogg";
            this.playSfxUISound(t);
          },
          hideChromaFlyout: function () {
            r.isActive() &&
              this.$(".skin-selection-item .chroma-button").each((e, t) => {
                r.sendEvent(t, "toggle");
              });
          },
          getIndexBySkinId(e, t) {
            for (let n = 0; n < e.length; n++) if (e[n].id === t) return n;
            return -1;
          },
          calculateCarouselScrollMagnitude(e, t) {
            const n = this.get("carouselSkins.length"),
              s = t - e;
            let i = 0;
            if (Math.abs(s) <= n / 2) i = s;
            else {
              i = (s > 0 ? -1 : 1) * (n - Math.abs(s));
            }
            return (i = Math.min(i, 2)), (i = Math.max(i, -2)), i;
          },
          scroll: function (e, t, n) {
            if (!this.get("disabled") && e !== t) {
              const s = this.calculateCarouselScrollMagnitude(e, t);
              this.set("carouselTransitionOffset", s),
                this.playSkinCarouselSound(s);
              const i = this.get("carouselSkins")[t];
              this.sendAction("setSkinThroughScroll", i),
                n && this.playSfxUISound(n);
            }
          },
          actions: {
            skinScrollBy1: function (e) {
              const t = this.get("carouselSkins.length"),
                n = this.get("viewSkinIndex"),
                s = (n + e + t) % t;
              this.scroll(n, s);
            },
            skinButtonClicked: function (e, t) {
              const n = this.get("carouselSkins"),
                s = this.get("viewSkinIndex"),
                i = this.getIndexBySkinId(n, e.id);
              this.scroll(s, i, t);
            },
            chromaButtonClicked: function (e) {
              e.get("isCentered") &&
                !this.get("disabled") &&
                (this.set("baseSkin", e.get("skin")),
                this.get("isFlyoutOpen") ||
                  this.playSfxUISound("sfx-cs-button-chromas-open.ogg"),
                this.set("isFlyoutOpen", !this.get("isFlyoutOpen")));
            },
            hideChromaFlyout: function () {
              this.set("isFlyoutOpen", !1);
            },
            skinButtonMouseEnter: function (e) {
              this.get("disabled") ||
                e ||
                this.playSfxUISound("sfx-uikit-grid-hover.ogg");
            },
            setSkinThroughChromaModal: function (e) {
              this.sendAction("setSkinThroughChromaModal", e),
                this.playSfxUISound("sfx-cs-button-chromas-click.ogg"),
                this.set("isFlyoutOpen", !1);
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "C0NxOryd",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-carousel-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-carousel-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-carousel-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["skin-selection-indicator ",["helper",["if"],[["get",["disabled"]],"disabled","enabled"],null]]]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","line line-left"],["flush-element"],["close-element"],["text","\\n  "],["open-element","ul",[]],["static-attr","class","skin-selection-indicator-list"],["flush-element"],["text","\\n"],["block",["each"],[["get",["skinPips"]]],null,9],["text","  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","line line-right"],["flush-element"],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","skin-selection-button-container"],["flush-element"],["text","\\n  "],["open-element","lol-uikit-arrow-button",[]],["dynamic-attr","disabled",["unknown",["disabledAttr"]],null],["static-attr","direction","left"],["static-attr","class","skin-selection-button left"],["static-attr","click-sfx-src","/fe/lol-champ-select/sounds/sfx-uikit-button-arrowback-click.ogg"],["static-attr","hover-sfx-src","/fe/lol-champ-select/sounds/sfx-uikit-button-gold-hover.ogg"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"skinScrollBy1",-1],null],null],["flush-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","skin-selection-carousel-container"],["flush-element"],["text","\\n    "],["open-element","ul",[]],["dynamic-attr","class",["concat",["skin-selection-carousel ",["helper",["if"],[["get",["disabled"]],"disabled","enabled"],null]," ",["helper",["if"],[["get",["willTransition"]],"will-transition","did-transition"],null]]]],["flush-element"],["text","\\n"],["block",["each"],[["get",["skinCarouselItems"]]],null,8],["text","      "],["open-element","lc-flyout",[]],["dynamic-attr","open",["unknown",["isFlyoutOpen"]],null],["dynamic-attr","onHide",["helper",["action"],[["get",[null]],"hideChromaFlyout"],null],null],["dynamic-attr","uiKitOptionOverrides",["unknown",["flyoutSettings"]],null],["flush-element"],["text","\\n        "],["open-element","lc-flyout-content",[]],["flush-element"],["text","\\n          "],["append",["helper",["chroma-modal"],null,[["selectedSkinId","timeRemaining","inFinalizationPhase","disabledChromas","currentMapChromaPath","baseSkin","jmxSettings","setSkinThroughChromaModal","recordDidRequestSucceed"],[["get",["selectedSkinId"]],["get",["timeRemaining"]],["get",["inFinalizationPhase"]],["get",["disabledChromas"]],["get",["currentMapChromaPath"]],["get",["baseSkin"]],["get",["jmxSettings"]],["helper",["action"],[["get",[null]],"setSkinThroughChromaModal"],null],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["append",["helper",["skin-purchase-button"],null,[["jmxSettings","viewSkin","isShown","ip","rp","isSkinSelectVisible","timeRemaining","inFinalizationPhase"],[["get",["jmxSettings"]],["get",["rootViewSkin"]],["get",["rootComponentShown"]],["get",["ip"]],["get",["rp"]],["get",["isSkinSelectVisible"]],["get",["timer","timeRemaining"]],["get",["timer","inFinalizationPhase"]]]]],false],["text","\\n\\n  "],["open-element","lol-uikit-arrow-button",[]],["dynamic-attr","disabled",["unknown",["disabledAttr"]],null],["static-attr","direction","right"],["static-attr","class","skin-selection-button right"],["static-attr","hover-sfx-src","/fe/lol-champ-select/sounds/sfx-uikit-button-gold-hover.ogg"],["static-attr","click-sfx-src","/fe/lol-champ-select/sounds/sfx-uikit-button-arrowfwd-click.ogg"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"skinScrollBy1",1],null],null],["flush-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","                      "],["open-element","div",[]],["static-attr","class","chroma-button-2 chroma-selection"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"chromaButtonClicked",["get",["item"]]],null],null],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["unless"],[["get",["item","isTieredSkin"]]],null,0]],"locals":[]},{"statements":[["text","                        "],["open-element","div",[]],["static-attr","class","content"],["dynamic-attr","style",["concat",["background: ",["unknown",["item","selectedChromaStyle"]]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-framed-icon"],null,[["disabled","class","onclick","interactive","borderWidth"],[["get",["disabledAttr"]],"chroma-button chroma-selection {{if item.selectedChildSkin \'selected\'}}",["helper",["action"],[["get",[null]],"chromaButtonClicked",["get",["item"]]],null],true,2]],2]],"locals":[]},{"statements":[["block",["if"],[["get",["item","skin","chromaPreviewPath"]]],null,3,1]],"locals":[]},{"statements":[["block",["if"],[["get",["item","hasChildSkins"]]],null,4]],"locals":[]},{"statements":[["block",["if"],[["get",["item","unlocked"]]],null,5]],"locals":[]},{"statements":[["text","              "],["open-element","div",[]],["static-attr","class","skin-selection-thumbnail-gem-overlay"],["flush-element"],["text","\\n                "],["open-element","img",[]],["dynamic-attr","src",["concat",[["unknown",["item","skin","rarityGemPath"]]]]],["flush-element"],["close-element"],["text","\\n              "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","        "],["open-element","li",[]],["dynamic-attr","class",["concat",["skin-selection-item\\n            skin-selection-item-visible\\n            ",["helper",["if"],[["get",["item","placeholder"]],"skin-selection-item-placeholder"],null],"\\n            ",["unknown",["item","offsetClass"]],"\\n            ",["helper",["if"],[["get",["item","showSelected"]],"skin-selection-item-selected"],null],"\\n            ",["helper",["if"],[["get",["item","unlocked"]],"enabled","disabled"],null]]]],["dynamic-attr","style",["unknown",["item","containerStyle"]],null],["flush-element"],["text","\\n\\n          "],["open-element","div",[]],["static-attr","class","skin-selection-thumbnail"],["dynamic-attr","onmouseenter",["helper",["action"],[["get",[null]],"skinButtonMouseEnter",["get",["item","unclickable"]]],null],null],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"skinButtonClicked",["get",["item","skin"]],"sfx-cs-button-thumbnail-click.ogg"],null],null],["dynamic-attr","style",["concat",["background-image:url(",["helper",["if"],[["get",["item","isTieredSkin"]],["get",["item","alternativeTilePath"]],["get",["item","skin","tilePath"]]],null],")"]]],["flush-element"],["text","\\n"],["block",["if"],[["get",["item","skin","rarityGemPath"]]],null,7],["text","\\n"],["block",["unless"],[["get",["item","unclickable"]]],null,6],["text","          "],["close-element"],["text","\\n          "],["open-element","div",[]],["dynamic-attr","class",["concat",["skin-selection-item-information\\n            ",["helper",["if"],[["get",["item","skin","ownership","rental","rented"]],"rental-icon"],null],"\\n            ",["helper",["if"],[["get",["item","skin","ownership","loyaltyReward"]],"loyalty-reward-icon"],null],"\\n            ",["helper",["if"],[["get",["UseNewLoyaltyIcon"]],"loyalty-reward-icon--rewards"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n"]],"locals":["item"]},{"statements":[["text","      "],["open-element","li",[]],["dynamic-attr","class",["concat",["skin-selection-indicator-selector ",["helper",["if"],[["get",["skinPip","isViewed"]],"skin-selection-indicator-selector-viewed"],null]]]],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"skinButtonClicked",["get",["skinPip","skin"]],"sfx-uikit-button-pip-click.ogg"],null],null],["flush-element"],["close-element"],["text","\\n"]],"locals":["skinPip","index"]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        const s = n(1),
          { Ember: i } = s,
          { EmberHelpers: o } = s;
        n(291),
          (e.exports = i.Component.extend({
            classNames: ["champion-skin-name"],
            layout: n(292),
            skinName: o.throttled("skin.name", 300),
            showChampionChestAvailable: i.computed(
              "skin.championId",
              "shouldShowChestAvailability",
              "championChestAvailabilityMap",
              function () {
                const e = this.get("skin.championId"),
                  t = this.get("championChestAvailabilityMap");
                return (
                  !!(this.get("shouldShowChestAvailability") && e && t) &&
                  t.get(e + "")
                );
              },
            ),
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "bvMCZj9K",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-name-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-name-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-name-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","skin-name-text"],["flush-element"],["text","\\n  "],["append",["unknown",["skinName"]],false],["text","\\n"],["close-element"],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,1]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["tra","tooltip_skin_name_chest_available"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","skin-name-chest-available"],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["right","whole-window"]],0],["text","  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n(294);
        const s = n(1),
          { Ember: i } = s,
          { EmberHelpers: o } = s,
          a = s.EmberDataBinding({
            Ember: i,
            websocket: s.getProvider().getSocket(),
            boundProperties: {
              skinInfo: "/lol-store/v1/skins/{{viewSkin.id}}",
            },
          });
        e.exports = i.Component.extend(a, {
          classNames: ["skin-purchase"],
          layout: n(295),
          skinPurchaseService: i.inject.service("skin-purchase"),
          disabled: o.computedGate(
            "skinInfo.active",
            "invalidPriceData",
            "viewSkin.isChampionUnlocked",
            "jmxSettings.LcuChampionSelect.SkinPurchaseEnabled",
            "jmxSettings.LcuChampionSelect.SkinPurchaseTime",
            "timeRemaining",
            "inFinalizationPhase",
            "invalidSkinInfoTag",
            function () {
              return (
                !this.get(
                  "jmxSettings.LcuChampionSelect.SkinPurchaseEnabled",
                ) ||
                !!(
                  !this.get("viewSkin.isChampionUnlocked") ||
                  !this.get("skinInfo.active") ||
                  (this.get("timeRemaining") <
                    this.get(
                      "jmxSettings.LcuChampionSelect.SkinPurchaseTime",
                    ) &&
                    this.get("inFinalizationPhase")) ||
                  this.get("invalidSkinInfoTag") ||
                  this.get("invalidPriceData")
                )
              );
            },
          ),
          invalidPriceData: i.computed(
            "skinInfo",
            "skinInfo.itemId",
            "viewSkin.id",
            function () {
              const e = this.get("skinInfo"),
                t = this.get("viewSkin.id");
              if (!e || e.get("itemId") !== t) return !0;
              const n = this._getPricesFromSkinInfo(e);
              return !n || 0 === Object.getOwnPropertyNames(n).length;
            },
          ),
          invalidSkinInfoTag: i.computed(
            "skinInfo",
            "skinInfo.tags.[]",
            function () {
              return (
                this.get("skinInfo.tags") &&
                this.get("skinInfo.tags").includes("paw_item_purchase_disabled")
              );
            },
          ),
          _getPricesFromSkinInfo: function (e) {
            if (!e) return {};
            const t = (e.sale && e.sale.prices) || [],
              n = e.prices || [],
              s = {},
              i = (e) => {
                e.cost && e.cost > 0 && e.currency && (s[e.currency] = e.cost);
              };
            return n.forEach(i), t.forEach(i), s;
          },
          showSkinPurchaseButton: i.computed(
            "viewSkin.unlocked",
            "viewSkin.isBase",
            function () {
              return (
                !this.get("viewSkin.unlocked") && !this.get("viewSkin.isBase")
              );
            },
          ),
          actions: {
            showSkinPurchaseModal: function () {
              if (this.get("disabled")) return;
              const e = this.get("skinInfo");
              this.get("skinPurchaseService").openPAWModal(
                e,
                this.recordDidRequestSucceed,
              );
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "1i7G2tKr",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-purchase-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-purchase-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-purchase-button-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","unlock-skin-hit-area"],["dynamic-attr","class",["concat",[["helper",["unless"],[["get",["showSkinPurchaseButton"]],"hidden"],null]," ",["helper",["if"],[["get",["disabled"]],"disabled","enabled"],null]," ",["helper",["unless"],[["get",["isSkinSelectVisible"]],"skin-select-not-visible"],null]]]],["modifier",["action"],[["get",[null]],"showSkinPurchaseModal"]],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","locked-state"],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["disabled"]]],null,1],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","class","champ-select-skin-purchase-unavailable-tooltip"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["tra","skin_purchase_unavailable_tooltip"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-tooltip"],null,[["tooltipPosition","type"],["top","system"]],0]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = (s = n(158)) && s.__esModule ? s : { default: s },
          a = n(152);
        const { RunMixin: r } = i.EmberAddons.EmberLifeline;
        n(297),
          (e.exports = i.Ember.Component.extend(r, {
            classNames: ["skin-select"],
            classNameBindings: ["showRerollButton:has-reroll"],
            layout: n(298),
            skinCarouselViewSkinId: void 0,
            parentSkinIdToSelectedChromaIdMap: {},
            skinLocked: i.Ember.computed("viewSkin.unlocked", function () {
              return !this.get("viewSkin.unlocked");
            }),
            init() {
              this._super(...arguments), this.initDataBindings();
            },
            didUpdateAttrs: function () {
              this._super(...arguments),
                this.get("timeRemaining") <
                  this.get("jmxSettings.LcuChampionSelect.SkinPurchaseTime") &&
                  this.get("inFinalization") &&
                  (i.sharedPayments.closePaymentsModal(),
                  i.PurchaseAnywhereApi.closePawModal());
            },
            initDataBindings: function () {
              (this._champSelectBinding = (0, i.DataBinding)(
                "/lol-champ-select",
                (0, i.getProvider)().getSocket(),
              )),
                this._champSelectBinding.observe(
                  "/v1/skin-selector-info",
                  this,
                  this.handleSkinSelectorInfo,
                ),
                this._champSelectBinding.observe(
                  "/v1/skin-carousel-skins",
                  this,
                  this.handleSkinCarouselSkins,
                );
            },
            handleSkinCarouselSkins: function (e) {
              this.set(
                "carouselSkins",
                (e || []).filter((e) => !e.disabled),
              );
              const t = this.get("viewSkin.id")
                ? this.get("viewSkin.id")
                : this.get("selectedSkinId");
              let n = this.getSkin(t);
              n?.productType === a.skinProductTypes.kTieredSkin &&
                (n = this.getMostProgressedSkin(n)),
                this.setViewSkin(n),
                this.updateParentSkinIdToSelectedChromaIdMap(n);
            },
            handleSkinSelectorInfo: function (e) {
              const t = this.getSkin(e && e.selectedSkinId);
              this.setProperties(e),
                this.setViewSkin(t),
                this.updateParentSkinIdToSelectedChromaIdMap(t);
            },
            getSkin: function (e) {
              const t = this.get("carouselSkins") || [];
              for (let n = 0; n < t.length; n++) {
                const s = t[n];
                if (s.id === e) return s;
                const i = (s.childSkins || []).find((t) => t.id === e);
                if (i && i.id) return i;
              }
            },
            setViewSkin: function (e) {
              this.set("viewSkin", e),
                e !== this.get("rootViewSkin") &&
                  this.sendAction("selectViewSkin", e);
            },
            requestSetSkin: function (e) {
              o.default
                .ajax({
                  url: "/lol-champ-select/v1/session/my-selection",
                  contentType: "application/json",
                  data: JSON.stringify({ selectedSkinId: e.id }),
                  method: "PATCH",
                  errorMessage: "error_could_not_set_skin",
                })
                .then(() => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0),
                    i.Telemetry.endTracingEvent("champ-select-skin-select");
                })
                .catch((e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e);
                });
            },
            updateParentSkinIdToSelectedChromaIdMap(e) {
              if (!e) return;
              const t = e.parentSkinId || e.id;
              this.parentSkinIdToSelectedChromaIdMap[t] = e.id;
            },
            getSelectedChromaForSkin: function (e) {
              return e &&
                this.parentSkinIdToSelectedChromaIdMap[e.id] &&
                this.parentSkinIdToSelectedChromaIdMap[e.id] !== e.id
                ? this.getSkin(this.parentSkinIdToSelectedChromaIdMap[e.id])
                : e;
            },
            setSkin: function (e) {
              this.get("allowSkinSelection") &&
                (i.Telemetry.startTracingEvent("champ-select-skin-select"),
                this.setViewSkin(e),
                e.unlocked &&
                  e.id !== this.get("selectedSkinId") &&
                  this.debounceTask("requestSetSkin", e, 500));
            },
            getMostProgressedSkin: function (e) {
              const t = e?.childSkins?.find?.(
                  (e) => this.get("viewSkin.skinId") === e.id,
                ),
                n =
                  e?.childSkins?.filter?.((e) => e?.ownership?.owned).pop() ??
                  e?.childSkins?.[0];
              return t?.id !== n?.id && this.setSkin(n), n;
            },
            actions: {
              setSkinThroughChromaModal: function (e) {
                e.productType === a.skinProductTypes.kTieredSkin
                  ? (e = this.getMostProgressedSkin(e))
                  : this.updateParentSkinIdToSelectedChromaIdMap(e),
                  this.setSkin(e);
              },
              setSkinThroughScroll: function (e) {
                (e =
                  e.productType === a.skinProductTypes.kTieredSkin
                    ? this.getMostProgressedSkin(e)
                    : this.getSelectedChromaForSkin(e)),
                  this.setSkin(e);
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "vNRV3ui4",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-select-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-select-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\skin-select-component\\\\index.js\\" "],["text","\\n\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",[["helper",["if"],[["get",["isShowingGrid"]],"hidden"],null]]]],["flush-element"],["text","\\n  "],["append",["helper",["skin-name"],null,[["skin","shouldShowChestAvailability","championChestAvailabilityMap"],[["get",["viewSkin"]],["get",["shouldShowChestAvailability"]],["get",["championChestAvailabilityMap"]]]]],false],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["skin-carousel-visibility-wrapper ",["helper",["if"],[["get",["skinSelectionDisabled"]],"hidden","visible"],null]]]],["flush-element"],["text","\\n    "],["append",["helper",["skin-carousel"],null,[["carouselSkins","selectedSkinId","selectedChampionId","championName","allowSkinSelection","isSkinGrantedFromBoost","disabled","jmxSettings","map","rootComponentShown","rootViewSkin","setSkinThroughScroll","setSkinThroughChromaModal","uxSettings","viewSkin","ip","rp","timer","isSkinSelectVisible","UseNewLoyaltyIcon","parentSkinIdToSelectedChromaIdMap"],[["get",["carouselSkins"]],["get",["selectedSkinId"]],["get",["selectedChampionId"]],["get",["championName"]],["get",["allowSkinSelection"]],["get",["isSkinGrantedFromBoost"]],["get",["isUILockedForGameStart"]],["get",["jmxSettings"]],["get",["map"]],["get",["rootComponentShown"]],["get",["rootViewSkin"]],"setSkinThroughScroll","setSkinThroughChromaModal",["get",["uxSettings"]],["get",["viewSkin"]],["get",["ip"]],["get",["rp"]],["get",["timer"]],["get",["isSkinSelectVisible"]],["get",["UseNewLoyaltyIcon"]],["get",["parentSkinIdToSelectedChromaIdMap"]]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["block",["if"],[["get",["showRerollButton"]]],null,0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["append",["helper",["reroll-button"],null,[["summoner","tbAllowRerolling","tbRerollsRemaining","disabled","recordDidRequestSucceed"],[["get",["summoner"]],["get",["tbAllowRerolling"]],["get",["tbRerollsRemaining"]],["get",["rerollsDisabled"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = n(212),
          o = n(152);
        n(300);
        const { RunMixin: a } = s.EmberAddons.EmberLifeline,
          r = s.UiKitPlugin.getTemplateHelper(),
          l = "championTradeToggleTooltipSeen",
          c = ".summoner-object.left:not(.is-self) .champion-icons .svg-icon",
          u = "positionSwapToggleTooltipSeen",
          m = ".position-swap-button";
        e.exports = s.Ember.Component.extend(a, {
          layout: n(301),
          classNames: ["summoner-array"],
          classNameBindings: [
            "isLeft:your-party:enemy-party",
            "showChestAvailabilityHintedPortraits:show-chest-availability-hinted-portraits",
            "shouldAlignTop:align-summoners-top",
          ],
          settingsService: (0, s.DataBinding)(
            "/lol-settings",
            (0, s.getProvider)().getSocket(),
          ),
          init: function () {
            this._super(...arguments),
              this.get("settingsService").observe(
                "/v2/ready",
                this,
                this.handleSettingsReady,
              );
          },
          didUpdateAttrs: function () {
            this._super(...arguments),
              this.tooltipSettingsReady &&
                this.shouldShowChampTradeTooltip() &&
                this.initChampTradeTooltip(),
              this.tooltipSettingsReady &&
                this.get("pickOrderSwappingEnabled") &&
                this.shouldShowPickOrderSwapTooltip() &&
                this.initPickOrderSwapTooltip();
          },
          shouldShowChampTradeTooltip: function () {
            return (
              this.get("isLeft") &&
              !this.champTradeTooltipShown &&
              this.get("timer.inFinalizationPhase") &&
              !this.get("isCustomGame") &&
              !this.get("showPositionAssignment") &&
              this.get("ChampTradingTooltipEnabled") &&
              this.get("team.length") > 1
            );
          },
          shouldShowPickOrderSwapTooltip: function () {
            return (
              this.get("isLeft") &&
              !this.positionSwapTooltipShown &&
              this.get("timer.inBanPickPhase") &&
              !this.get("isCustomGame") &&
              !this.get("showPositionAssignment") &&
              this.get("PickOrderSwappingTooltipEnabled") &&
              this.get("team.length") > 1
            );
          },
          handleChampSelectSummoner: function (e, t) {
            this.summonerBySlotId[t].setProperties(e);
          },
          handleSettingsReady: function (e) {
            this.tooltipSettingsReady = e;
          },
          initChampTradeTooltip: function () {
            return (0, i.getAccountSetting)(l).then((e) => {
              const t = Boolean(e && e.value);
              if (
                (this.assignChampTradeTooltip(),
                (this.champTradeTooltipShown = !0),
                !t)
              )
                return (
                  this.showChampTradeTooltip(), (0, i.saveAccountSetting)(l, !0)
                );
            });
          },
          showChampTradeTooltip: function () {
            const e = this.element.querySelector(c);
            e &&
              (s.TooltipManager.show(e),
              this.runTask(() => {
                s.TooltipManager.hide(e),
                  this.runTask(() => {
                    const e = this.get("tooltipTitleElement");
                    e && e.classList.add("hidden");
                  }, 500);
              }, 1e4));
          },
          assignChampTradeTooltip: function () {
            const e = this.element.querySelector(c);
            if (!e) return;
            this.set("tooltipContainerElement", e);
            const t = document.createElement("lol-uikit-tooltip"),
              n = r.contentBlockTooltipAttention(
                this.get("tra.champ_trade_new_tooltip"),
              ),
              i = document.createElement("div");
            (i.innerHTML = this.get("tra.champ_trade_tooltip_header")),
              (i.className = ".champ-trade-tooltip-title"),
              this.set("tooltipTitleElement", i),
              n.prepend(i),
              t.appendChild(n),
              s.TooltipManager.assign(e, t, null, {
                type: "attention",
                targetAnchor: { x: "right", y: "center" },
                tooltipAnchor: { x: "left", y: "center" },
                offset: { x: 14, y: 0 },
              }),
              s.TooltipManager.hide(e);
          },
          initPickOrderSwapTooltip: function () {
            return (0, i.getAccountSetting)(u).then((e) => {
              const t = Boolean(e && e.value);
              if (
                (this.assignPickOrderSwapTooltip(),
                (this.positionSwapTooltipShown = !0),
                !t)
              )
                return (
                  this.showPickOrderSwapTooltip(),
                  (0, i.saveAccountSetting)(u, !0)
                );
            });
          },
          showPickOrderSwapTooltip: function () {
            const e = this.element.querySelector(m);
            e &&
              (s.TooltipManager.show(e),
              this.runTask(() => {
                s.TooltipManager.hide(e),
                  this.runTask(() => {
                    const e = this.get("tooltipTitleElement");
                    e && e.classList.add("hidden");
                  }, 500);
              }, 1e4));
          },
          assignPickOrderSwapTooltip: function () {
            const e = this.element.querySelector(m);
            if (!e) return;
            this.set("tooltipContainerElement", e);
            const t = document.createElement("lol-uikit-tooltip"),
              n = r.contentBlockTooltipAttention(
                this.get("tra.position_swap_new_tooltip"),
              ),
              i = document.createElement("div");
            (i.innerHTML = this.get("tra.pick_order_swap_tooltip_header")),
              (i.className = ".pick-order-swapping-tooltip-title"),
              this.set("tooltipTitleElement", i),
              n.prepend(i),
              t.appendChild(n),
              s.TooltipManager.assign(e, t, null, {
                type: "attention",
                targetAnchor: { x: "right", y: "center" },
                tooltipAnchor: { x: "left", y: "center" },
                offset: { x: 14, y: 0 },
              }),
              s.TooltipManager.hide(e);
          },
          shouldShow: s.Ember.computed.or("isLeft", "timer.notInPlanningPhase"),
          timerCellId: s.Ember.computed(
            "timer.inPlanningPhase",
            "currentSummoner.cellId",
            "sessionActions.allPlayersActTogether",
            "sessionActions.currentActingCells",
            "thisTeamActiveCells",
            function () {
              const e = this.get("timer.inPlanningPhase"),
                t = this.get("thisTeamMinCellId");
              if (e || this.get("sessionActions.allPlayersActTogether"))
                return this.get("currentSummoner.cellId") - t;
              const n = this.get("thisTeamActiveCells");
              if (!n || !n.length) return 0;
              return n.map((e) => e - t).reduce((e, t) => e + t, 0) / n.length;
            },
          ),
          hasActiveAction: s.Ember.computed.notEmpty(
            "sessionActions.activeAction",
          ),
          inFinalizationPhase: s.Ember.computed.alias(
            "timer.inFinalizationPhase",
          ),
          notMyTeam: s.Ember.computed.not("isLeft"),
          thisTeamCellIds: s.Ember.computed.map("team", function (e) {
            return e.get("cellId");
          }),
          thisTeamMinCellId: s.Ember.computed("thisTeamCellIds", function () {
            return Math.min.apply(null, this.get("thisTeamCellIds"));
          }),
          thisTeamActiveCells: s.Ember.computed(
            "sessionActions.currentActingCells",
            "thisTeamCellIds",
            function () {
              const e = this.get("thisTeamCellIds"),
                t = this.get("sessionActions.currentActingCells");
              return e && t ? t.filter((t) => e.includes(t)) : [];
            },
          ),
          pickOrderSwappingEnabled: s.Ember.computed(
            "timer.inPlanningPhase",
            "timer.inBanPickPhase",
            "timerDisabledPickOrderSwap",
            "showPositionAssignment",
            "currentSummoner.isDonePicking",
            function () {
              return (
                (this.get("timer.inPlanningPhase") ||
                  this.get("timer.inBanPickPhase")) &&
                !this.get("timerDisabledPickOrderSwap") &&
                !this.get("showPositionAssignment") &&
                !this.get("currentSummoner.isDonePicking")
              );
            },
          ),
          inPlanningButNotMyTeam: s.Ember.computed.and(
            "timer.inPlanningPhase",
            "notMyTeam",
          ),
          inBanPickSimulButNotMyTeam: s.Ember.computed.and(
            "timer.inBanPickPhase",
            "notMyTeam",
            "sessionActions.allPlayersActTogether",
          ),
          thisTeamHasNoActiveAction: s.Ember.computed(
            "timer.inBanPickPhase",
            "thisTeamActiveCells.length",
            "hasActiveAction",
            function () {
              return (
                this.get("timer.inBanPickPhase") &&
                (!this.get("thisTeamActiveCells.length") ||
                  !this.get("hasActiveAction"))
              );
            },
          ),
          simulActAndMyActionComplete: s.Ember.computed(
            "sessionActions.allPlayersActTogether",
            "currentSummoner.isActingNow",
            function () {
              return (
                this.get("sessionActions.allPlayersActTogether") &&
                !this.get("currentSummoner.isActingNow")
              );
            },
          ),
          hideSummonerTimer: s.Ember.computed(
            "showPositionAssignment",
            "isPlayingSimulBanOutro",
            "timer.inBanPickPhase",
            "timer.inPlanningPhase",
            "inPlanningButNotMyTeam",
            "inBanPickSimulButNotMyTeam",
            "thisTeamHasNoActiveAction",
            "simulActAndMyActionComplete",
            function () {
              return (
                this.get("showPositionAssignment") ||
                this.get("isPlayingSimulBanOutro") ||
                !(
                  this.get("timer.inBanPickPhase") ||
                  this.get("timer.inPlanningPhase")
                ) ||
                this.get("inPlanningButNotMyTeam") ||
                this.get("inBanPickSimulButNotMyTeam") ||
                this.get("thisTeamHasNoActiveAction") ||
                this.get("simulActAndMyActionComplete") ||
                !!this.get("subteamDataList")
              );
            },
          ),
          shouldAlignTop: s.Ember.computed(
            "shouldUseSubteamLayout",
            "summoners.length",
            "summoners.@each.isPlaceholder",
            function () {
              const e = this.get("summoners").filter(
                (e) => !e.isPlaceholder,
              ).length;
              return (
                this.get("shouldUseSubteamLayout") ||
                e > o.STANDARD_MAX_TEAM_SIZE
              );
            },
          ),
          shouldUseSubteamLayout: s.Ember.computed(
            "subteamDataList",
            "isLeft",
            function () {
              return !this.get("isLeft") && !!this.get("subteamDataList");
            },
          ),
          subteamsCurrentActionTypeHeader: s.Ember.computed(
            "isLeft",
            "summoners.length",
            "sessionActions.someoneIsBanning",
            function () {
              return !this.get("isLeft") && this.get("summoners.length") > 0
                ? this.get("sessionActions.someoneIsBanning")
                  ? this.get("tra").get("banning_champion")
                  : this.get("tra").get("picking_champion")
                : null;
            },
          ),
          subteamsSummonersData: s.Ember.computed(
            "summoners",
            "summoners.@each.cellId",
            "subteamDataList",
            function () {
              const e = this.get("summoners").reduce(
                  (e, t) => ((e[t.cellId] = t), e),
                  {},
                ),
                t = this.get("tra");
              return this.get("subteamDataList")
                .map((n) => ({
                  summoners: n.cellIds
                    .map((t) => e[t])
                    .filter((e) => !!e && !e.isPlaceholder),
                  subteamIconPath: n.display.icon,
                  subteamLabel: t.get(n.display.label),
                }))
                .filter((e) => !!e.summoners.length);
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "hmon4KUA",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-array-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-array-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-array-component\\\\index.js\\" "],["text","\\n"],["open-element","span",[]],["dynamic-attr","class",["concat",["first-pick ",["helper",["if"],[["get",["showFirstPick"]],"visible","removed"],null]]]],["flush-element"],["append",["unknown",["tra","first_pick"]],false],["close-element"],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["party ",["helper",["if"],[["get",["shouldShow"]],"visible","hidden"],null]]]],["flush-element"],["text","\\n"],["block",["if"],[["get",["shouldUseSubteamLayout"]]],null,6,1],["text","  "],["open-element","div",[]],["static-attr","class","summoner-timer-wrapper"],["flush-element"],["text","\\n    "],["append",["helper",["summoner-timer"],null,[["isInfinite","timerCellId","hideSummonerTimer","formattedTime","isMyTeam"],[["get",["timer","isInfinite"]],["get",["timerCellId"]],["get",["hideSummonerTimer"]],["get",["formattedTime"]],["get",["isLeft"]]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-wrapper ",["helper",["if"],[["get",["summoner","isPlaceholder"]],"removed","visible"],null]," ",["helper",["if"],[["get",["isLeft"]],"left","right"],null]]]],["flush-element"],["text","\\n        "],["open-element","div",[]],["dynamic-attr","class",["concat",["lines ",["helper",["if"],[["get",["showPositionAssignment"]],"hidden","visible"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["append",["helper",["summoner-object"],null,[["team","summoner","currentSummonerChampionName","pickOrderSwappingEnabled","inFinalizationPhase","activeSwap","activeTrade","summonerId","subteamDataList","uxSettings","jmxSettings","showPositionAssignment","isLeft","viewSkin","championChestAvailabilityMap","shouldShowChestAvailability","boosterSummonerId","isUILockedForGameStart","isCustomGame","recordDidRequestSucceed"],[["get",["team"]],["get",["summoner"]],["get",["currentSummoner","champion","name"]],["get",["pickOrderSwappingEnabled"]],["get",["inFinalizationPhase"]],["get",["activeSwap"]],["get",["activeTrade"]],["get",["summoner","summonerId"]],["get",["subteamDataList"]],["get",["uxSettings"]],["get",["jmxSettings"]],["get",["showPositionAssignment"]],["get",["isLeft"]],["get",["viewSkin"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]],["get",["boosterSummonerId"]],["get",["isUILockedForGameStart"]],["get",["isCustomGame"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n      "],["close-element"],["text","\\n"]],"locals":["summoner"]},{"statements":[["block",["each"],[["get",["summoners"]]],null,0]],"locals":[]},{"statements":[["text","          "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-wrapper ",["helper",["if"],[["get",["summoner","isPlaceholder"]],"removed","visible"],null]," ",["helper",["if"],[["get",["isLeft"]],"left","right"],null]]]],["flush-element"],["text","\\n            "],["open-element","div",[]],["dynamic-attr","class",["concat",["lines ",["helper",["if"],[["get",["showPositionAssignment"]],"hidden","visible"],null]]]],["flush-element"],["close-element"],["text","\\n            "],["append",["helper",["summoner-object"],null,[["team","summoner","currentSummonerChampionName","pickOrderSwappingEnabled","inFinalizationPhase","activeSwap","activeTrade","summonerId","subteamDataList","uxSettings","jmxSettings","showPositionAssignment","isLeft","showChampionIconTooltip","viewSkin","championChestAvailabilityMap","shouldShowChestAvailability","boosterSummonerId","isUILockedForGameStart","isCustomGame","recordDidRequestSucceed"],[["get",["team"]],["get",["summoner"]],["get",["currentSummoner","champion","name"]],["get",["pickOrderSwappingEnabled"]],["get",["inFinalizationPhase"]],["get",["activeSwap"]],["get",["activeTrade"]],["get",["summoner","summonerId"]],["get",["subteamDataList"]],["get",["uxSettings"]],["get",["jmxSettings"]],["get",["showPositionAssignment"]],["get",["isLeft"]],true,["get",["viewSkin"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]],["get",["boosterSummonerId"]],["get",["isUILockedForGameStart"]],["get",["isCustomGame"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n          "],["close-element"],["text","\\n"]],"locals":["summoner"]},{"statements":[["text","            "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","padding","small"],["flush-element"],["text","\\n              "],["open-element","p",[]],["flush-element"],["append",["unknown",["subteamSummonersData","subteamLabel"]],false],["close-element"],["text","\\n            "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","div",[]],["static-attr","class","subteam-summoners-wrapper"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon-wrapper"],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["top","whole-window"]],3],["text","          "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon-arrow"],["flush-element"],["close-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon"],["dynamic-attr","style",["concat",["background-image: url(",["unknown",["subteamSummonersData","subteamIconPath"]],");"]]],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n"],["block",["each"],[["get",["subteamSummonersData","summoners"]]],null,2],["text","      "],["close-element"],["text","\\n"]],"locals":["subteamSummonersData"]},{"statements":[["text","      "],["open-element","div",[]],["static-attr","class","subteams-current-action-type-header"],["flush-element"],["append",["unknown",["subteamsCurrentActionTypeHeader"]],false],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["if"],[["get",["subteamsCurrentActionTypeHeader"]]],null,5],["block",["each"],[["get",["subteamsSummonersData"]]],null,4]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = a(n(158)),
          o = a(n(164));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        n(303);
        const { DomMixin: r } = s.EmberAddons.EmberLifeline,
          l = "COMMS_ABUSE_TEXT",
          c = [l, "SABOTAGING_TEAM", "DISRESPECTFUL_BEHAVIOR", "OTHER"],
          u = n(304)[0][1],
          m = s.UiKitPlugin.getContextMenuManager();
        e.exports = s.Ember.Component.extend(r, o.default, {
          layout: n(307),
          classNames: ["summoner-overlay"],
          classNameBindings: ["isContextMenuOpened:show"],
          chatPublisherService: s.Ember.inject.service("chat-publisher"),
          playerReportService: s.Ember.inject.service("player-report"),
          hasReported: !1,
          isContextMenuOpened: !1,
          init: function () {
            this._super(...arguments),
              (this._contextMenuCloseListener = () =>
                this.set("isContextMenuOpened", !1)),
              m.addCloseListener(this._contextMenuCloseListener);
          },
          willDestroyElement() {
            this._super(...arguments),
              m.removeCloseListener(this._contextMenuCloseListener);
          },
          didReceiveAttrs: function () {
            this._super(...arguments);
            const e = this.get("displayName"),
              t = this.get("puuid"),
              n = this.get("obfuscatedPuuid");
            (e === this._prevDisplayName &&
              t === this._prevPuuid &&
              n === this._prevObfuscatedPuuid) ||
              this.set("hasReported", !1),
              (this._prevDisplayName = e),
              (this._prevPuuid = t),
              (this._prevObfuscatedPuuid = n);
          },
          reportButtonTooltipDescription: s.Ember.computed(
            "hasReported",
            function () {
              return this.get("hasReported")
                ? this.get("tra.csr_button_report_sent")
                : this.get("tra.csr_button_report_description");
            },
          ),
          reportMenuItems: s.Ember.computed(
            "displayName",
            "puuid",
            "obfuscatedPuuid",
            "jmxSettings.LcuChampionSelect.ReportCategories",
            function () {
              const e = [],
                t =
                  this.get("jmxSettings.LcuChampionSelect.ReportCategories") ||
                  c;
              e.push({
                element: this._createMenuHeaderElement(this.get("displayName")),
                disabled: !0,
              });
              for (let n = 0; n < t.length; n++)
                e.push({
                  action: function () {
                    this.send("submitReport", t[n]);
                  },
                  target: this,
                  element: this._createMenuItemElement(
                    t[n],
                    n === t.length - 1,
                  ),
                });
              return e;
            },
          ),
          _createMenuHeaderElement(e) {
            const t = document.createElement("div");
            t.classList.add("context-menu-header");
            const n = document.createElement("div");
            n.classList.add("title"),
              (n.innerHTML = this.get("tra").formatString(
                "csr_context_menu_header",
                { name: e },
              ));
            const s = document.createElement("div");
            return (
              s.classList.add("separator"),
              t.appendChild(n),
              t.appendChild(s),
              t
            );
          },
          _createMenuItemElement(e, t) {
            const n = document.createElement("div");
            n.classList.add("context-menu-item");
            const s = document.createElement("div");
            s.classList.add("title");
            const i = (e || "").toLowerCase();
            if (
              ((s.innerHTML = this.get(`tra.csr_report_category_${i}`)),
              n.appendChild(s),
              !t)
            ) {
              const e = document.createElement("div");
              e.classList.add("separator"), n.appendChild(e);
            }
            return n;
          },
          actions: {
            toggleMute() {
              const e = this.get("isMuted"),
                t = e ? "csr_unmuted" : "csr_muted",
                n = this.get("tra").formatString(t, {
                  name: this.get("displayName"),
                });
              this.get("chatPublisherService").sendChatMessage(n);
              const o = this.get("summonerId"),
                a = this.get("puuid") || "",
                r = this.get("obfuscatedSummonerId"),
                l = this.get("obfuscatedPuuid") || "";
              return (
                s.Telemetry.sendEvent(
                  "champ_select_toggle_player_muted_clicked",
                  e ? 1 : 0,
                ),
                i.default
                  .ajax({
                    type: "POST",
                    contentType: "application/json",
                    url: "/lol-champ-select/v1/toggle-player-muted",
                    data: JSON.stringify({
                      summonerId: o,
                      puuid: a,
                      obfuscatedSummonerId: r,
                      obfuscatedPuuid: l,
                    }),
                    errorMessage: t + "_error",
                  })
                  .then(() => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!0);
                  })
                  .catch((e) => {
                    this.recordDidRequestSucceed &&
                      this.recordDidRequestSucceed(!1, e);
                  })
              );
            },
            showReportContextMenu() {
              if (this.get("hasReported")) return;
              const e = this.get("reportMenuItems");
              e &&
                e.length &&
                (m.setCustomMenuItems(e, {
                  css: u,
                  menuClass: "champ-select-reporting-menu",
                }),
                m.openAtEvent(event),
                this.set("isContextMenuOpened", !0));
            },
            submitReport(e) {
              const t = this.get("playerReportService"),
                n = this.get("isMuted");
              if (!t || !t.sendPlayerReport) return;
              const s = this.get("tra").formatString("csr_report_submitted", {
                  name: this.get("displayName"),
                }),
                i = {
                  offenderPuuid: this.get("puuid"),
                  obfuscatedOffenderPuuid: this.get("obfuscatedPuuid"),
                  gameId: this.get("session.gameId"),
                  categories: [e],
                  offenderSummonerId: this.get("summonerId"),
                };
              t.sendPlayerReport(i).then(
                () => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0),
                    this.get("chatPublisherService").sendChatMessage(s),
                    this.set("hasReported", !0);
                },
                (e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e);
                },
              ),
                e !== l || n || this.send("toggleMute");
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        var s = n(305),
          i = n(306)(s);
        i.push([
          e.id,
          '.champ-select-reporting-menu .context-menu-header .title h5 {\n  font-family: var(--font-display);\n}\n.champ-select-reporting-menu .context-menu-header,\n.champ-select-reporting-menu .context-menu-item {\n  font-family: var(--font-body);\n}\n.champ-select-reporting-menu .context-menu-header,\n.champ-select-reporting-menu .context-menu-header .title h5,\n.champ-select-reporting-menu .context-menu-item {\n  -webkit-user-select: none;\n}\n.champ-select-reporting-menu .context-menu-header,\n.champ-select-reporting-menu .context-menu-header .title h5,\n.champ-select-reporting-menu .context-menu-item {\n  font-kerning: normal;\n  -webkit-font-feature-settings: "kern" 1;\n  -webkit-font-smoothing: antialiased;\n}\n.champ-select-reporting-menu .context-menu-header .title h5 {\n  text-transform: uppercase;\n}\n.champ-select-reporting-menu .context-menu-header .title h5:lang(ko-kr),\n.champ-select-reporting-menu .context-menu-header .title h5:lang(ja-jp),\n.champ-select-reporting-menu .context-menu-header .title h5:lang(tr-tr),\n.champ-select-reporting-menu .context-menu-header .title h5:lang(el-gr),\n.champ-select-reporting-menu .context-menu-header .title h5:lang(th-th),\n.champ-select-reporting-menu .context-menu-header .title h5:lang(zh-tw) {\n  text-transform: none;\n}\n.champ-select-reporting-menu .context-menu-header .title h5 {\n  color: #f0e6d2;\n  font-size: 14px;\n  font-weight: 700;\n  line-height: 18px;\n  letter-spacing: 0.075em;\n}\n.champ-select-reporting-menu .context-menu-header .title h5:lang(ar-ae) {\n  letter-spacing: 0;\n}\n.champ-select-reporting-menu .context-menu-header,\n.champ-select-reporting-menu .context-menu-item {\n  color: #a09b8c;\n  font-size: 12px;\n  font-weight: normal;\n  line-height: 16px;\n  letter-spacing: 0.025em;\n  -webkit-font-smoothing: subpixel-antialiased;\n}\n.champ-select-reporting-menu .context-menu-header:lang(ja-jp),\n.champ-select-reporting-menu .context-menu-item:lang(ja-jp) {\n  font-size: 13px;\n}\n.champ-select-reporting-menu .context-menu-header:lang(ar-ae),\n.champ-select-reporting-menu .context-menu-item:lang(ar-ae) {\n  letter-spacing: 0;\n}\n.champ-select-reporting-menu {\n  user-select: none;\n  -webkit-user-select: none;\n  cursor: default;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  min-width: 127px;\n  z-index: 10;\n  box-sizing: border-box;\n  background-color: #010a13;\n  box-shadow: 0 0 1px #000, 0 0 1px #000;\n  border: 1px solid #463714;\n  outline: none;\n}\n.champ-select-reporting-menu:lang(ar-ae) {\n  direction: rtl;\n}\n.champ-select-reporting-menu .context-menu-header {\n  padding-left: 10px;\n  min-width: calc(100% - 10px);\n  width: -webkit-max-content;\n}\n.champ-select-reporting-menu .context-menu-header:lang(ar-ae) {\n  padding-left: 0px;\n  padding-right: 10px;\n}\n.champ-select-reporting-menu .context-menu-header .title {\n  color: #f0e6d2;\n  display: inline-block;\n  padding: 10px 10px 2px 0;\n}\n.champ-select-reporting-menu .context-menu-header .title:lang(ar-ae) {\n  padding: 10px 0px 2px 10px;\n}\n.champ-select-reporting-menu .context-menu-header .title h5 {\n  margin: 0;\n  white-space: nowrap;\n}\n.champ-select-reporting-menu .context-menu-header .separator {\n  border: 0;\n  height: 1px;\n  background-color: #1e2328;\n  margin: 5px 0 0 -10px;\n}\n.champ-select-reporting-menu .context-menu-header .separator:lang(ar-ae) {\n  margin: 5px -10px 0 0;\n}\n.champ-select-reporting-menu .context-menu-item {\n  display: block;\n  outline: none;\n  min-width: 100%;\n  width: -webkit-max-content;\n  height: 30px;\n  line-height: 30px;\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0 10px;\n  border: none;\n  background: none;\n  white-space: nowrap;\n  overflow: visible;\n  text-overflow: ellipsis;\n  text-align: left;\n  position: relative;\n}\n.champ-select-reporting-menu .context-menu-item:lang(ar-ae) {\n  text-align: right;\n}\n.champ-select-reporting-menu .context-menu-item .title {\n  color: #a09b8c;\n}\n.champ-select-reporting-menu .context-menu-item div {\n  vertical-align: middle;\n}\n.champ-select-reporting-menu .context-menu-item .separator {\n  border: 0;\n  height: 1px;\n  background-color: #1e2328;\n  margin: 0 -10px 0 -10px;\n}\n.champ-select-reporting-menu .context-menu-item:not(.disabled):hover {\n  background: #1e2328;\n  color: #f0e6d2;\n  cursor: pointer;\n}\n.champ-select-reporting-menu .context-menu-item:active {\n  color: #cdbe91;\n}\n',
          "",
        ]),
          (e.exports = i);
      },
      (e) => {
        "use strict";
        e.exports = function (e) {
          return e[1];
        };
      },
      (e) => {
        "use strict";
        e.exports = function (e) {
          var t = [];
          return (
            (t.toString = function () {
              return this.map(function (t) {
                var n = "",
                  s = void 0 !== t[5];
                return (
                  t[4] && (n += "@supports (".concat(t[4], ") {")),
                  t[2] && (n += "@media ".concat(t[2], " {")),
                  s &&
                    (n += "@layer".concat(
                      t[5].length > 0 ? " ".concat(t[5]) : "",
                      " {",
                    )),
                  (n += e(t)),
                  s && (n += "}"),
                  t[2] && (n += "}"),
                  t[4] && (n += "}"),
                  n
                );
              }).join("");
            }),
            (t.i = function (e, n, s, i, o) {
              "string" == typeof e && (e = [[null, e, void 0]]);
              var a = {};
              if (s)
                for (var r = 0; r < this.length; r++) {
                  var l = this[r][0];
                  null != l && (a[l] = !0);
                }
              for (var c = 0; c < e.length; c++) {
                var u = [].concat(e[c]);
                (s && a[u[0]]) ||
                  (void 0 !== o &&
                    (void 0 === u[5] ||
                      (u[1] = "@layer"
                        .concat(u[5].length > 0 ? " ".concat(u[5]) : "", " {")
                        .concat(u[1], "}")),
                    (u[5] = o)),
                  n &&
                    (u[2]
                      ? ((u[1] = "@media "
                          .concat(u[2], " {")
                          .concat(u[1], "}")),
                        (u[2] = n))
                      : (u[2] = n)),
                  i &&
                    (u[4]
                      ? ((u[1] = "@supports ("
                          .concat(u[4], ") {")
                          .concat(u[1], "}")),
                        (u[4] = i))
                      : (u[4] = "".concat(i))),
                  t.push(u));
              }
            }),
            t
          );
        };
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "8DgoTCbk",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-overlay-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-overlay-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-overlay-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","summoner-overlay-background"],["flush-element"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","summoner-overlay-buttons-container"],["flush-element"],["text","\\n  "],["open-element","button",[]],["dynamic-attr","class",["concat",["overlay-button ",["helper",["unless"],[["get",["jmxSettings","LcuChampionSelect","ChampSelectMutingEnabled"]],"removed"],null]," ",["helper",["if"],[["get",["isMuted"]],"unmute","mute"],null]]]],["modifier",["action"],[["get",[null]],"toggleMute"]],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["type","tooltipPosition"],["system","top"]],1],["text","  "],["close-element"],["text","\\n\\n  "],["open-element","button",[]],["dynamic-attr","class",["concat",["overlay-button report ",["helper",["unless"],[["get",["isReportingEnabled"]],"removed"],null]," ",["helper",["if"],[["get",["hasReported"]],"disabled"],null]]]],["modifier",["action"],[["get",[null]],"showReportContextMenu"]],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["type","tooltipPosition"],["system","top"]],0],["text","  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["reportButtonTooltipDescription"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["helper",["if"],[["get",["isMuted"]],["get",["tra","csr_button_unmute_description"]],["get",["tra","csr_button_mute_description"]]],null],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(1),
          o = (s = n(309)) && s.__esModule ? s : { default: s };
        n(310);
        e.exports = i.Ember.Component.extend({
          layout: n(311),
          classNames: ["summoner-object"],
          classNameBindings: [
            "isLeft:left:right",
            "isPickingNow:is-picking-now",
            "summoner.isSelf",
            "isBanningNow:is-banning-now",
            "summoner.areSummonerActionsComplete:actions-complete",
            "showIntroAnimation:intro-animation",
            "summoner.pickSnipedClass",
            "summoner.shouldShowSelectedSkin:skin-showcase-active",
            "slotIdClass",
          ],
          summonerInfoService: i.Ember.inject.service("summoner-info"),
          didReceiveAttrs: function () {
            this._super(...arguments);
          },
          displayName: i.Ember.computed.alias("summoner.displayName"),
          summonerId: i.Ember.computed.alias("summoner.summonerId"),
          isPickingNow: i.Ember.computed.equal(
            "summoner.activeActionType",
            "pick",
          ),
          isBanningNow: i.Ember.computed.equal(
            "summoner.activeActionType",
            "ban",
          ),
          showChampionIconTooltip: !1,
          slotIdClass: i.Ember.computed("summoner.slotId", function () {
            return `slot-id-${this.get("summoner.slotId")}`;
          }),
          showIntroAnimation: i.Ember.computed(
            "summoner.isPlaceholder",
            "isLeft",
            "showPositionAssignment",
            function () {
              return (
                this.get("isLeft") &&
                !this.get("summoner.isPlaceholder") &&
                this.get("showPositionAssignment")
              );
            },
          ),
          animateActingNowIntro: i.EmberHelpers.delayed(
            "summoner.isActingNow",
            600,
          ),
          showSummonerActing: i.Ember.computed(
            "animateActingNowIntro",
            "summoner.isActingNow",
            function () {
              return (
                this.get("animateActingNowIntro") &&
                this.get("summoner.isActingNow")
              );
            },
          ),
          summonerHasActiveSwap: i.Ember.computed(
            "activeSwap",
            "summoner.swapId",
            function () {
              const e = this.get("activeSwap");
              return (
                e && e.id && -1 !== e.id && e.id === this.get("summoner.swapId")
              );
            },
          ),
          summonerHasActiveTrade: i.Ember.computed(
            "activeTrade",
            "summoner.tradeId",
            function () {
              const e = this.get("activeTrade");
              return (
                e &&
                e.id &&
                -1 !== e.id &&
                e.id === this.get("summoner.tradeId")
              );
            },
          ),
          showPickOrderSwapButton: i.Ember.computed(
            "pickOrderSwappingEnabled",
            "summoner.showSwaps",
            "summoner.isDonePicking",
            "summonerHasActiveSwap",
            "isLeft",
            function () {
              return (
                (this.get("pickOrderSwappingEnabled") &&
                  this.get("summoner.showSwaps") &&
                  !this.get("summoner.isDonePicking") &&
                  this.get("isLeft")) ||
                this.get("summonerHasActiveSwap")
              );
            },
          ),
          showChampionTradeButton: i.Ember.computed(
            "summoner.isSelf",
            "inFinalizationPhase",
            function () {
              return (
                !this.get("summoner.isSelf") && this.get("inFinalizationPhase")
              );
            },
          ),
          voteProjectionText: i.Ember.computed(
            "summoner.currentChampionVotePercentInteger",
            function () {
              const e = this.get("summoner.currentChampionVotePercentInteger");
              return -1 === e
                ? ""
                : 100 === e
                  ? this.get("tra.summoner_team_vote_majority")
                  : this.get("tra").formatString(
                      "summoner_team_vote_percentage",
                      { percentage: e },
                    );
            },
          ),
          positionIconPath: i.Ember.computed(
            "summoner.assignedPosition",
            function () {
              const e = this.get("summoner.assignedPosition");
              if (e) {
                return `/fe/lol-champ-select/svg/position-${e}.svg`;
              }
              return null;
            },
          ),
          isDonePicking: i.Ember.computed.alias("summoner.isDonePicking"),
          statusText: i.Ember.computed(
            "summoner.statusMessageKey",
            function () {
              const e = this.get("summoner.statusMessageKey");
              return e ? this.get(`tra.${e}`) : "";
            },
          ),
          assignedPositionText: i.Ember.computed(
            "summoner.assignedPosition",
            function () {
              const e = this.get("summoner.assignedPosition");
              return e ? this.get(`tra.summoner_assigned_position_${e}`) : "";
            },
          ),
          summonerPrimaryText: i.Ember.computed(
            "isLeft",
            "statusText",
            "assignedPositionText",
            "isDonePicking",
            "summoner.championName",
            function () {
              const e = this.get("assignedPositionText"),
                t = this.get("summoner.championName") || "";
              return this.get("isDonePicking")
                ? t
                : this.get("isLeft")
                  ? "" !== e
                    ? e
                    : t
                  : "";
            },
          ),
          summonerSecondaryText: i.Ember.computed(
            "isLeft",
            "assignedPositionText",
            "statusText",
            "isDonePicking",
            function () {
              return this.get("isDonePicking")
                ? this.get("isLeft")
                  ? this.get("assignedPositionText")
                  : ""
                : this.get("statusText");
            },
          ),
          banMagicVideo: i.Ember.computed(
            "isLeft",
            "summoner.isSelf",
            function () {
              return this.get("summoner.isSelf")
                ? {
                    intro:
                      "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-gold-intro.webm",
                    idle: "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-gold-idle.webm",
                    outro:
                      "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-gold-outro.webm",
                  }
                : this.get("isLeft")
                  ? {
                      intro:
                        "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-blue-intro.webm",
                      idle: "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-blue-idle.webm",
                      outro:
                        "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-blue-outro.webm",
                    }
                  : {
                      intro:
                        "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-red-intro.webm",
                      idle: "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-red-idle.webm",
                      outro:
                        "fe/lol-champ-select/video/summoner-object/summoner-object-magic-action-red-outro.webm",
                    };
            },
          ),
          bright: i.Ember.computed(
            "showIntroAnimation",
            "summoner.isDonePicking",
            "isPickingNow",
            function () {
              return (
                this.get("showIntroAnimation") ||
                this.get("summoner.isDonePicking") ||
                this.get("isPickingNow")
              );
            },
          ),
          selectedSkin: i.Ember.computed(
            "summoner.skinId",
            "summoner.skinSplashPath",
            function () {
              return {
                splashPath: this.get("summoner.skinSplashPath"),
                id: this.get("summoner.skinId"),
              };
            },
          ),
          selfThrottledSelectedSkin: i.Ember.computed(
            "viewSkin.unlocked",
            "viewSkin",
            "selectedSkin",
            function () {
              return this.get("viewSkin.unlocked")
                ? this.get("viewSkin")
                : this.get("selectedSkin");
            },
          ),
          otherThrottledSelectedSkin: i.EmberHelpers.throttled(
            "selectedSkin",
            1e3,
          ),
          throttledSelectedSkin: i.Ember.computed(
            "summoner.isSelf",
            "selfThrottledSelectedSkin",
            "otherThrottledSelectedSkin",
            function () {
              return this.get("summoner.isSelf")
                ? this.get("selfThrottledSelectedSkin")
                : this.get("otherThrottledSelectedSkin");
            },
          ),
          skinShowcaseStyle: i.Ember.computed(
            "summoner.shouldShowSelectedSkin",
            "throttledSelectedSkin.id",
            "throttledSelectedSkin.splashPath",
            "summoner.cellId",
            "team.length",
            function () {
              const e = this.get("throttledSelectedSkin.splashPath");
              if (!this.get("summoner.shouldShowSelectedSkin")) return "";
              const t = (function (e, t) {
                const n = 80,
                  s = ((t - 1) * n) / 2 - 256 - e * n;
                return `-webkit-mask-position: 0 0, -1px ${s}px`;
              })(
                this.get("summoner.cellId") || 0,
                (this.get("team") || [null]).length,
              );
              return `${`background-image: url(${e})`}; ${t};${(function (e) {
                let t = "";
                const n = o.default[e];
                n &&
                  (n.x && (t += ` background-position-x: ${n.x};`),
                  n.y && (t += ` background-position-y: ${n.y};`));
                return t;
              })(this.get("throttledSelectedSkin.id"))}`;
            },
          ),
          isReportingEnabled: i.Ember.computed(
            "jmxSettings.LcuChampionSelect.ReportingEnabled",
            "isCustomGame",
            function () {
              return (
                this.get("jmxSettings.LcuChampionSelect.ReportingEnabled") &&
                !this.get("isCustomGame")
              );
            },
          ),
          shouldShowOverlay: i.Ember.computed(
            "jmxSettings.LcuChampionSelect.ChampSelectMutingEnabled",
            "isReportingEnabled",
            "summoner.isSelf",
            "summoner.isOnPlayersTeam",
            "summoner.cellId",
            "subteamDataList",
            function () {
              const e =
                this.get(
                  "jmxSettings.LcuChampionSelect.ChampSelectMutingEnabled",
                ) || this.get("isReportingEnabled");
              let t =
                !this.get("summoner.isSelf") &&
                this.get("summoner.isOnPlayersTeam") &&
                e;
              const n = this._getSubteamData(
                this.get("subteamDataList"),
                this.get("summoner.cellId"),
              );
              return n && (t &= n && n.isLocalSubteam), t;
            },
          ),
          championIconStyle: i.Ember.computed(
            "summoner.championIconStyle",
            function () {
              return this.get("summoner.championIconStyle");
            },
          ),
          showTeamBoostIcon: i.Ember.computed(
            "summonerId",
            "boosterSummonerId",
            function () {
              return (
                this.get("boosterSummonerId") &&
                this.get("summonerId") === this.get("boosterSummonerId")
              );
            },
          ),
          showChampionChestAvailable: i.Ember.computed(
            "shouldShowChestAvailability",
            "summoner.championId",
            "championChestAvailabilityMap",
            function () {
              const e = this.get("summoner.championId"),
                t = this.get("championChestAvailabilityMap");
              return (
                !!(this.get("shouldShowChestAvailability") && e && t) &&
                t.get(e + "")
              );
            },
          ),
          _getSubteamData: function (e, t) {
            if (!e) return !1;
            const n = e.find((e) => e.cellIds.includes(t));
            return n || !1;
          },
          showSubteamIcon: i.Ember.computed(
            "summoner.cellId",
            "subteamDataList",
            "isLeft",
            function () {
              if (!this.get("isLeft")) return !1;
              const e = this.get("summoner.cellId"),
                t = this._getSubteamData(this.get("subteamDataList"), e);
              return !!t && t.cellIds.indexOf(e) === t.cellIds.length - 1;
            },
          ),
          subteamIconPath: i.Ember.computed(
            "summoner.cellId",
            "subteamDataList",
            function () {
              const e = this._getSubteamData(
                this.get("subteamDataList"),
                this.get("summoner.cellId"),
              );
              return e ? e.display.icon : "";
            },
          ),
          subteamLabel: i.Ember.computed(
            "summoner.cellId",
            "subteamDataList",
            function () {
              const e = this._getSubteamData(
                this.get("subteamDataList"),
                this.get("summoner.cellId"),
              );
              return e ? this.get("tra").get(e.display.label) : "";
            },
          ),
        });
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          1e3: { x: "0px", y: "-45px" },
          3003: { x: "0px", y: "-55px" },
          5e3: { x: "0px", y: "-55px" },
          5006: { x: "0px", y: "-45px" },
          6001: { x: "0px", y: "-50px" },
          9e3: { x: "0px", y: "-45px" },
          11001: { x: "0px", y: "-50px" },
          11009: { x: "0px", y: "-50px" },
          11010: { x: "0px", y: "-55px" },
          12e3: { x: "0px", y: "-50px" },
          12008: { x: "0px", y: "-60px" },
          12009: { x: "0px", y: "-60px" },
          13e3: { x: "0px", y: "-55px" },
          13001: { x: "0px", y: "-50px" },
          13003: { x: "0px", y: "-60px" },
          13010: { x: "0px", y: "-50px" },
          16007: { x: "0px", y: "-50px" },
          17004: { x: "0px", y: "-55px" },
          17005: { x: "0px", y: "-50px" },
          17008: { x: "0px", y: "-55px" },
          17015: { x: "0px", y: "-55px" },
          17016: { x: "0px", y: "-55px" },
          17017: { x: "0px", y: "-55px" },
          18e3: { x: "0px", y: "-50px" },
          18001: { x: "0px", y: "-55px" },
          18002: { x: "0px", y: "-50px" },
          18005: { x: "0px", y: "-55px" },
          18011: { x: "0px", y: "-55px" },
          19e3: { x: "0px", y: "-55px" },
          19006: { x: "0px", y: "-45px" },
          19008: { x: "0px", y: "-60px" },
          20002: { x: "0px", y: "-50px" },
          24012: { x: "0px", y: "-65px" },
          24013: { x: "0px", y: "-65px" },
          28002: { x: "0px", y: "-60px" },
          29001: { x: "0px", y: "-55px" },
          29003: { x: "0px", y: "-55px" },
          29006: { x: "0px", y: "-55px" },
          29007: { x: "0px", y: "-55px" },
          29008: { x: "0px", y: "-55px" },
          31006: { x: "0px", y: "-50px" },
          32007: { x: "0px", y: "-55px" },
          33e3: { x: "-25px", y: "-50px" },
          33007: { x: "20px", y: "-55px" },
          34e3: { x: "0px", y: "-60px" },
          34002: { x: "0px", y: "-55px" },
          34007: { x: "0px", y: "-50px" },
          37007: { x: "0px", y: "-55px" },
          41002: { x: "0px", y: "-50px" },
          41008: { x: "0px", y: "-45px" },
          44e3: { x: "0px", y: "-50px" },
          45009: { x: "0px", y: "-45px" },
          51011: { x: "0px", y: "-55px" },
          53020: { x: "0px", y: "-70px" },
          53021: { x: "0px", y: "-70px" },
          54e3: { x: "0px", y: "-65px" },
          54006: { x: "0px", y: "-55px" },
          54007: { x: "0px", y: "-65px" },
          56006: { x: "0px", y: "-45px" },
          57e3: { x: "0px", y: "-45px" },
          57001: { x: "0px", y: "-50px" },
          57002: { x: "0px", y: "-60px" },
          57004: { x: "0px", y: "-55px" },
          57005: { x: "0px", y: "-60px" },
          57006: { x: "0px", y: "-60px" },
          57007: { x: "0px", y: "-55px" },
          58e3: { x: "0px", y: "-45px" },
          58005: { x: "0px", y: "-50px" },
          58006: { x: "0px", y: "-50px" },
          58007: { x: "0px", y: "-45px" },
          58008: { x: "0px", y: "-50px" },
          58009: { x: "0px", y: "-65px" },
          60004: { x: "0px", y: "-55px" },
          60005: { x: "0px", y: "-45px" },
          61006: { x: "0px", y: "-50px" },
          63005: { x: "0px", y: "-45px" },
          63006: { x: "0px", y: "-50px" },
          68002: { x: "0px", y: "-50px" },
          68003: { x: "0px", y: "-50px" },
          69004: { x: "0px", y: "-50px" },
          72002: { x: "0px", y: "-55px" },
          74001: { x: "0px", y: "-50px" },
          74005: { x: "0px", y: "-55px" },
          76005: { x: "0px", y: "-75px" },
          78002: { x: "0px", y: "-55px" },
          78005: { x: "0px", y: "-60px" },
          80006: { x: "0px", y: "-60px" },
          80008: { x: "0px", y: "-50px" },
          83e3: { x: "0px", y: "-50px" },
          85006: { x: "0px", y: "-75px" },
          86e3: { x: "0px", y: "-55px" },
          86001: { x: "0px", y: "-50px" },
          86011: { x: "0px", y: "-60px" },
          89e3: { x: "0px", y: "-50px" },
          89003: { x: "0px", y: "-50px" },
          89004: { x: "0px", y: "-50px" },
          89008: { x: "0px", y: "-70px" },
          89009: { x: "0px", y: "-55px" },
          90006: { x: "0px", y: "-50px" },
          91005: { x: "0px", y: "-60px" },
          92006: { x: "0px", y: "-55px" },
          92016: { x: "0px", y: "-60px" },
          96e3: { x: "0px", y: "-65px" },
          96001: { x: "0px", y: "-65px" },
          96002: { x: "0px", y: "-60px" },
          96007: { x: "0px", y: "-50px" },
          96008: { x: "0px", y: "-60px" },
          96009: { x: "0px", y: "-45px" },
          96010: { x: "0px", y: "-55px" },
          98e3: { x: "0px", y: "-50px" },
          98003: { x: "0px", y: "-55px" },
          102003: { x: "0px", y: "-50px" },
          103004: { x: "0px", y: "-55px" },
          103005: { x: "0px", y: "-50px" },
          103007: { x: "0px", y: "-55px" },
          104007: { x: "0px", y: "-55px" },
          105001: { x: "0px", y: "-50px" },
          105008: { x: "0px", y: "-55px" },
          105009: { x: "0px", y: "-60px" },
          105010: { x: "0px", y: "-80px" },
          106005: { x: "0px", y: "-55px" },
          107008: { x: "0px", y: "-60px" },
          110006: { x: "0px", y: "-55px" },
          111003: { x: "0px", y: "-50px" },
          111004: { x: "0px", y: "-60px" },
          112004: { x: "0px", y: "-60px" },
          114002: { x: "0px", y: "-40px" },
          115e3: { x: "0px", y: "-55px" },
          115001: { x: "0px", y: "-50px" },
          115005: { x: "0px", y: "-60px" },
          117006: { x: "0px", y: "-60px" },
          119006: { x: "0px", y: "-60px" },
          121e3: { x: "0px", y: "-50px" },
          121001: { x: "0px", y: "-50px" },
          121003: { x: "0px", y: "-75px" },
          121004: { x: "0px", y: "-45px" },
          122001: { x: "0px", y: "-50px" },
          126004: { x: "0px", y: "-65px" },
          131003: { x: "0px", y: "-65px" },
          131011: { x: "0px", y: "-50px" },
          133001: { x: "0px", y: "-50px" },
          133004: { x: "0px", y: "-65px" },
          15e4: { x: "0px", y: "-60px" },
          150003: { x: "0px", y: "-60px" },
          157003: { x: "0px", y: "-65px" },
          157009: { x: "0px", y: "-65px" },
          161e3: { x: "0px", y: "-55px" },
          161001: { x: "0px", y: "-50px" },
          161002: { x: "0px", y: "-55px" },
          161003: { x: "0px", y: "-55px" },
          163001: { x: "0px", y: "-55px" },
          164e3: { x: "0px", y: "-60px" },
          201003: { x: "0px", y: "-50px" },
          202001: { x: "0px", y: "-55px" },
          203e3: { x: "0px", y: "-55px" },
          203001: { x: "0px", y: "-65px" },
          222002: { x: "0px", y: "-50px" },
          222004: { x: "0px", y: "-50px" },
          222012: { x: "0px", y: "-60px" },
          223e3: { x: "0px", y: "-50px" },
          223001: { x: "0px", y: "-50px" },
          236006: { x: "0px", y: "-50px" },
          236007: { x: "0px", y: "-55px" },
          238002: { x: "0px", y: "-50px" },
          238003: { x: "0px", y: "-60px" },
          245002: { x: "0px", y: "-60px" },
          245011: { x: "0px", y: "-50px" },
          254005: { x: "0px", y: "-60px" },
          254011: { x: "0px", y: "-60px" },
          267003: { x: "0px", y: "-50px" },
          267007: { x: "0px", y: "-50px" },
          267008: { x: "0px", y: "-55px" },
          268001: { x: "0px", y: "-55px" },
          412e3: { x: "0px", y: "-50px" },
          421001: { x: "0px", y: "-60px" },
          421002: { x: "0px", y: "-55px" },
          429e3: { x: "0px", y: "-50px" },
          429001: { x: "0px", y: "-50px" },
          429002: { x: "0px", y: "-55px" },
          429003: { x: "0px", y: "-55px" },
          432e3: { x: "0px", y: "-55px" },
          479001: { x: "0px", y: "-55px" },
        };
        t.default = n;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "LCfV443X",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-object-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-object-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-object-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["showSubteamIcon"]]],null,13],["block",["if"],[["get",["uxSettings","largeAreaAnimationsEnabled"]]],null,11,10],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["active-bar ",["helper",["if"],[["get",["summoner","shouldShowActingBar"]],"","hidden"],null]]]],["flush-element"],["close-element"],["text","\\n\\n"],["open-element","div",[]],["static-attr","class","active-bar-spacer"],["flush-element"],["close-element"],["text","\\n"],["block",["unless"],[["get",["isUILockedForGameStart"]]],null,9],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-container-wrapper ",["helper",["if"],[["get",["showPickOrderSwapButton"]],"expanded","collapsed"],null]]]],["flush-element"],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-spells ",["helper",["if"],[["get",["summoner","shouldShowSpells"]],"","removed"],null]," ",["helper",["unless"],[["get",["bright"]],"dim"],null]]]],["flush-element"],["text","\\n    "],["open-element","img",[]],["static-attr","class","spell spell1"],["dynamic-attr","src",["unknown",["summoner","spell1IconPath"]],null],["flush-element"],["close-element"],["text","\\n    "],["open-element","img",[]],["static-attr","class","spell spell2"],["dynamic-attr","src",["unknown",["summoner","spell2IconPath"]],null],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-ban-item ",["helper",["if"],[["get",["summoner","shouldShowBanIntentIcon"]],"visible","removed"],null]]]],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","champ-ban-icon"],["dynamic-attr","style",["concat",["background-image:url(",["unknown",["summoner","banIntentSquarePortratPath"]],")"]]],["flush-element"],["text","\\n      "],["open-element","span",[]],["static-attr","class","ban-icon-overlay"],["flush-element"],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","class","summoner-container-spacer"],["flush-element"],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-container ",["helper",["if"],[["get",["summoner","shouldShowExpanded"]],"expanded","collapsed"],null]]]],["flush-element"],["text","\\n    "],["open-element","lol-parties-comm-halo",[]],["dynamic-attr","puuid",["unknown",["summoner","puuid"]],null],["static-attr","size","medium"],["flush-element"],["text","\\n      "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-icon-container ",["helper",["unless"],[["get",["bright"]],"dim"],null]," "]]],["flush-element"],["text","\\n"],["block",["if"],[["get",["showChampionIconTooltip"]]],null,8],["text","        "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-ring-pop-animation ",["helper",["if"],[["get",["summoner","shouldShowRingAnimations"]],"visible","removed"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-ring-shine-animation ",["helper",["if"],[["get",["summoner","shouldShowRingAnimations"]],"visible","removed"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-icon-pick-snipe-glow-animation"],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-icon-pick-snipe-magic-animation"],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,5],["text","        "],["open-element","div",[]],["static-attr","class","champion-icons"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","champion-icons-bg"],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["positionIconPath"]]],null,4],["text","          "],["open-element","div",[]],["static-attr","class","portrait-icon fit-icon"],["dynamic-attr","style",["helper",["sanitize"],[["get",["championIconStyle"]]],null],null],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n\\n        "],["open-element","div",[]],["static-attr","class","champion-ring"],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,3],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-icon-pick-snipe-ring-animation"],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","champion-icon-pick-snipe-magic-animation"],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-ring-magic-animation-inner ",["helper",["if"],[["get",["summoner","shouldShowRingAnimations"]],"visible","removed"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-ring-magic-animation-outer ",["helper",["if"],[["get",["summoner","shouldShowRingAnimations"]],"visible","removed"],null]]]],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","div",[]],["dynamic-attr","class",["concat",["image-ring-spinner  ",["helper",["if"],[["get",["showSummonerActing"]],"visible","removed"],null]," ",["helper",["if"],[["get",["isLeft"]],"left-side","right-side"],null]," ",["helper",["if"],[["get",["summoner","isSelf"]],"is-self"],null]," ",["helper",["if"],[["get",["uxSettings","largeAreaAnimationsEnabled"]],"animated","not-animated"],null]]]],["flush-element"],["close-element"],["text","\\n        "],["open-element","img",[]],["dynamic-attr","class",["concat",["summoner-muted-icon ",["helper",["unless"],[["get",["summoner","showMuted"]],"removed"],null]]]],["static-attr","src","/fe/lol-champ-select/images/summoner-object/button-mute.svg"],["flush-element"],["close-element"],["text","\\n"],["block",["unless"],[["get",["isUILockedForGameStart"]]],null,2],["text","      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","div",[]],["static-attr","class","player-details-spacer"],["flush-element"],["close-element"],["text","\\n\\n    "],["open-element","div",[]],["static-attr","class","player-details"],["dynamic-attr","style",["unknown",["playerDetailsStyle"]],null],["flush-element"],["text","\\n      "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-vote-projection ",["helper",["unless"],[["get",["voteProjectionText"]],"no-vote-percent"],null]]]],["flush-element"],["text","\\n        "],["append",["unknown",["voteProjectionText"]],false],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-secondary-text ",["helper",["unless"],[["get",["summonerSecondaryText"]],"removed"],null]]]],["flush-element"],["text","\\n        "],["open-element","span",[]],["static-attr","class","summoner-secondary-text-inner"],["flush-element"],["append",["unknown",["summonerSecondaryText"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-primary-text ",["helper",["unless"],[["get",["summonerPrimaryText"]],"hidden"],null]]]],["flush-element"],["text","\\n        "],["append",["unknown",["summonerPrimaryText"]],false],["text","\\n"],["text","        "],["open-element","div",[]],["static-attr","class","summoner-primary-text-glow"],["flush-element"],["append",["unknown",["summonerPrimaryText"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","div",[]],["dynamic-attr","class",["concat",["summoner-name ",["helper",["if"],[["get",["showTeamBoostIcon"]],"showing-summoner-booster-icon"],null]]]],["flush-element"],["text","\\n        "],["open-element","span",[]],["static-attr","class","name-text"],["flush-element"],["text","\\n          "],["append",["helper",["player-name-wrapper"],null,[["displayName","hiddenName","isSummonerInMyTeam","isOnPlayersTeam","nameVisibilityType","puuid"],[["get",["summoner","displayName"]],["get",["summoner","hiddenName"]],["get",["summoner","isSummonerInMyTeam"]],["get",["summoner","isOnPlayersTeam"]],["get",["summoner","nameVisibilityType"]],["get",["summoner","puuid"]]]]],false],["text","\\n        "],["close-element"],["text","\\n"],["block",["if"],[["get",["showTeamBoostIcon"]]],null,1],["text","      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n"],["block",["if"],[["get",["shouldShowOverlay"]]],null,0],["text","  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["append",["helper",["summoner-overlay"],null,[["displayName","puuid","summonerId","obfuscatedPuuid","obfuscatedSummonerId","isMuted","isReportingEnabled","jmxSettings","recordDidRequestSucceed"],[["get",["displayName"]],["get",["summoner","puuid"]],["get",["summoner","summonerId"]],["get",["summoner","obfuscatedPuuid"]],["get",["summoner","obfuscatedSummonerId"]],["get",["summoner","showMuted"]],["get",["isReportingEnabled"]],["get",["jmxSettings"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","          "],["open-element","div",[]],["static-attr","class","summoner-name-booster-icon"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","          "],["append",["helper",["trade-button"],null,[["tradeId","summonerToTradeChampionName","currentSummonerChampionName","uxSettings","displayName","recordDidRequestSucceed","summonerHasActiveTrade","showChampionTradeButton","showValidTrade","showChampionChestAvailable"],[["get",["summoner","tradeId"]],["get",["summoner","championName"]],["get",["currentSummonerChampionName"]],["get",["uxSettings"]],["get",["displayName"]],["get",["recordDidRequestSucceed"]],["get",["summonerHasActiveTrade"]],["get",["showChampionTradeButton"]],["get",["summoner","showTrades"]],["get",["showChampionChestAvailable"]]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","          "],["open-element","div",[]],["static-attr","class","champion-ring-chest-available-glow"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","            "],["open-element","img",[]],["dynamic-attr","src",["unknown",["positionIconPath"]],null],["static-attr","class","svg-icon"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","          "],["open-element","div",[]],["static-attr","class","champion-icon-pick-chest-available-glow"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","              "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","padding","small"],["flush-element"],["text","\\n                "],["open-element","p",[]],["flush-element"],["append",["unknown",["summoner","championName"]],false],["close-element"],["text","\\n              "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["top","whole-window"]],6]],"locals":[]},{"statements":[["block",["if"],[["get",["summoner","championName"]]],null,7]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",["swap-button-spacing ",["helper",["if"],[["get",["showPickOrderSwapButton"]],"","collapsed"],null]]]],["flush-element"],["text","\\n    "],["append",["helper",["swap-button"],null,[["swapId","uxSettings","summonerHasActiveSwap","displayName","recordDidRequestSucceed","showPickOrderSwapButton"],[["get",["summoner","swapId"]],["get",["uxSettings"]],["get",["summonerHasActiveSwap"]],["get",["displayName"]],["get",["recordDidRequestSucceed"]],["get",["showPickOrderSwapButton"]]]]],false],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",["image-magic-background ",["unknown",["summoner","actingBackgroundAnimationState"]]," skin-showcase"]]],["dynamic-attr","style",["unknown",["skinShowcaseStyle"]],null],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","uikit-state-machine",[]],["static-attr","state","not-acting"],["dynamic-attr","acting-state",["unknown",["summoner","actingBackgroundAnimationState"]],null],["static-attr","class","video-magic-background-state-machine skin-showcase"],["dynamic-attr","style",["unknown",["skinShowcaseStyle"]],null],["flush-element"],["text","\\n    "],["open-element","uikit-states",[]],["flush-element"],["text","\\n      "],["open-element","uikit-state",[]],["static-attr","name","not-acting"],["flush-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-intro-vid"],["static-attr","preloading",""],["flush-element"],["close-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-idle-vid"],["static-attr","preloading",""],["flush-element"],["close-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-outro-vid"],["static-attr","preloading",""],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","intro"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-media",[]],["static-attr","selector",".bg-intro-vid"],["static-attr","can-play",""],["flush-element"],["close-element"],["text","\\n          "],["open-element","uikit-condition-media",[]],["static-attr","selector",".bg-idle-vid"],["static-attr","can-play",""],["flush-element"],["close-element"],["text","\\n          "],["open-element","uikit-condition-parameter",[]],["static-attr","name","acting-state"],["static-attr","value","is-acting-background"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","uikit-state",[]],["static-attr","name","intro"],["flush-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-intro-vid"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","idle"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-media",[]],["static-attr","selector",".bg-intro-vid"],["static-attr","ended",""],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","outro"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-parameter",[]],["static-attr","name","acting-state"],["static-attr","value","not-acting-background"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","uikit-state",[]],["static-attr","name","idle"],["flush-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-idle-vid"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","outro"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-parameter",[]],["static-attr","name","acting-state"],["static-attr","value","not-acting-background"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n\\n      "],["open-element","uikit-state",[]],["static-attr","name","outro"],["flush-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-idle-vid"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n        "],["open-element","uikit-behavior-media",[]],["static-attr","selector",".bg-outro-vid"],["static-attr","playing",""],["flush-element"],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","not-acting"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-media",[]],["static-attr","selector",".bg-outro-vid"],["static-attr","ended",""],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n\\n        "],["open-element","uikit-transition",[]],["static-attr","next-state","not-acting"],["flush-element"],["text","\\n          "],["open-element","uikit-condition-parameter",[]],["static-attr","name","acting-state"],["static-attr","value","not-acting-background"],["flush-element"],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n\\n    "],["open-element","uikit-video",[]],["dynamic-attr","class",["concat",["bg-intro-vid video-magic-background ",["helper",["unless"],[["get",["isLeft"]],"right"],null]]]],["static-attr","visible-state","intro"],["dynamic-attr","src",["concat",[["unknown",["banMagicVideo","intro"]]]]],["static-attr","cache-name","rcp-fe-lol-champ-select"],["flush-element"],["close-element"],["text","\\n    "],["open-element","uikit-video",[]],["dynamic-attr","class",["concat",["bg-idle-vid video-magic-background ",["helper",["unless"],[["get",["isLeft"]],"right"],null]]]],["static-attr","visible-state","idle"],["dynamic-attr","src",["concat",[["unknown",["banMagicVideo","idle"]]]]],["static-attr","loop","loop"],["static-attr","cache-name","rcp-fe-lol-champ-select"],["flush-element"],["close-element"],["text","\\n    "],["open-element","uikit-video",[]],["dynamic-attr","class",["concat",["bg-outro-vid video-magic-background ",["helper",["unless"],[["get",["isLeft"]],"right"],null]]]],["static-attr","visible-state","outro"],["dynamic-attr","src",["concat",[["unknown",["banMagicVideo","outro"]]]]],["static-attr","cache-name","rcp-fe-lol-champ-select"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","padding","small"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["subteamLabel"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon-wrapper"],["flush-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["top","whole-window"]],12],["text","    "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon-arrow"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","champion-select-subteam-icon"],["dynamic-attr","style",["concat",["background-image: url(",["unknown",["subteamIconPath"]],");"]]],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        const s = n(1),
          { Ember: i } = s,
          o = i.Component.extend({
            layout: n(313),
            classNames: ["spell-select-flyout"],
            spells: null,
            hoveredSpell: null,
            targetedSpell: null,
            contextSpellLocked: i.computed.and(
              "contextSpell",
              "contextSpell.locked",
            ),
            contextSpellLockedDescription: i.computed(
              "contextSpell",
              "contextSpell.lockedReason",
              "tra.spell_modal_requires_level",
              "tra.spell_modal_disabled",
              function () {
                let e;
                switch (this.get("contextSpell.lockedReason")) {
                  case "LEVEL":
                    e = "spell_modal_requires_level";
                    break;
                  case "DISABLED":
                    e = "spell_modal_disabled";
                }
                return this.get("tra.service").formatString(e, {
                  level: this.get("contextSpell.summonerLevel"),
                });
              },
            ),
            contextSpellCooldownDescription: i.computed(
              "contextSpell",
              "contextSpell.cooldown",
              "tra.spell_modal_cooldown",
              function () {
                const e = this.get("contextSpell.cooldown");
                if (e)
                  return this.get("tra.service").formatString(
                    "spell_modal_cooldown",
                    { cooldown: e },
                  );
              },
            ),
            contextSpell: i.computed(
              "hoveredSpell",
              "targetedSpell",
              function () {
                const e = this.get("hoveredSpell"),
                  t = this.get("targetedSpell");
                return e || t;
              },
            ),
            actions: {
              onFlyoutSpellHover(e) {
                this.set("hoveredSpell", e);
              },
            },
          });
        e.exports = o;
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "zXa7XMZX",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-spell-popup\\\\layout.hbs\\" style-path=\\"null\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-spell-popup\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","spell-information"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","spell-title"],["flush-element"],["text","\\n    "],["append",["unknown",["contextSpell","name"]],false],["text","\\n  "],["close-element"],["text","\\n"],["block",["if"],[["get",["contextSpellLocked"]]],null,1],["text","  "],["open-element","div",[]],["static-attr","class","spell-description"],["flush-element"],["text","\\n    "],["append",["unknown",["contextSpell","description"]],false],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","spell-cooldown"],["flush-element"],["text","\\n    "],["append",["unknown",["contextSpellCooldownDescription"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["open-element","div",[]],["static-attr","class","spell-divider"],["flush-element"],["close-element"],["text","\\n "],["open-element","lol-uikit-scrollable",[]],["static-attr","class","summoner-spells"],["flush-element"],["text","\\n"],["block",["each"],[["get",["spells"]]],null,0],["text","  "],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["helper",["flyout-selector-popup-button"],null,[["item","selectedItem","onFlyoutItemSelected","onFlyoutItemHover"],[["get",["spell"]],["get",["targetedSpell"]],["get",["onFlyoutSpellSelected"]],["helper",["action"],[["get",[null]],"onFlyoutSpellHover"],null]]]],false],["text","\\n"]],"locals":["spell"]},{"statements":[["text","  "],["open-element","div",[]],["static-attr","class","spell-locked-description"],["flush-element"],["text","\\n    "],["append",["unknown",["contextSpellLockedDescription"]],false],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = l(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = n(152),
          o = r(n(150)),
          a = r(n(158));
        function r(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function l(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (l = function (e) {
            return e ? n : t;
          })(e);
        }
        n(315);
        const { DataBinding: c } = s.default,
          { Telemetry: u } = s.default,
          m = s.UiKitPlugin.getFlyoutManager(),
          { RunMixin: d } = s.EmberAddons.EmberLifeline,
          p = s.UiKitPlugin.getContextualNotificationManager();
        e.exports = s.Ember.Component.extend(d, {
          layout: n(316),
          classNames: ["summoner-spell-container"],
          disabled: !1,
          requestInProgress: !1,
          smiteAssignmentNotification: null,
          smiteAssignmentNotificationAlreadyShown: !1,
          didUserChangeItem: !1,
          targetSummonerSpellIndex: i.INVALID_SPELL_ID,
          hoveredSpell: null,
          targetedSpell: null,
          init() {
            this._super(...arguments);
            this.set("flyoutOptions", {
              targetAnchor: { x: "center", y: "top" },
              tooltipAnchor: { x: "center", y: "bottom" },
              offset: { x: 0, y: -20 },
              backdropCutout: null,
              orientation: "top",
              animated: !1,
            });
          },
          didUpdateAttrs: function () {
            this._super(...arguments);
            const e = this.get("showPositionAssignment"),
              t = this.get("timer.inPlanningPhase"),
              n = this.get("timer.inBanPickPhase");
            if (!t || e || this.smiteAssignmentNotificationAlreadyShown)
              n &&
                this.smiteAssignmentNotification &&
                p.remove(this.smiteAssignmentNotification);
            else {
              c("/lol-lobby-team-builder/champ-select")
                .get("/v1/has-auto-assigned-smite", { skipCache: !0 })
                .then((e) => {
                  e &&
                    (this.runTask(() => {
                      this.displaySmiteAssignmentNotification();
                    }, 1e3),
                    (this.smiteAssignmentNotificationAlreadyShown = !0));
                });
            }
          },
          displaySmiteAssignmentNotification: function () {
            if (this.smiteAssignmentNotification) return;
            const e = p.add(this.get("tra.smite_assignment_message"), {
              target: {
                domNode: this.element,
                anchor: { x: "center", y: "top" },
              },
              dismissOnTargetHide: !0,
            });
            (this.smiteAssignmentNotification = e),
              e.onRemove.then(() => {
                this.smiteAssignmentNotification = null;
              });
          },
          summonerSpells: s.Ember.computed("spell1", "spell2", function () {
            return s.Ember.A([this.get("spell1"), this.get("spell2")]);
          }),
          clearRequestInProgress: s.Ember.observer(
            "spell1",
            "spell2",
            function () {
              this.set("requestInProgress", !1),
                this.cancelTask(this.requestInProgressTimeout);
            },
          ),
          autoClearRequestInProgress: s.Ember.observer(
            "requestInProgress",
            function () {
              this.get("requestInProgress") &&
                (this.cancelTask(this.requestInProgressTimeout),
                (this.requestInProgressTimeout = this.runTask(() => {
                  this.clearRequestInProgress();
                }, 1e4)));
            },
          ),
          getSummonerSpellIdsFromPositionTable: function (e, t) {
            return e
              ? t && t in e
                ? e[t].spells
                : i.POSITION_ANY in e
                  ? e[i.POSITION_ANY].spells
                  : []
              : [];
          },
          requiredSummonerSpells: s.Ember.computed(
            "assignedPosition",
            "perPositionRequiredSummonerSpells",
            function () {
              const e = this.get("assignedPosition"),
                t = this.get("perPositionRequiredSummonerSpells");
              return this.getSummonerSpellIdsFromPositionTable(t, e);
            },
          ),
          disallowedSummonerSpells: s.Ember.computed(
            "assignedPosition",
            "perPositionDisallowedSummonerSpells",
            function () {
              const e = this.get("assignedPosition"),
                t = this.get("perPositionDisallowedSummonerSpells");
              return this.getSummonerSpellIdsFromPositionTable(t, e);
            },
          ),
          filteredSpells: s.Ember.computed(
            "spells",
            "requiredSummonerSpells",
            "disallowedSummonerSpells",
            function () {
              const e = this.get("requiredSummonerSpells");
              if (e && e.length > 1)
                return this.get("spells").filter((t) => e.includes(t.id));
              const t = this.get("disallowedSummonerSpells");
              return t && t.length > 0
                ? this.get("spells").filter((e) => !t.includes(e.id))
                : this.get("spells");
            },
          ),
          _calculateSpellCaretPosition(e) {
            let t = 0;
            if (e.element && e.element.parentElement) {
              const n = e.element.parentElement.clientWidth / 2;
              t = e.element.offsetWidth / 2 - n + e.element.offsetLeft;
            }
            this.set("spellCaretOffset", t);
          },
          _hideFlyout() {
            this.set("isFlyoutOpen", !1),
              this.set("hoveredSpell", null),
              this.set("targetedSpell", null);
          },
          _setSpells: function (e) {
            const t = this.get("summonerSpells").mapBy("id");
            ((void 0 !== e.spell1Id && e.spell1Id !== t[0]) ||
              (void 0 !== e.spell2Id && e.spell2Id !== t[1])) &&
              (u.startTimer("champ-select-spell-selected"),
              this._sendFlashPreferenceData(e),
              this._sendSpellRequestData(e));
          },
          _playSpellSound: function (e) {
            o.default.playSound("sfx-ui", e.get("soundPath"));
          },
          _show: function (e) {
            this._playSpellSound(e),
              u.sendEvent("champ-select-spell-popup-shown");
          },
          _sendFlashPreferenceData(e) {
            const t = {};
            4 === e.spell1Id &&
              ((t.playerFlashOnFPreference = !1),
              this.patchRuneRecommenderSettings(t)),
              4 === e.spell2Id &&
                ((t.playerFlashOnFPreference = !0),
                this.patchRuneRecommenderSettings(t));
          },
          patchRuneRecommenderSettings(e) {
            this.set("requestInProgress", !0),
              a.default
                .ajax({
                  url: "/lol-settings/v2/account/LCUPreferences/lol-perks",
                  contentType: "application/json",
                  data: JSON.stringify({ data: e, schemaVersion: 1 }),
                  method: "PATCH",
                  errorMessage: "error_could_not_set_spell_preferences",
                })
                .then(() => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0),
                    this.set("requestInProgress", !1);
                })
                .catch((e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e),
                    this.isDestroying ||
                      this.isDestroyed ||
                      this.set("requestInProgress", !1);
                });
          },
          _sendSpellRequestData(e) {
            this.set("requestInProgress", !0),
              a.default
                .ajax({
                  url: "/lol-champ-select/v1/session/my-selection",
                  contentType: "application/json",
                  data: JSON.stringify(e),
                  method: "PATCH",
                  errorMessage: "error_could_not_set_spells",
                })
                .then(() => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0),
                    this.set("requestInProgress", !1);
                })
                .catch((e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e),
                    this.isDestroying ||
                      this.isDestroyed ||
                      this.set("requestInProgress", !1);
                });
          },
          _onSpellConfirm() {
            this.set("isFlyoutOpen", !1), this.set("didUserChangeItem", !0);
          },
          actions: {
            onFlyoutSpellSelected(e) {
              if (s.Ember.get(e, "locked")) return;
              const t = this.get("summonerSpells").mapBy("id"),
                n = this.get("targetedSpell"),
                o = s.Ember.get(n, "id"),
                a = s.Ember.get(e, "id"),
                r = this.get("requiredSummonerSpells") || [],
                l = 1 === r.length ? r[0] : i.INVALID_SPELL_ID;
              let c,
                u = {};
              o === t[0]
                ? ((c = t[1]),
                  (u = { spell1Id: a }),
                  o === l && ((u.spell2Id = l), (c = l)))
                : ((c = t[0]),
                  (u = { spell2Id: a }),
                  o === l && ((u.spell1Id = l), (c = l))),
                a === c && (u = { spell1Id: t[1], spell2Id: t[0] }),
                this._show(e),
                this._setSpells(u),
                this._onSpellConfirm();
            },
            toggleFlyout(e) {
              const t = e.selectedItem,
                n = this.get("summonerSpells").indexOf(t),
                s = this.get("targetSummonerSpellIndex"),
                a = this.get("isFlyoutOpen");
              if (n === i.INVALID_SPELL_ID || (a && s === n))
                this._hideFlyout();
              else {
                this._calculateSpellCaretPosition(e),
                  this.set("targetSummonerSpellIndex", n),
                  this.set("hoveredSpell", t),
                  this.set("targetedSpell", t);
                a && s !== n
                  ? this.send("repositionCaret")
                  : (o.default.playSound(
                      "sfx-ui",
                      `${i.SOUNDS_PATH}/sfx-cs-spells-open.ogg`,
                    ),
                    this.set("isFlyoutOpen", !0));
              }
            },
            repositionCaret() {
              m.repositionCaret(this.get("spellCaretOffset"));
            },
            afterUserChangedItemAnimation() {
              this.set("didUserChangeItem", !1);
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "JS8zLI4d",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-spell-select-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-spell-select-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-spell-select-component\\\\index.js\\" "],["text","\\n"],["append",["helper",["flyout-selector-trigger-button"],null,[["selectedItem","toggleFlyout","disabled","temporarilyDisabled","didUserChangeItem","afterUserChangedItemAnimation"],[["get",["spell1"]],["helper",["action"],[["get",[null]],"toggleFlyout"],null],["get",["disabled"]],["get",["requestInProgress"]],["get",["didUserChangeItem"]],["helper",["action"],[["get",[null]],"afterUserChangedItemAnimation"],null]]]],false],["text","\\n"],["append",["helper",["flyout-selector-trigger-button"],null,[["selectedItem","toggleFlyout","disabled","temporarilyDisabled","didUserChangeItem","afterUserChangedItemAnimation"],[["get",["spell2"]],["helper",["action"],[["get",[null]],"toggleFlyout"],null],["get",["disabled"]],["get",["requestInProgress"]],["get",["didUserChangeItem"]],["helper",["action"],[["get",[null]],"afterUserChangedItemAnimation"],null]]]],false],["text","\\n"],["open-element","lc-flyout",[]],["dynamic-attr","open",["unknown",["isFlyoutOpen"]],null],["dynamic-attr","onHide",["helper",["action"],[["get",[null]],"toggleFlyout"],null],null],["dynamic-attr","didShow",["helper",["action"],[["get",[null]],"repositionCaret"],null],null],["dynamic-attr","uiKitOptionOverrides",["unknown",["flyoutOptions"]],null],["flush-element"],["text","\\n  "],["open-element","lc-flyout-content",[]],["flush-element"],["text","\\n    "],["append",["helper",["summoner-spell-popup"],null,[["spells","hoveredSpell","targetedSpell","onFlyoutSpellSelected"],[["get",["filteredSpells"]],["get",["hoveredSpell"]],["get",["targetedSpell"]],["helper",["action"],[["get",[null]],"onFlyoutSpellSelected"],null]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(152);
        n(318);
        const i = n(1),
          { Ember: o } = i;
        e.exports = o.Component.extend({
          classNames: ["summoner-timer"],
          layout: n(319),
          summonerTimerStyle: o.computed("timerCellId", function () {
            const e = this.get("timerCellId");
            return this.calculateAndFormatStyleFromCellId(e);
          }),
          calculateAndFormatStyleFromCellId: function (e) {
            return `transform: translateY(${e * s.SUMMONER_OBJECT_SIZE}px);`;
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "Vx98RbjG",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-timer-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-timer-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\summoner-timer-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["timer ",["helper",["if"],[["get",["hideSummonerTimer"]],"hidden"],null]," ",["helper",["unless"],[["get",["isMyTeam"]],"right"],null]]]],["dynamic-attr","data-time",["unknown",["formattedTime"]],null],["dynamic-attr","style",["unknown",["summonerTimerStyle"]],null],["flush-element"],["text","\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["action-pointer ",["helper",["if"],[["get",["isMyTeam"]],"left","right"],null]]]],["flush-element"],["close-element"],["text","\\n"],["block",["if"],[["get",["isInfinite"]]],null,1,0],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["unknown",["formattedTime"]],false],["text","\\n"]],"locals":[]},{"statements":[["text","    ∞\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(321);
        var i = n(152);
        e.exports = s.Ember.Component.extend({
          classNames: ["team-bans"],
          classNameBindings: [
            "isMyTeam:left:right",
            "hasSimultaneousBans:flip-my-team-bans",
            "numBanActionItemsClass",
          ],
          layout: n(322),
          banActionItems: s.Ember.computed(
            "numBans",
            "banActions.[]",
            function () {
              const e = Math.floor(this.get("numBans") / 2),
                t = this.get("banActions"),
                n = [].concat(t);
              for (; e > n.length; ) n.push(s.Ember.Object.create());
              return n;
            },
          ),
          numBanActionItemsClass: s.Ember.computed(
            "banActionItems.length",
            function () {
              return this.get("banActionItems.length") >
                i.STANDARD_MAX_TEAM_SIZE
                ? "has-extra-bans"
                : "";
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "U/dHPJyF",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","bans-container"],["flush-element"],["text","\\n"],["block",["each"],[["get",["banActionItems"]]],null,0],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["append",["helper",["team-bans-item"],null,[["banAction","actionIndex","isMyTeam","hasSimultaneousBans","gameMode"],[["get",["banAction"]],["get",["index"]],["get",["isMyTeam"]],["get",["hasSimultaneousBans"]],["get",["gameMode"]]]]],false],["text","\\n"]],"locals":["banAction","index"]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n(324);
        var s = n(1),
          i = n(152);
        e.exports = s.Ember.Component.extend({
          classNames: ["team-bans-item"],
          classNameBindings: ["indexClass"],
          layout: n(325),
          indexClass: s.Ember.computed(
            "actionIndex",
            "isMyTeam",
            "hasSimultaneousBans",
            "gameMode",
            function () {
              if (
                this.get("hasSimultaneousBans") &&
                !this.get("isMyTeam") &&
                !i.GAME_MODES_WITH_NO_BAN_DELAY_TIMERS[this.get("gameMode")]
              )
                return `enemy-ban-index-${this.get("actionIndex")}`;
            },
          ),
          bannedChampIconPath: s.Ember.computed(
            "banAction.completed",
            "banAction.champion",
            function () {
              return this.get("banAction.completed")
                ? this.get("banAction.champion.squarePortraitPath")
                : "";
            },
          ),
          championIsNotBanned: s.Ember.computed(
            "banAction.completed",
            function () {
              return !this.get("banAction.completed");
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "poS+ACew",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\team-bans-item\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\team-bans-item\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-bans-component\\\\team-bans-item\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["team-bans-champion-icon ",["helper",["if"],[["get",["banAction","completed"]],"is-completed"],null]]]],["dynamic-attr","style",["concat",["background-image:url(",["unknown",["bannedChampIconPath"]],")"]]],["flush-element"],["close-element"],["text","\\n\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","type","disabled"],["bottom","system",["get",["championIsNotBanned"]]]],0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["flush-element"],["text","\\n    "],["open-element","p",[]],["flush-element"],["append",["unknown",["banAction","champion","name"]],false],["close-element"],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = (s = n(158)) && s.__esModule ? s : { default: s };
        n(327);
        const o = n(1),
          { Ember: a } = o,
          r =
            (o.ViewportPlugin.fullScreen().getScreenRoot(
              "rcp-fe-lol-champ-select",
            ),
            o.EmberDataBinding({
              Ember: a,
              websocket: o.getProvider().getSocket(),
              basePaths: {
                teamBoosts: "/lol-champ-select",
                login: "/lol-login",
                lolInventory: "/lol-inventory",
              },
              boundProperties: {
                teamBoost: { api: "teamBoosts", path: "/v1/team-boost" },
                walletRP: { api: "lolInventory", path: "/v1/wallet/RP" },
              },
            }));
        e.exports = a.Component.extend(r, {
          classNames: ["team-boost"],
          layout: n(328),
          isBoostPurchaseModalShown: !1,
          rp: a.computed("walletRP.RP", function () {
            return this.get("walletRP.RP") || 0;
          }),
          disabled: a.computed(
            "isUILockedForGameStart",
            "canAffordBoost",
            "disabledViaTime",
            function () {
              return !(
                !this.get("isUILockedForGameStart") &&
                this.get("canAffordBoost") &&
                !this.get("disabledViaTime")
              );
            },
          ),
          showBoostButton: a.computed(
            "teamBoost.unlocked",
            "allowBattleBoost",
            "inFinalizationPhase",
            "isShowingVoteCeremonies",
            function () {
              return (
                !this.get("teamBoost.unlocked") &&
                this.get("allowBattleBoost") &&
                this.get("inFinalizationPhase") &&
                !this.get("isShowingVoteCeremonies")
              );
            },
          ),
          canAffordBoost: a.computed("rp", "teamBoost.price", function () {
            return this.get("rp") >= this.get("teamBoost.price");
          }),
          disabledViaTime: a.computed(
            "timeRemaining",
            "jmxSettings.LcuChampionSelect.SkinPurchaseTime",
            "inFinalizationPhase",
            function () {
              return !!(
                this.get("inFinalizationPhase") &&
                this.get("timeRemaining") <
                  this.get("jmxSettings.LcuChampionSelect.SkinPurchaseTime")
              );
            },
          ),
          boostButtonText: a.computed(
            "boostableSkinCount",
            "tra.service",
            "tra.service.boost_button_double_skin",
            "tra.service.pregame_boost",
            function () {
              return 2 === this.get("boostableSkinCount")
                ? this.get("tra.service").get("boost_button_double_skin")
                : this.get("tra.service").get("pregame_boost");
            },
          ),
          boostTooltipMessage: a.computed("canAffordBoost", function () {
            return this.get("canAffordBoost")
              ? this.get("tra.service").formatString("boost_tooltip_message", {
                  boostableSkinCount: this.get("boostableSkinCount"),
                })
              : this.get("tra.service").get("boost_tooltip_insufficient_rp");
          }),
          boostPurchaseModalShowing: a.computed(
            "isBoostPurchaseModalShown",
            "disabled",
            function () {
              return (
                this.get("isBoostPurchaseModalShown") && !this.get("disabled")
              );
            },
          ),
          actions: {
            showBoostPurchaseModal() {
              this.get("disabled") || this.set("isBoostPurchaseModalShown", !0);
            },
            closePurchaseBoostModal() {
              this.set("isBoostPurchaseModalShown", !1);
            },
            executePurchaseBoost() {
              i.default
                .ajax({
                  type: "POST",
                  url: "/lol-champ-select/v1/team-boost/purchase",
                  errorMessage: "error_could_not_purchase_boost",
                })
                .then(() => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!0);
                })
                .catch((e) => {
                  this.recordDidRequestSucceed &&
                    this.recordDidRequestSucceed(!1, e);
                })
                .finally(() => {
                  this.set("isBoostPurchaseModalShown", !1);
                });
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "F7nnqcP2",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-button-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["showBoostButton"]]],null,2],["text","\\n"],["open-element","lc-confirm-modal",[]],["dynamic-attr","acceptText",["unknown",["tra","unlock"]],null],["dynamic-attr","closeButton",true,null],["dynamic-attr","onYes",["helper",["action"],[["get",[null]],"executePurchaseBoost"],null],null],["dynamic-attr","onHide",["helper",["action"],[["get",[null]],"closePurchaseBoostModal"],null],null],["dynamic-attr","open",["unknown",["boostPurchaseModalShowing"]],null],["flush-element"],["text","\\n  "],["open-element","lc-modal-content",[]],["flush-element"],["text","\\n    "],["append",["helper",["team-boost-modal"],null,[["price","rp","boostableSkinCount"],[["get",["teamBoost","price"]],["get",["rp"]],["get",["boostableSkinCount"]]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-large"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["boostTooltipMessage"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-tooltip"],null,[["tooltipPosition","restrictArea"],["bottom","whole-window"]],0]],"locals":[]},{"statements":[["text","  "],["open-element","lol-uikit-flat-button",[]],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"showBoostPurchaseModal"],null],null],["dynamic-attr","disabled",["unknown",["disabled"]],null],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","team-boost-content-wrapper"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","team-boost-rp-icon"],["flush-element"],["close-element"],["text","\\n      "],["append",["unknown",["boostButtonText"]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n"],["block",["unless"],[["get",["disabledViaTime"]]],null,1]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
          if (!t && e && e.__esModule) return e;
          if (null === e || ("object" != typeof e && "function" != typeof e))
            return { default: e };
          var n = i(t);
          if (n && n.has(e)) return n.get(e);
          var s = {},
            o = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var a in e)
            if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) {
              var r = o ? Object.getOwnPropertyDescriptor(e, a) : null;
              r && (r.get || r.set)
                ? Object.defineProperty(s, a, r)
                : (s[a] = e[a]);
            }
          (s.default = e), n && n.set(e, s);
          return s;
        })(n(1));
        function i(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (i = function (e) {
            return e ? n : t;
          })(e);
        }
        n(330);
        const o = s.Ember.Component.extend({
          layout: n(331),
          boostModalMessage: s.Ember.computed(
            "price",
            "tra.boost_modal_message",
            function () {
              return this.get("tra.service").formatString(
                "boost_modal_message",
                { price: this.get("price") },
              );
            },
          ),
          currentRpMessage: s.Ember.computed(
            "rp",
            "tra.rp_amount",
            function () {
              return this.get("tra.service").formatString("rp_amount", {
                amount: this.get("rp"),
              });
            },
          ),
          costRpMessage: s.Ember.computed(
            "price",
            "tra.rp_amount",
            function () {
              return this.get("tra.service").formatString("rp_amount", {
                amount: this.get("price"),
              });
            },
          ),
          balanceRpMessage: s.Ember.computed(
            "rpRemaining",
            "tra.rp_amount",
            function () {
              return this.get("tra.service").formatString("rp_amount", {
                amount: this.get("rpRemaining"),
              });
            },
          ),
          numSkinsMessage: s.Ember.computed(
            "boostableSkinCount",
            "tra.boost_modal_list_item_1",
            function () {
              return this.get("tra.service").formatString(
                "boost_modal_list_item_1",
                { boostableSkinCount: this.get("boostableSkinCount") },
              );
            },
          ),
          rpRemaining: s.Ember.computed("price", "rp", function () {
            return this.get("rp") - this.get("price");
          }),
        });
        e.exports = o;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "F/bg0JJ/",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-modal-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-modal-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\team-boost-modal-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","team-boost-notification"],["flush-element"],["text","\\n  "],["open-element","lol-uikit-content-block",[]],["static-attr","padding","large"],["static-attr","class","boost-description"],["flush-element"],["text","\\n    "],["open-element","h3",[]],["flush-element"],["append",["unknown",["tra","boost_modal_title"]],false],["close-element"],["text","\\n    "],["open-element","p",[]],["flush-element"],["append",["unknown",["boostModalMessage"]],false],["close-element"],["text","\\n    "],["open-element","p",[]],["flush-element"],["text","- "],["append",["unknown",["numSkinsMessage"]],false],["close-element"],["text","\\n    "],["open-element","p",[]],["flush-element"],["text","- "],["append",["unknown",["tra","boost_modal_list_item_2"]],false],["close-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","hr",[]],["flush-element"],["close-element"],["text","\\n  "],["open-element","lol-uikit-content-block",[]],["static-attr","padding","large"],["static-attr","class","boost-details"],["flush-element"],["text","\\n    "],["open-element","table",[]],["static-attr","cellspacing","0"],["flush-element"],["text","\\n      "],["open-element","tr",[]],["flush-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","label"],["flush-element"],["append",["unknown",["tra","current_rp"]],false],["close-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","value"],["flush-element"],["append",["unknown",["currentRpMessage"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","tr",[]],["flush-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","label"],["flush-element"],["append",["unknown",["tra","cost"]],false],["close-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","value"],["flush-element"],["append",["unknown",["costRpMessage"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","tr",[]],["static-attr","class","total"],["flush-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","label"],["flush-element"],["append",["unknown",["tra","balance"]],false],["close-element"],["text","\\n        "],["open-element","td",[]],["static-attr","class","value"],["flush-element"],["append",["unknown",["balanceRpMessage"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s,
          i = n(152),
          o = (s = n(150)) && s.__esModule ? s : { default: s };
        n(333);
        const a = n(1),
          { Ember: r } = a,
          { EmberHelpers: l } = a,
          c = "sfx-ui",
          u = "sfx-notifications";
        e.exports = r.Component.extend({
          classNames: ["timer-status"],
          layout: n(334),
          classNameBindings: ["isHeaderExpanded:expanded-header"],
          inPlanningOrFinalization: r.computed.or(
            "timer.inPlanningPhase",
            "timer.inFinalizationPhase",
          ),
          alliedTeamActive: r.computed(
            "alliedActiveAction",
            "inPlanningOrFinalization",
            "isTeamBuilderGame",
            function () {
              return (
                this.get("isTeamBuilderGame") &&
                (this.get("alliedActiveAction") ||
                  this.get("inPlanningOrFinalization"))
              );
            },
          ),
          enemyTeamActive: r.computed(
            "enemyActiveAction",
            "inPlanningOrFinalization",
            "isTeamBuilderGame",
            function () {
              return (
                this.get("isTeamBuilderGame") &&
                (this.get("enemyActiveAction") ||
                  this.get("inPlanningOrFinalization"))
              );
            },
          ),
          displayAlternateTimer: r.computed.and(
            "isHeaderExpanded",
            "isShowingPerksModal",
          ),
          useBurnoutAnimation1: !0,
          burnoutBarAnimationTriggerObserver: l.observer(
            "currentActions.[]",
            "isShowingPositionAssignment",
            function () {
              if (
                0 === this.get("currentActions.length") &&
                !this.get("inPlanningOrFinalization")
              )
                return;
              const e = this.element.querySelector(
                  ".burnout-timer.left .burnout-timer-bar",
                ),
                t = this.element.querySelector(
                  ".burnout-timer.left .burnout-timer-glow",
                ),
                n = this.element.querySelector(
                  ".burnout-timer.right .burnout-timer-bar",
                ),
                s = this.element.querySelector(
                  ".burnout-timer.right .burnout-timer-glow",
                );
              if (!(e && t && n && s)) return;
              const i = `${this.useBurnoutAnimation1 ? "burnoutTimerBackgroundSize" : "burnoutTimerBackgroundSize2"} ${this.get("timer.timeRemaining")}s linear 0s`;
              (e.style.animation = i),
                (t.style.animation = i),
                (n.style.animation = i),
                (s.style.animation = i),
                (this.useBurnoutAnimation1 = !this.useBurnoutAnimation1);
            },
          ),
          timerTickObserver: r.observer("timer.timeRemaining", function () {
            r.run.once(this, function () {
              if (this.isDestroying || this.isDestroyed) return;
              const e = this.get("timer.timeRemaining");
              if (this.get("timeSeen") === e) return;
              this.set("timeSeen", e);
              const { classList: t } = this.$()[0];
              if (
                (t.remove("timer-pulse"),
                (e <= 5 && this.get("timer.inPlanningPhase")) ||
                  (e <= 10 && this.get("timer.inFinalizationPhase")))
              )
                o.default.playSound(
                  u,
                  "/fe/lol-champ-select/sounds/sfx-cs-timer-tick-small.ogg",
                );
              else {
                let n = i.DURATIONS.actionSoundThreshold;
                if (this.get("isDraftMode")) {
                  const e = this.get(
                    "jmxSettings.LcuChampionSelect.DraftActionTickSoundThreshold",
                  );
                  e && (n = e);
                }
                const s =
                  this.get("timer.inBanPickPhase") &&
                  this.get("activeAction.actor.isSelf");
                e <= n &&
                  s &&
                  (o.default.playSound(
                    u,
                    "/fe/lol-champ-select/sounds/sfx-cs-timer-tick.ogg",
                  ),
                  this.element.offsetWidth,
                  t.add("timer-pulse"));
              }
            });
          }),
          playActionTypeTransitionSounds: l.observeChange(
            "activeAction.type",
            r.on("init", function () {
              if (!this.get("isDraftMode")) return;
              const e = this.get("activeAction.type");
              "pick" === e
                ? o.default.playSound(
                    c,
                    "/fe/lol-champ-select/sounds/sfx-cs-draft-pick-intro.ogg",
                  )
                : "ban" !== e ||
                  this.get("activeAction.actor.isSelf") ||
                  o.default.playSound(
                    c,
                    "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-intro.ogg",
                  );
            }),
          ),
          localPlayerActive: r.computed(
            "activeAction.actor.isSelf",
            "champSelectScreen",
            "timer.inPlanningPhase",
            "summoner.champion",
            function () {
              return (
                this.get("activeAction.actor.isSelf") ||
                (this.get("champSelectScreen") === i.SCREENS.selected &&
                  !this.get("isShowingVoteCeremonies")) ||
                (this.get("timer.inPlanningPhase") &&
                  !this.get("summoner.champion"))
              );
            },
          ),
          blueTeamIsChoosing: r.computed("activeActions.[]", function () {
            return (
              this.get("activeActions") &&
              this.get("activeActions").filterBy("isOnLeftSide", !0).length > 1
            );
          }),
          redTeamIsChoosing: r.computed("activeActions.[]", function () {
            return (
              this.get("activeActions") &&
              this.get("activeActions").filterBy("isOnLeftSide", !1).length > 1
            );
          }),
          shouldHideMessage: r.computed(
            "activeAction.isVoteReveal",
            "isPlayingCeremony",
            function () {
              return (
                !this.get("activeAction.isVoteReveal") &&
                this.get("isPlayingCeremony")
              );
            },
          ),
          message: l.computedGate(
            "timer.phase",
            "activeAction.actor.isSelf",
            "activeAction.isBan",
            "activeAction.isPick",
            "activeAction.isVote",
            "activeAction.championId",
            "activeAction.actor.name",
            "activeAction.isVoteReveal",
            "allPlayersActTogether",
            "blueTeamIsChoosing",
            "redTeamIsChoosing",
            "champSelectScreen",
            "isSpectating",
            "alliedTeamActive",
            "enemyTeamActive",
            "tra.timer_phase_ban_pick_choose_message",
            "tra.timer_phase_ban_pick_lock_message",
            "tra.timer_phase_ban_pick_blue_team_choosing_message",
            "tra.timer_phase_ban_pick_red_team_choosing_message",
            "tra.timer_phase_ban_pick_waiting_message",
            "tra.timer_phase_finalization_message",
            "tra.timer_phase_ban_pick_ban_message",
            "tra.timer_phase_ban_pick_other_pick_message",
            "tra.timer_phase_ban_pick_other_ban_message",
            "tra.timer_phase_game_starting_message",
            "tra.timer_phase_vote_choose_message",
            "tra.spectator_delay_message",
            function () {
              switch (this.get("timer.phase")) {
                case i.TIMER_PHASES.planning:
                  return this.get("localPlayerActive")
                    ? this.get("tra.timer_phase_ban_pick_intent_message")
                    : this.get("tra.timer_phase_ban_pick_waiting_message");
                case i.TIMER_PHASES.banPick:
                  return this.get("champSelectScreen") === i.SCREENS.selected
                    ? this.get("tra.timer_phase_finalization_message")
                    : this.get("activeAction.actor.isSelf")
                      ? this.get("activeAction.isPick")
                        ? this.get("tra.timer_phase_ban_pick_choose_message")
                        : this.get("activeAction.isVote")
                          ? this.get("tra.timer_phase_vote_choose_message")
                          : this.get("tra.timer_phase_ban_pick_ban_message")
                      : this.get("allPlayersActTogether")
                        ? this.get("tra.timer_phase_ban_pick_waiting_message")
                        : this.get("blueTeamIsChoosing") &&
                            this.get("isSpectating")
                          ? this.get(
                              "tra.timer_phase_ban_pick_blue_team_choosing_message",
                            )
                          : this.get("redTeamIsChoosing") &&
                              this.get("isSpectating")
                            ? this.get(
                                "tra.timer_phase_ban_pick_red_team_choosing_message",
                              )
                            : this.get("alliedTeamActive")
                              ? this.get(
                                  "tra.timer_phase_ban_pick_allied_team_choosing_message",
                                )
                              : this.get("enemyTeamActive")
                                ? this.get(
                                    "tra.timer_phase_ban_pick_enemy_team_choosing_message",
                                  )
                                : this.get("activeAction.isPick")
                                  ? this.get("tra.service").formatString(
                                      "timer_phase_ban_pick_other_pick_message",
                                      {
                                        summonerName: this.get(
                                          "activeAction.actor.name",
                                        ),
                                      },
                                    )
                                  : this.get("activeAction.isBan")
                                    ? this.get("tra.service").formatString(
                                        "timer_phase_ban_pick_other_ban_message",
                                        {
                                          summonerName: this.get(
                                            "activeAction.actor.name",
                                          ),
                                        },
                                      )
                                    : "";
                case i.TIMER_PHASES.finalization:
                  return this.get("activeAction.isVoteReveal")
                    ? this.get("tra.timer_phase_vote_reveal_message")
                    : this.get("tra.timer_phase_finalization_message");
                case i.TIMER_PHASES.gameStarting:
                  return this.get("isSpectating")
                    ? this.get("tra.spectator_delay_message")
                    : this.get("tra.timer_phase_game_starting_message");
                default:
                  return "";
              }
            },
          ),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "AL5qYe/w",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\timer-status-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\timer-status-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\timer-status-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["isHeaderExpanded"]]],null,7,2],["text","\\n"],["open-element","div",[]],["static-attr","class","timer-container"],["flush-element"],["text","\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["burnout-timer left ",["helper",["unless"],[["get",["alliedTeamActive"]],"burnout-timer-invisible"],null]," ",["helper",["if"],[["get",["alliedActiveAction","isBan"]],"red","blue"],null]]]],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","burnout-timer-glow"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","burnout-timer-bar"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["timer ",["helper",["if"],[["get",["isPlayingCeremony"]],"hidden"],null]," ",["helper",["if"],[["get",["displayAlternateTimer"]],"hidden"],null]]]],["dynamic-attr","data-time",["unknown",["formattedTime"]],null],["flush-element"],["text","\\n"],["block",["if"],[["get",["timer","isInfinite"]]],null,1,0],["text","  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["dynamic-attr","class",["concat",["burnout-timer right ",["helper",["unless"],[["get",["enemyTeamActive"]],"hidden"],null]," ",["helper",["if"],[["get",["inPlanningOrFinalization"]],"blue","red"],null]]]],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","burnout-timer-glow"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","burnout-timer-bar"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","svg",[]],["static-attr","class","metal-work left"],["static-attr","id","Layer_1"],["static-attr","data-name","Layer 1"],["static-attr","xmlns","http://www.w3.org/2000/svg","http://www.w3.org/2000/xmlns/"],["static-attr","viewBox","0 0 1360 140.04"],["static-attr","width","340"],["static-attr","height","35.01"],["flush-element"],["text","\\n    "],["open-element","defs",[]],["flush-element"],["text","\\n      "],["open-element","linearGradient",[]],["static-attr","id","Gradient1"],["flush-element"],["text","\\n        "],["open-element","stop",[]],["static-attr","class","stop1"],["static-attr","offset","0%"],["flush-element"],["close-element"],["text","\\n        "],["open-element","stop",[]],["static-attr","class","stop2"],["static-attr","offset","55%"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n      "],["open-element","style",[]],["static-attr","type","text/css"],["flush-element"],["text",".cls-1 { fill: url(#Gradient1); }\\n      .stop1 { stop-color: #463714; }\\n      .stop2 { stop-color: #785A28; }\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","path",[]],["static-attr","class","cls-1"],["static-attr","transform","translate(615.5 6.54)"],["static-attr","d","M-261.55,112.3v9.45h10.79V101.37h-5.4c-47,0-87.17-36-93.48-83.75l-2.71-7.84H-583.08L-595.5-2.5h212c-.08,1.83,0,10.14,0,12h4v-16l-236,0v4h4l23,23.14h225.34C-354.46,69.64-310,109.74-261.55,112.3Zm6,17.2c-57.68,0-107.69-40.62-120-96h-4c12.41,58.46,63.33,100,124,100h996l4-4Z"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n  "],["open-element","svg",[]],["static-attr","class","metal-work right"],["static-attr","id","Layer_2"],["static-attr","data-name","Layer 1"],["static-attr","xmlns","http://www.w3.org/2000/svg","http://www.w3.org/2000/xmlns/"],["static-attr","viewBox","0 0 1360 140.04"],["static-attr","width","340"],["static-attr","height","35.01"],["flush-element"],["text","\\n    "],["open-element","path",[]],["static-attr","class","cls-1"],["static-attr","transform","translate(615.5 6.54)"],["static-attr","d","M-261.55,112.3v9.45h10.79V101.37h-5.4c-47,0-87.17-36-93.48-83.75l-2.71-7.84H-583.08L-595.5-2.5h212c-.08,1.83,0,10.14,0,12h4v-16l-236,0v4h4l23,23.14h225.34C-354.46,69.64-310,109.74-261.55,112.3Zm6,17.2c-57.68,0-107.69-40.62-120-96h-4c12.41,58.46,63.33,100,124,100h996l4-4Z"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n\\n"],["append",["helper",["team-boost-button"],null,[["allowBattleBoost","isUILockedForGameStart","jmxSettings","inFinalizationPhase","isShowingVoteCeremonies","boostableSkinCount","recordDidRequestSucceed","timeRemaining"],[["get",["allowBattleBoost"]],["get",["isUILockedForGameStart"]],["get",["jmxSettings"]],["get",["inFinalizationPhase"]],["get",["isShowingVoteCeremonies"]],["get",["boostableSkinCount"]],["get",["recordDidRequestSucceed"]],["get",["timer","timeRemaining"]]]]],false],["text","\\n\\n\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["append",["unknown",["formattedTime"]],false],["text","\\n"]],"locals":[]},{"statements":[["text","      ∞\\n"]],"locals":[]},{"statements":[["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",["message ",["helper",["if"],[["get",["shouldHideMessage"]],"hidden"],null]," ",["helper",["if"],[["get",["localPlayerActive"]],"local-player-acting"],null]]]],["flush-element"],["text","\\n    "],["append",["unknown",["message"]],false],["text","\\n  "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["append",["helper",["champion-bench"],null,[["benchChampions","championChestAvailabilityMap","shouldShowChestAvailability","showChestAvailabilityHintedPortraits","inventory","summoner","recordDidRequestSucceed"],[["get",["benchChampions"]],["get",["championChestAvailabilityMap"]],["get",["shouldShowChestAvailability"]],["get",["showChestAvailabilityHintedPortraits"]],["get",["inventory"]],["get",["summoner"]],["get",["recordDidRequestSucceed"]]]]],false],["text","\\n"]],"locals":[]},{"statements":[["text","        "],["append",["unknown",["formattedTime"]],false],["text","\\n"]],"locals":[]},{"statements":[["text","        ∞\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","div",[]],["dynamic-attr","class",["concat",["small-timer ",["helper",["if"],[["get",["isPlayingCeremony"]],"hidden"],null]]]],["dynamic-attr","data-time",["unknown",["formattedTime"]],null],["flush-element"],["text","\\n"],["block",["if"],[["get",["timer","isInfinite"]]],null,5,4],["text","    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["if"],[["get",["displayAlternateTimer"]]],null,6],["block",["if"],[["get",["showChampionBench"]]],null,3]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = r(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = a(n(158)),
          o = a(n(150));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function r(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (r = function (e) {
            return e ? n : t;
          })(e);
        }
        n(336),
          (e.exports = s.Ember.Component.extend({
            layout: n(337),
            classNames: ["trade-button"],
            requestInProgress: !1,
            disabled: s.Ember.computed("requestInProgress", function () {
              return !!this.get("requestInProgress") || null;
            }),
            tradeTooltipText: s.Ember.computed(
              "displayName",
              "tradeId",
              "showValidTrade",
              "summonerToTradeChampionName",
              "currentSummonerChampionName",
              function () {
                return this.get("showValidTrade")
                  ? this.get("tra.service").formatString(
                      "pregame_trade_tooltip",
                      {
                        entity1: this.get("currentSummonerChampionName"),
                        entity2: this.get("summonerToTradeChampionName"),
                      },
                    )
                  : this.get("tra.error_trade_is_unavailable");
              },
            ),
            actions: {
              trade: function () {
                return (
                  o.default.playSound(
                    "sfx-ui",
                    "/fe/lol-champ-select/sounds/sfx-cs-button-trade-click.ogg",
                  ),
                  s.Telemetry.startTracingEvent("champ-select-trade-propose"),
                  this.set("requestInProgress", !0),
                  i.default
                    .ajax({
                      type: "POST",
                      url:
                        "/lol-champ-select/v1/session/trades/" +
                        this.get("tradeId") +
                        "/request",
                      errorMessage: "error_could_not_request_trade",
                    })
                    .then(() => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!0),
                        s.Telemetry.invokeWithLowProbability(function () {
                          s.Telemetry.recordNonTimingTracingEvent(
                            "champ-trade-propose-success",
                            1,
                            "event",
                          );
                        });
                    })
                    .catch((e) => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!1, e),
                        s.Telemetry.invokeWithLowProbability(function () {
                          const t = e && e.responseText ? e.responseText : "";
                          s.DataBinding.bindTo(
                            s.default.getProvider().getSocket(),
                          )
                            .get("/lol-summoner/v1/current-summoner")
                            .then(function (e) {
                              const {
                                  accountId: n,
                                  puuid: i,
                                  summonerId: o,
                                } = e,
                                a = JSON.stringify({
                                  accountId: n,
                                  clientDateISOString: new Date().toISOString(),
                                  puuid: i,
                                  responseText: t,
                                  summonerId: o,
                                });
                              s.Telemetry.sendEvent(
                                "champ-trade-propose-fail",
                                a,
                              ),
                                s.Telemetry.recordNonTimingTracingEvent(
                                  "champ-trade-propose-fail",
                                  1,
                                  "event",
                                );
                            });
                        });
                    })
                    .finally(() => {
                      window.requestAnimationFrame(() => {
                        s.Telemetry.endTracingEvent(
                          "champ-select-trade-propose",
                        );
                      }),
                        this.set("requestInProgress", !1);
                    })
                );
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "3Z+qe6K+",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\trade-button-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["showChampionTradeButton"]]],null,7]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","            "],["open-element","div",[]],["static-attr","class","tooltip-champion-chest-available"],["flush-element"],["append",["unknown",["tra","tooltip_champion_chest_available"]],false],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","        "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","class","champ-select-trade-button-tooltip"],["flush-element"],["text","\\n          "],["open-element","p",[]],["flush-element"],["append",["unknown",["tradeTooltipText"]],false],["close-element"],["text","\\n"],["block",["if"],[["get",["showChampionChestAvailable"]]],null,0],["text","        "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","      "],["open-element","div",[]],["static-attr","class","icon"],["flush-element"],["close-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","type"],["top","system"]],1]],"locals":[]},{"statements":[["block",["uikit-framed-icon"],null,[["onclick","class","interactive","borderWidth","disabled"],[["helper",["action"],[["get",[null]],"trade"],null],"champion-trade-button",true,2,["get",["disabled"]]]],2],["text","    "],["open-element","div",[]],["static-attr","class","champion-trade-ring-background"],["flush-element"],["close-element"],["text","\\n  "]],"locals":[]},{"statements":[["block",["if"],[["get",["showValidTrade"]]],null,3]],"locals":[]},{"statements":[["text","      "],["open-element","div",[]],["static-attr","class","icon"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-framed-icon"],null,[["class","interactive","borderWidth","disabled"],["champion-trade-button-active-trade",true,2,["get",["disabled"]]]],5],["text","    "],["open-element","div",[]],["static-attr","class","champion-trade-ring-background"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["dynamic-attr","class",["concat",["champion-trade-ring-spinner ",["helper",["if"],[["get",["uxSettings","largeAreaAnimationsEnabled"]],"animated","not-animated"],null]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["if"],[["get",["summonerHasActiveTrade"]]],null,6,4]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = r(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = a(n(158)),
          o = a(n(150));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function r(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (r = function (e) {
            return e ? n : t;
          })(e);
        }
        n(339),
          (e.exports = s.Ember.Component.extend({
            layout: n(340),
            classNames: ["swap-button"],
            requestInProgress: !1,
            disabled: s.Ember.computed("requestInProgress", function () {
              return !!this.get("requestInProgress") || null;
            }),
            swapTooltipText: s.Ember.computed("displayName", function () {
              return this.get("tra.service").formatString(
                "pregame_swap_tooltip",
                { actor: this.get("displayName") },
              );
            }),
            actions: {
              swap: function () {
                return (
                  o.default.playSound(
                    "sfx-ui",
                    "/fe/lol-champ-select/sounds/sfx-cs-button-swap-click.ogg",
                  ),
                  s.Telemetry.startTracingEvent("postition-swap-propose"),
                  this.set("requestInProgress", !0),
                  i.default
                    .ajax({
                      type: "POST",
                      url:
                        "/lol-champ-select/v1/session/swaps/" +
                        this.get("swapId") +
                        "/request",
                      errorMessage: "error_could_not_request_swap",
                    })
                    .then(() => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!0),
                        s.Telemetry.invokeWithLowProbability(function () {
                          s.Telemetry.recordNonTimingTracingEvent(
                            "postition-swap-propose-success",
                            1,
                            "event",
                          );
                        });
                    })
                    .catch((e) => {
                      this.recordDidRequestSucceed &&
                        this.recordDidRequestSucceed(!1, e),
                        s.Telemetry.invokeWithLowProbability(function () {
                          const t = e && e.responseText ? e.responseText : "";
                          s.DataBinding.bindTo(
                            s.default.getProvider().getSocket(),
                          )
                            .get("/lol-summoner/v1/current-summoner")
                            .then(function (e) {
                              const {
                                  accountId: n,
                                  puuid: i,
                                  summonerId: o,
                                } = e,
                                a = JSON.stringify({
                                  accountId: n,
                                  clientDateISOString: new Date().toISOString(),
                                  puuid: i,
                                  responseText: t,
                                  summonerId: o,
                                });
                              s.Telemetry.sendEvent(
                                "postition-swap-propose-fail",
                                a,
                              ),
                                s.Telemetry.recordNonTimingTracingEvent(
                                  "postition-swap-propose-fail",
                                  1,
                                  "event",
                                );
                            });
                        });
                    })
                    .finally(() => {
                      window.requestAnimationFrame(() => {
                        s.Telemetry.endTracingEvent("postition-swap-propose");
                      }),
                        this.set("requestInProgress", !1);
                    })
                );
              },
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "7+5jtdp2",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-button-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-button-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-button-component\\\\index.js\\" "],["text","\\n\\n"],["block",["if"],[["get",["summonerHasActiveSwap"]]],null,5,3]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-system"],["static-attr","class","champ-select-swap-button-tooltip"],["flush-element"],["text","\\n        "],["open-element","p",[]],["flush-element"],["append",["unknown",["swapTooltipText"]],false],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","    "],["open-element","div",[]],["static-attr","class","icon"],["flush-element"],["close-element"],["text","\\n"],["block",["uikit-tooltip"],null,[["tooltipPosition","type","restrictArea"],["top","system","whole-window"]],0]],"locals":[]},{"statements":[["block",["uikit-framed-icon"],null,[["onclick","class","interactive","borderWidth","disabled"],[["helper",["action"],[["get",[null]],"swap"],null],"position-swap-button",true,2,["get",["disabled"]]]],1]],"locals":[]},{"statements":[["block",["if"],[["get",["showPickOrderSwapButton"]]],null,2]],"locals":[]},{"statements":[["text","    "],["open-element","div",[]],["static-attr","class","icon"],["flush-element"],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-framed-icon"],null,[["class","interactive","borderWidth","disabled"],["position-swap-button-active-swap",true,2,["get",["disabled"]]]],4],["text","  "],["open-element","div",[]],["dynamic-attr","class",["concat",["pick-order-swap-ring-spinner ",["helper",["if"],[["get",["uxSettings","largeAreaAnimationsEnabled"]],"animated","not-animated"],null]]]],["flush-element"],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default =
            t.SWAP_STATES =
            t.SWAP_RESOLVED_STATES =
            t.SWAP_CREATED_STATES =
            t.SWAP_CLEAR_TIMEOUT_MS =
            t.SWAP_CANCEL_TIMEOUT_MS =
            t.SWAP_ACCEPTED_TIMEOUT_MS =
              void 0);
        var s = (function (e, t) {
            if (!t && e && e.__esModule) return e;
            if (null === e || ("object" != typeof e && "function" != typeof e))
              return { default: e };
            var n = r(t);
            if (n && n.has(e)) return n.get(e);
            var s = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e)
              if (
                "default" !== o &&
                Object.prototype.hasOwnProperty.call(e, o)
              ) {
                var a = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                a && (a.get || a.set)
                  ? Object.defineProperty(s, o, a)
                  : (s[o] = e[o]);
              }
            (s.default = e), n && n.set(e, s);
            return s;
          })(n(1)),
          i = a(n(158)),
          o = a(n(150));
        function a(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function r(e) {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap(),
            n = new WeakMap();
          return (r = function (e) {
            return e ? n : t;
          })(e);
        }
        const { RunMixin: l } = s.EmberAddons.EmberLifeline;
        n(342);
        const c = {
          RECEIVED: "RECEIVED",
          AVAILABLE: "AVAILABLE",
          SENT: "SENT",
          BUSY: "BUSY",
          DECLINED: "DECLINED",
          ACCEPTED: "ACCEPTED",
          CANCELLED: "CANCELLED",
        };
        t.SWAP_STATES = c;
        const u = [c.ACCEPTED, c.DECLINED, c.CANCELLED, c.BUSY];
        t.SWAP_RESOLVED_STATES = u;
        const m = [c.RECEIVED, c.SENT, c.BUSY];
        t.SWAP_CREATED_STATES = m;
        const d = 1e4;
        t.SWAP_CANCEL_TIMEOUT_MS = d;
        t.SWAP_CLEAR_TIMEOUT_MS = 1700;
        t.SWAP_ACCEPTED_TIMEOUT_MS = 200;
        const p = "session/swaps",
          h = "cancel",
          g = "accept",
          f = "decline",
          S = "clear";
        var b = s.Ember.Component.extend(l, {
          layout: n(343),
          init: function () {
            this._super(...arguments),
              (this.audioPool = o.default),
              this.set("isAnimated", !0);
          },
          didRender: function () {
            this._super(...arguments);
            const e = this.get("swap"),
              t = this.get("summoners");
            this.prevSwapState !== e.state
              ? (this.cancelTask(this._swapCancelTimeout),
                this.cancelTask(this._swapClearTimeout),
                e.state === c.SENT && this.scheduleSwapCancel(e.id),
                m.includes(e.state) &&
                  (this.set("isDisplayed", !0),
                  this.setSummonerName(
                    this.get("swapRequestorIndex"),
                    "requestor",
                  ),
                  this.setSummonerName(
                    this.get("swapResponderIndex"),
                    "responder",
                  ),
                  this.positionSwapDialog(this.get("swapOtherSummonerIndex"))),
                u.includes(e.state) && this.scheduleSwapClear(e.id, e.state),
                this.playSwapSfx(e.state))
              : t &&
                t[this.get("swapRequestorIndex")] &&
                t[this.get("swapResponderIndex")] &&
                (t[this.get("swapRequestorIndex")].isDonePicking ||
                  t[this.get("swapResponderIndex")].isDonePicking) &&
                this.swapServiceCall(e.id, p, h),
              (this.prevSwapState = e.state);
          },
          swapRequestorIndex: s.Ember.computed(
            "swap.requestorIndex",
            "subteamDataList",
            function () {
              return this.getCellIndex(
                this.get("swap.requestorIndex"),
                this.get("subteamDataList"),
              );
            },
          ),
          swapResponderIndex: s.Ember.computed(
            "swap.responderIndex",
            "subteamDataList",
            function () {
              return this.getCellIndex(
                this.get("swap.responderIndex"),
                this.get("subteamDataList"),
              );
            },
          ),
          swapOtherSummonerIndex: s.Ember.computed(
            "swap.otherSummonerIndex",
            "subteamDataList",
            function () {
              return this.getCellIndex(
                this.get("swap.otherSummonerIndex"),
                this.get("subteamDataList"),
              );
            },
          ),
          getCellIndex(e, t) {
            if (!t) return e;
            const n = t.find((e) => e.isLocalSubteam),
              s = n ? n.cellIds.indexOf(e) : -1;
            return s > -1 ? s : e;
          },
          setSummonerName: function (e, t) {
            const n = this.get("summoners");
            n &&
              e >= 0 &&
              n[e] &&
              n[e].displayName &&
              this.set(t, n[e].displayName);
          },
          positionSwapDialog: function (e) {
            const t = [
                ...document.querySelectorAll(
                  ".your-party .champion-icon-container",
                ),
              ][e].getBoundingClientRect(),
              n = this.element.querySelector(".swap-dialog");
            (n.style.top = t.top - 5 + "px"),
              (n.style.left = `${t.left + t.width + 15}px`);
          },
          playSwapSfx: function (e) {
            let t = "";
            switch (e) {
              case c.SENT:
              case c.RECEIVED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-swaprequest-rcvd.ogg";
                break;
              case c.ACCEPTED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-swaprequest-accepted.ogg";
                break;
              case c.DECLINED:
                t =
                  "/fe/lol-champ-select/sounds/sfx-cs-notif-swaprequest-declined.ogg";
            }
            t && this.audioPool.playSound("sfx-notifications", t);
          },
          pickOrderSwapTimeRemaining: s.Ember.computed(
            "pickOrderSwapDisabledConfigurationInSeconds",
            "timeRemaining",
            "inPlanningPhase",
            function () {
              return this.get("inPlanningPhase")
                ? d
                : Math.min(
                    1e3 *
                      (this.get("timeRemaining") -
                        this.get(
                          "pickOrderSwapDisabledConfigurationInSeconds",
                        )),
                    d,
                  );
            },
          ),
          scheduleSwapCancel: function (e) {
            const t =
              this.get("pickOrderSwapTimeRemaining") > 0
                ? this.get("pickOrderSwapTimeRemaining")
                : 0;
            this._swapCancelTimeout = this.runTask(
              () => this.swapServiceCall(e, p, h),
              t,
            );
          },
          scheduleSwapClear: function (e, t) {
            const n = t === c.ACCEPTED ? 200 : 1700;
            this._swapClearTimeout = this.runTask(
              () => (
                this.set("isDisplayed", !1),
                this.swapServiceCall(e, "ongoing-swap", S)
              ),
              n,
            );
          },
          showAcceptSwapButton: s.Ember.computed.equal(
            "swap.state",
            c.RECEIVED,
          ),
          showCancelSwapButton: s.Ember.computed.equal("swap.state", c.SENT),
          isCloseButtonDisabled: s.Ember.computed("swap.state", function () {
            return u.includes(this.get("swap.state"));
          }),
          swapStateClass: s.Ember.computed("swap.state", function () {
            return this.get("swap.state").toLowerCase();
          }),
          isSwapInProgress: s.Ember.computed("swap.state", function () {
            const e = this.get("swap.state");
            return e === c.SENT || e === c.RECEIVED;
          }),
          swapMessageString: s.Ember.computed(
            "swap.state",
            "swapWaitingString",
            "swapCanceledString",
            "swapDeclinedString",
            "swapErrorString",
            function () {
              switch (this.get("swap.state")) {
                case c.SENT:
                case c.RECEIVED:
                  return this.get("swapWaitingString");
                case c.CANCELLED:
                  return this.get("tra.pregame_swap_canceled");
                case c.DECLINED:
                  return this.get("swapDeclinedString");
                case c.BUSY:
                  return this.get("swapBusyString");
                case c.ACCEPTED:
                  return "";
                default:
                  return this.get("tra.pregame_swap_error");
              }
            },
          ),
          swapDeclinedString: s.Ember.computed(
            "responder",
            "tra.pregame_swap_declined",
            function () {
              return this.get("tra.service").formatString(
                "pregame_swap_declined",
                { actor: this.get("responder") },
              );
            },
          ),
          swapWaitingString: s.Ember.computed(
            "swap.initiatedByLocalPlayer",
            "requestor",
            "responder",
            "tra.pregame_swap_requested",
            "tra.pregame_swap_waiting",
            function () {
              const e = this.get("swap.initiatedByLocalPlayer"),
                t = this.get("requestor"),
                n = this.get("responder");
              return e
                ? this.get("tra.service").formatString("pregame_swap_waiting", {
                    actor: n,
                  })
                : this.get("tra.service").formatString(
                    "pregame_swap_requested",
                    { actor: t },
                  );
            },
          ),
          swapBusyString: s.Ember.computed(
            "responder",
            "tra.pregame_swap_error",
            function () {
              return this.get("tra.service").formatString("pregame_swap_busy", {
                actor: this.get("responder"),
              });
            },
          ),
          swapServiceCall: function (e, t, n) {
            const o = `/lol-champ-select/v1/${t}/${e}/${n}`;
            return i.default
              .ajax({
                type: "POST",
                url: o,
                errorMessage: "error_could_not_swap",
              })
              .then(() => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!0),
                  s.Telemetry.invokeWithLowProbability(function () {
                    switch (n) {
                      case g:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-swap-accept-success",
                          1,
                          "event",
                        );
                        break;
                      case h:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-swap-cancel-success",
                          1,
                          "event",
                        );
                        break;
                      case f:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-swap-decline-success",
                          1,
                          "event",
                        );
                        break;
                      case S:
                        s.Telemetry.recordNonTimingTracingEvent(
                          "champ-swap-clear-success",
                          1,
                          "event",
                        );
                    }
                  });
              })
              .catch((e) => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!1, e);
                s.DataBinding.bindTo(s.default.getProvider().getSocket())
                  .get("/lol-summoner/v1/current-summoner")
                  .then(function (t) {
                    const { accountId: i, puuid: o, summonerId: a } = t;
                    s.Telemetry.invokeWithLowProbability(function () {
                      const t = e && e.responseText ? e.responseText : "",
                        r = JSON.stringify({
                          accountId: i,
                          clientDateISOString: new Date().toISOString(),
                          puuid: o,
                          responseText: t,
                          summonerId: a,
                        });
                      switch (n) {
                        case g:
                          s.Telemetry.sendEvent("champ-swap-accept-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-swap-accept-fail",
                              1,
                              "event",
                            );
                          break;
                        case h:
                          s.Telemetry.sendEvent("champ-swap-cancel-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-swap-cancel-fail",
                              1,
                              "event",
                            );
                          break;
                        case f:
                          s.Telemetry.sendEvent("champ-swap-decline-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-swap-decline-fail",
                              1,
                              "event",
                            );
                          break;
                        case S:
                          s.Telemetry.sendEvent("champ-swap-clear-fail", r),
                            s.Telemetry.recordNonTimingTracingEvent(
                              "champ-swap-clear-fail",
                              1,
                              "event",
                            );
                      }
                    });
                  });
              });
          },
          actions: {
            acceptSwap: function (e) {
              return (
                s.Telemetry.startTracingEvent("champ-select-swap-accept"),
                this.swapServiceCall(e, p, g).finally(() => {
                  window.requestAnimationFrame(() => {
                    s.Telemetry.endTracingEvent("champ-select-swap-accept");
                  });
                })
              );
            },
            closeSwap: function (e, t) {
              return t === c.SENT
                ? this.swapServiceCall(e, p, h)
                : t === c.RECEIVED
                  ? this.swapServiceCall(e, p, f)
                  : void 0;
            },
          },
        });
        t.default = b;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "BdgTD+0I",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-dialog-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-dialog-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\swap-dialog-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["dynamic-attr","class",["concat",["swap-dialog animated ",["helper",["unless"],[["get",["showAcceptSwapButton"]],"not-received"],null]," ",["unknown",["swapStateClass"]]," ",["helper",["if"],[["get",["isDisplayed"]],"active"],null]]]],["flush-element"],["text","\\n  "],["open-element","lol-uikit-flyout-frame",[]],["static-attr","orientation","right"],["dynamic-attr","show",["unknown",["isDisplayed"]],null],["dynamic-attr","animated",["unknown",["isAnimated"]],null],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","swap-wrapper"],["flush-element"],["text","\\n      "],["open-element","div",[]],["static-attr","class","swap-container"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","swap-content-container"],["flush-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","swap-message"],["flush-element"],["append",["unknown",["swapMessageString"]],false],["close-element"],["text","\\n          "],["open-element","div",[]],["static-attr","class","button-group"],["flush-element"],["text","\\n"],["block",["if"],[["get",["showAcceptSwapButton"]]],null,2],["block",["if"],[["get",["showCancelSwapButton"]]],null,1],["text","          "],["close-element"],["text","\\n        "],["close-element"],["text","\\n      "],["close-element"],["text","\\n"],["block",["if"],[["get",["isSwapInProgress"]]],null,0],["text","    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["open-element","div",[]],["static-attr","class","swap-timer-wrapper"],["flush-element"],["text","\\n        "],["open-element","div",[]],["static-attr","class","swap-timer"],["flush-element"],["close-element"],["text","\\n      "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","            "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"closeSwap",["get",["swap","id"]],["get",["swap","state"]]],null],null],["flush-element"],["text","\\n               "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","decline-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_swap_cancel"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["text","            "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"acceptSwap",["get",["swap","id"]]],null],null],["flush-element"],["text","\\n              "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_swap_accept"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n             "],["open-element","lol-uikit-flat-button",[]],["static-attr","class","action-button"],["dynamic-attr","onclick",["helper",["action"],[["get",[null]],"closeSwap",["get",["swap","id"]],["get",["swap","state"]]],null],null],["flush-element"],["text","\\n               "],["open-element","div",[]],["static-attr","class","action-button-inner-container"],["flush-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","decline-icon"],["flush-element"],["close-element"],["text","\\n                "],["open-element","div",[]],["static-attr","class","action-text"],["flush-element"],["text","\\n                  "],["append",["unknown",["tra","pregame_swap_decline"]],false],["text","\\n                "],["close-element"],["text","\\n              "],["close-element"],["text","\\n            "],["close-element"],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(345);
        const i = s.Ember.Component.extend({
          layout: n(346),
          classNames: ["ward-skin-select-flyout"],
          contextWardSkin: s.Ember.computed(
            "hoveredWardSkin",
            "selectedWardSkin",
            function () {
              return (
                this.get("hoveredWardSkin") || this.get("selectedWardSkin")
              );
            },
          ),
          imageStyle: s.Ember.computed(
            "map.assets.champ-select-flyout-background",
            function () {
              return (
                'background-image: url("' +
                this.get("map.assets.champ-select-flyout-background") +
                '")'
              );
            },
          ),
          actions: {
            onFlyoutWardHover(e) {
              this.set("hoveredWardSkin", e);
            },
          },
        });
        e.exports = i;
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "izF2+pms",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-popup\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-popup\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-popup\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","ward-skin-details"],["dynamic-attr","style",["unknown",["imageStyle"]],null],["flush-element"],["text","\\n  "],["open-element","img",[]],["static-attr","class","ward-skin-shadow"],["dynamic-attr","src",["concat",[["unknown",["contextWardSkin","wardShadowImagePath"]]]]],["flush-element"],["close-element"],["text","\\n  "],["open-element","img",[]],["static-attr","class","ward-skin-image"],["dynamic-attr","src",["concat",[["unknown",["contextWardSkin","wardImagePath"]]]]],["flush-element"],["close-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","ward-skin-name"],["flush-element"],["text","\\n    "],["append",["unknown",["contextWardSkin","name"]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["open-element","lol-uikit-scrollable",[]],["static-attr","class","ward-skins"],["static-attr","overflow-masks","enabled"],["flush-element"],["text","\\n"],["block",["each"],[["get",["wardSkins"]]],null,1],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","      "],["append",["helper",["flyout-selector-popup-button"],null,[["item","selectedItem","onFlyoutItemSelected","onFlyoutItemHover"],[["get",["wardSkin"]],["get",["selectedWardSkin"]],["get",["onWardSkinConfirmed"]],["helper",["action"],[["get",[null]],"onFlyoutWardHover"],null]]]],false],["text","\\n"]],"locals":[]},{"statements":[["block",["unless"],[["get",["wardSkin","locked"]]],null,0]],"locals":["wardSkin"]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1),
          i = n(152),
          o = r(n(150));
        n(348);
        var a = r(n(158));
        function r(e) {
          return e && e.__esModule ? e : { default: e };
        }
        const l = s.UiKitPlugin.getFlyoutManager();
        e.exports = s.Ember.Component.extend({
          layout: n(349),
          classNames: ["ward-skin-container"],
          loadoutsService: s.Ember.inject.service("loadouts"),
          wardSkinIndex: 0,
          disabled: !1,
          useLoadouts: !1,
          isFlyoutOpen: !1,
          didUserChangeItem: !1,
          flyoutImageStyle: s.Ember.computed(
            "map.assets.champ-select-flyout-background",
            function () {
              return (
                'background-image: url("' +
                this.get("map.assets.champ-select-flyout-background") +
                '")'
              );
            },
          ),
          wardSkinDisabledTooltipText: s.Ember.computed(
            "isDonePicking",
            function () {
              return this.get("isDonePicking")
                ? this.get("tra.ward_skin_button_disabled")
                : this.get("tra.ward_skin_button_disabled_not_done_picking");
            },
          ),
          init: function () {
            this._super(...arguments);
            this.set("flyoutOptions", {
              targetAnchor: { x: "center", y: "top" },
              tooltipAnchor: { x: "center", y: "bottom" },
              offset: { x: 0, y: -20 },
              backdropCutout: null,
              orientation: "top",
              animated: !1,
            });
          },
          setWardSkinViaPlatform: function (e) {
            a.default
              .ajax({
                url: "/lol-champ-select/v1/session/my-selection",
                contentType: "application/json",
                data: JSON.stringify({ wardSkinId: e.get("id") }),
                method: "PATCH",
                errorMessage: "error_could_not_set_ward_skin",
              })
              .then(() => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!0);
              })
              .catch((e) => {
                this.recordDidRequestSucceed &&
                  this.recordDidRequestSucceed(!1, e);
              });
          },
          actions: {
            toggleFlyout(e) {
              const t = this.get("wardSkins").indexOf(e.selectedItem);
              -1 === t
                ? this.set("isFlyoutOpen", !1)
                : (l.repositionCaret(0),
                  this.get("isFlyoutOpen") ||
                    o.default.playSound(
                      i.SFX_CHANNEL,
                      `${i.SOUNDS_PATH}/sfx-cs-spells-open.ogg`,
                    ),
                  this.set("wardSkinIndex", t),
                  this.set("isFlyoutOpen", !this.get("isFlyoutOpen")));
            },
            onWardSkinConfirmed(e) {
              s.Ember.get(e, "locked") ||
                (s.Telemetry.startTimer("champ-select-ward-skin-selected"),
                s.Telemetry.sendEvent("champ-select-ward-skin-selected"),
                o.default.playSound(
                  i.SFX_CHANNEL,
                  `${i.SOUNDS_PATH}/sfx-cs-ward-select.ogg`,
                ),
                this.get("useLoadouts")
                  ? this.get("loadoutsService").setWardSkinViaLoadouts(
                      e,
                      this.get("accountLoadout.id"),
                      this.recordDidRequestSucceed,
                    )
                  : this.setWardSkinViaPlatform(e),
                this.set("isFlyoutOpen", !1),
                this.set("didUserChangeItem", !0));
            },
            afterUserChangedItemAnimation() {
              this.set("didUserChangeItem", !1);
            },
          },
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "bZHFP2aF",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-select-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-select-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\ward-skin-select-component\\\\index.js\\" "],["text","\\n"],["append",["helper",["flyout-selector-trigger-button"],null,[["selectedItem","toggleFlyout","disabled","imageStyle","didUserChangeItem","afterUserChangedItemAnimation"],[["get",["selectedWardSkin"]],["helper",["action"],[["get",[null]],"toggleFlyout"],null],["get",["disabled"]],["get",["flyoutImageStyle"]],["get",["didUserChangeItem"]],["helper",["action"],[["get",[null]],"afterUserChangedItemAnimation"],null]]]],false],["text","\\n"],["open-element","lc-flyout",[]],["dynamic-attr","open",["unknown",["isFlyoutOpen"]],null],["dynamic-attr","onHide",["helper",["action"],[["get",[null]],"toggleFlyout"],null],null],["dynamic-attr","uiKitOptionOverrides",["unknown",["flyoutOptions"]],null],["flush-element"],["text","\\n  "],["open-element","lc-flyout-content",[]],["flush-element"],["text","\\n    "],["append",["helper",["ward-skin-popup"],null,[["selectedWardSkin","wardSkins","map","onWardSkinConfirmed"],[["get",["selectedWardSkin"]],["get",["wardSkins"]],["get",["map"]],["helper",["action"],[["get",[null]],"onWardSkinConfirmed"],null]]]],false],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"],["block",["if"],[["get",["disabled"]]],null,1]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","    "],["open-element","lol-uikit-content-block",[]],["static-attr","type","tooltip-small"],["static-attr","class","champ-select-edit-ward-skin-tooltip"],["flush-element"],["text","\\n      "],["open-element","p",[]],["flush-element"],["append",["unknown",["wardSkinDisabledTooltipText"]],false],["close-element"],["text","\\n    "],["close-element"],["text","\\n"]],"locals":[]},{"statements":[["block",["uikit-tooltip"],null,[["tooltipPosition","type","offsetY"],["top","system",22]],0]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        var s = n(1);
        n(351),
          (e.exports = s.Ember.Component.extend({
            layout: n(352),
            classNames: ["missions-tracker-button-component"],
            missionsButton: null,
            missionsButtonEnabled: s.Ember.computed(
              "jmxSettings",
              "jmxSettings.Missions.MissionsEnabled",
              "jmxSettings.Missions.MissionsFrontEndEnabled",
              "entitlements.entitlements.[]",
              function () {
                let e = !1,
                  t = !1;
                this.get("jmxSettings") &&
                  ((e =
                    !1 !== this.get("jmxSettings.Missions.MissionsEnabled")),
                  (t =
                    !1 !==
                    this.get("jmxSettings.Missions.MissionsFrontEndEnabled")));
                const n = this.get("entitlements.entitlements"),
                  s =
                    n &&
                    n.includes("urn:entitlement:globalriot.missions.enabled");
                return e && (t || s);
              },
            ),
            click() {
              s.Telemetry.recordNonTimingTracingEvent(
                "champ-select-missions-button-click",
                1,
                "click",
              );
            },
          }));
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "7i2ch6pZ",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\missions-tracker-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\missions-tracker-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\missions-tracker-component\\\\index.js\\" "],["text","\\n"],["block",["if"],[["get",["missionsButtonEnabled"]]],null,0]],"locals":[],"named":[],"yields":[],"blocks":[{"statements":[["text","  "],["append",["unknown",["missions-button"]],false],["text","\\n"]],"locals":[]}],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        n(354);
        const s = n(1),
          { Ember: i } = s;
        e.exports = i.Component.extend({
          classNames: ["vote-reveal"],
          classNameBindings: ["visible:visible:removed"],
          layout: n(355),
          voteRevealLabel: i.computed.readOnly("tra.vote_reveal_message"),
          championName: i.computed.readOnly("summoner.champion.name"),
        });
      },
      (e, t, n) => {
        "use strict";
        n.r(t);
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "psh2B/F2",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\vote-reveal-component\\\\layout.hbs\\" style-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\vote-reveal-component\\\\style.styl\\" js-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\vote-reveal-component\\\\index.js\\" "],["text","\\n"],["open-element","div",[]],["static-attr","class","vote-reveal-label"],["flush-element"],["text","\\n  "],["open-element","div",[]],["static-attr","class","vote-reveal-text"],["flush-element"],["text","\\n    "],["append",["unknown",["voteRevealLabel"]],false],["text","\\n    "],["open-element","div",[]],["static-attr","class","text-glow"],["flush-element"],["text","\\n      "],["append",["unknown",["voteRevealLabel"]],false],["text","\\n    "],["close-element"],["text","\\n  "],["close-element"],["text","\\n\\n  "],["open-element","div",[]],["static-attr","class","vote-reveal-champion-name-wrapper"],["flush-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","line line-left"],["flush-element"],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","vote-reveal-champion-name-text vote-reveal-champion-name"],["flush-element"],["text","\\n      "],["append",["unknown",["championName"]],false],["text","\\n      "],["open-element","div",[]],["static-attr","class","text-glow vote-reveal-champion-name"],["flush-element"],["text","\\n        "],["append",["unknown",["championName"]],false],["text","\\n      "],["close-element"],["text","\\n    "],["close-element"],["text","\\n    "],["open-element","div",[]],["static-attr","class","line line-right"],["flush-element"],["close-element"],["text","\\n  "],["close-element"],["text","\\n"],["close-element"],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s,
          i = n(1),
          o = n(357),
          a = (s = n(150)) && s.__esModule ? s : { default: s };
        const { RunMixin: r } = i.EmberAddons.EmberLifeline,
          l = new Set([
            "champion-ban-vo",
            "champion-pick-vo",
            "champion-stinger-sfx",
          ]);
        var c = i.Ember.Service.extend(r, {
          audioPool: a.default,
          init() {
            this._super(...arguments),
              (this._champVoChannelByName = {}),
              (this._sfxTimeoutByPath = {}),
              (this._champSelectScreenRoot =
                i.ViewportPlugin.fullScreen().getScreenRoot(
                  "rcp-fe-lol-champ-select",
                )),
              this.setupScreenRootListeners();
          },
          willDestroy() {
            this._super(...arguments),
              this._champSelectBinding.unobserve("/v1/sfx-notifications", this),
              this.stopAllAudio();
          },
          initDataBindings() {
            (this._champSelectBinding = (0, i.DataBinding)(
              "/lol-champ-select",
              (0, i.getProvider)().getSocket(),
            )),
              this._champSelectBinding.observe(
                "/v1/sfx-notifications",
                this,
                this.handleSfxNotifications.bind(this),
              );
          },
          setupScreenRootListeners() {
            this._champSelectScreenRoot.on("hide", () => this.stopAllAudio());
          },
          getChampVoChannel(e) {
            return (
              this._champVoChannelByName[e] ||
                (this._champVoChannelByName[e] = i.AudioPlugin.getChannel(e)),
              this._champVoChannelByName[e]
            );
          },
          handleSfxNotifications(e) {
            (e || []).forEach((e) => {
              const { eventType: t } = e;
              l.has(t) ? this.playChampionSfx(e) : this.playChampSelectSfx(e);
            });
          },
          playChampSelectSfx(e) {
            const { delayMillis: t, eventType: n } = e,
              { path: s, playOptions: i } = o.soundOptionsByEventType[n];
            this._sfxTimeoutByPath[s] = this.runTask(() => {
              this.audioPool.playSound(o.defaultSfxChannel, s, i),
                delete this._sfxTimeoutByPath[s];
            }, t);
          },
          playChampionSfx(e) {
            const { path: t, eventType: n, delayMillis: s } = e,
              { channelName: i, playOptions: a } = o.soundOptionsByEventType[n],
              r = this.getChampVoChannel(i);
            this._sfxTimeoutByPath[t] = this.runTask(() => {
              a.shouldStopChannelAudio && this.stopChannelAudio(r),
                r.playSound(t, a),
                delete this._sfxTimeoutByPath[t];
            }, s);
          },
          stopChannelAudio: (e) =>
            Promise.all(
              e.playingSounds.map((e) => e.stop().then(() => e.dispose())),
            ),
          stopAllAudio: function () {
            return (
              Object.keys(this._sfxTimeoutByPath).forEach((e) => {
                this.cancelTask(this._sfxTimeoutByPath[e]);
              }),
              (this._sfxTimeoutByPath = {}),
              Promise.all(
                Object.keys(this._champVoChannelByName).map((e) => {
                  const t = this._champVoChannelByName[e];
                  return this.stopChannelAudio(t);
                }),
              )
            );
          },
        });
        t.default = c;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.soundOptionsByEventType = t.defaultSfxChannel = void 0);
        t.defaultSfxChannel = "sfx-notifications";
        const n = { shouldStopChannelAudio: !0, shouldDuckOtherChannels: !0 },
          s = {
            "draft-my-team-first-pick-notif": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-left-first-pick.ogg",
            },
            "draft-their-team-first-pick-notif": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-right-first-pick.ogg",
            },
            "draft-my-pick-sniped": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-your-pick-denied.ogg",
            },
            "draft-pick-locked-in-my-team-single": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-left-pick-single.ogg",
            },
            "draft-pick-locked-in-their-team-single": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-right-pick-single.ogg",
            },
            "ten-bans-my-ban-completed": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-your-ban.ogg",
            },
            "ten-bans-ally-ban-completed": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-10ban-ally-ban.ogg",
              playOptions: { maxConcurrent: 5 },
            },
            "my-turn-to-ban": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-notif-yourban.ogg",
            },
            "my-turn-to-pick": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-notif-yourpick.ogg",
            },
            "serial-bans-ally-ban-completed": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-ban-your-team.ogg",
            },
            "serial-bans-enemy-ban-completed": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-ban-enemy-team.ogg",
            },
            "champion-ban-vo": {
              path: "",
              channelName: "vo-ban-champion",
              playOptions: n,
            },
            "champion-pick-vo": {
              path: "",
              channelName: "vo-pick-champion",
              playOptions: n,
            },
            "champion-stinger-sfx": {
              path: "",
              channelName: "sfx-champions",
              playOptions: { duckOtherChannels: !0 },
            },
            "pin-drop-local-player": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-player.ogg",
            },
            "pin-drop-ally-0": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-ally-0.ogg",
            },
            "pin-drop-ally-1": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-ally-1.ogg",
            },
            "pin-drop-ally-2": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-ally-2.ogg",
            },
            "pin-drop-ally-3": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-ally-3.ogg",
            },
            "pin-drop-ally-4": {
              path: "/fe/lol-champ-select/sounds/sfx-cs-draft-posassign-ally-4.ogg",
            },
          };
        t.soundOptionsByEventType = s;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s,
          i = n(1),
          o = n(152),
          a = (s = n(164)) && s.__esModule ? s : { default: s };
        const { RunMixin: r } = i.EmberAddons.EmberLifeline;
        var l = i.Ember.Service.extend(r, a.default, {
          init: function () {
            this._super(...arguments),
              (this.champSelectBinding = (0, i.DataBinding)(
                "/lol-champ-select",
                (0, i.getProvider)().getSocket(),
              )),
              this.champSelectBinding.observe(
                "/v1/session",
                this,
                this._handleChampSelectSession,
              );
          },
          _handleChampSelectSession: function (e) {
            e &&
              (this._setToConnected(),
              this._cancelDisconnectTimeouts(),
              this._createDisconnectTimeout(
                e.timer.adjustedTimeLeftInPhase + this._getDisconnectDelayMs(),
              ),
              this._createDisconnectShouldExitTimeout(
                e.timer.adjustedTimeLeftInPhase +
                  this._getDisconnectShouldExitDelayMs(),
              ),
              (this._session = e));
          },
          _setToConnected: function () {
            this.set("isDisconnected", !1), this._setDisconnectShouldExit(!1);
          },
          _getDisconnectDelayMs: function () {
            const e = this.get(
              "jmxSettings.LcuChampionSelect.DisconnectDelayMs",
            );
            return e || o.DEFAULT_DISCONNECT_DELAY_MS;
          },
          _getDisconnectShouldExitDelayMs: function () {
            const e = this.get(
              "jmxSettings.LcuChampionSelect.DisconnectShouldExitDelayMs",
            );
            return e || o.DEFAULT_DISCONNECT_SHOULD_EXIT_DELAY_MS;
          },
          _cancelDisconnectTimeouts: function () {
            this.cancelTask(this._setDisconnectTimeout),
              this.cancelTask(this._setDisconnectShouldExitTimeout),
              (this._setDisconnectTimeout = null),
              (this._setDisconnectShouldExitTimeout = null);
          },
          _createDisconnectTimeout: function (e) {
            this._setDisconnectTimeout = this.runTask(() => {
              this.set("isDisconnected", !0);
            }, e);
          },
          _createDisconnectShouldExitTimeout: function (e) {
            this._setDisconnectShouldExitTimeout = this.runTask(() => {
              this._setDisconnectShouldExit(!0);
            }, e);
          },
          _setDisconnectShouldExit: function (e) {
            this.set("disconnectShouldExit", e);
            const t = this._disconnectShouldExitCallback;
            t && t(e);
          },
          setDisconnectShouldExitCallback: function (e) {
            this._disconnectShouldExitCallback = e;
          },
          receivedServiceCallResponse: function (e = null) {
            if (!this._session) return;
            const t = this.get("isDisconnected");
            t && !e
              ? (this._cancelDisconnectTimeouts(),
                this._setToConnected(),
                this._createDisconnectTimeout(
                  this._session.timer.adjustedTimeLeftInPhase +
                    this._getDisconnectDelayMs(),
                ),
                this._createDisconnectShouldExitTimeout(
                  this._session.timer.adjustedTimeLeftInPhase +
                    this._getDisconnectShouldExitDelayMs(),
                ))
              : !t &&
                this._isDisconnectError(e) &&
                (this._cancelDisconnectTimeouts(),
                this._createDisconnectTimeout(0),
                this._createDisconnectShouldExitTimeout(
                  this._session.timer.adjustedTimeLeftInPhase +
                    this._getDisconnectShouldExitDelayMs(),
                ));
          },
          _isDisconnectError: function (e) {
            if (e && e.responseJSON && e.responseJSON.message) {
              const t = e.responseJSON.message;
              for (const e in o.DISCONNECT_ERROR_INDICATORS)
                if (t.includes(e)) return !0;
            }
            return !1;
          },
        });
        t.default = l;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = s.Ember.Service.extend({
            init: function () {
              this._super(...arguments),
                (this.champSelectBinding = (0, s.DataBinding)(
                  "/lol-champ-select",
                  (0, s.getProvider)().getSocket(),
                )),
                this.champSelectBinding.observe(
                  "/v1/pickable-champion-ids",
                  this,
                  this.handlePickableChampionIds,
                ),
                this.champSelectBinding.observe(
                  "/v1/bannable-champion-ids",
                  this,
                  this.handleBannableChampionIds,
                );
            },
            handlePickableChampionIds: function (e) {
              this.set("pickableChampionSet", new Set(e || []));
            },
            handleBannableChampionIds: function (e) {
              this.set("bannableChampionSet", new Set(e || []));
            },
          });
        t.default = i;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = s.Ember.Service.extend({
            init: function () {
              this._super(...arguments),
                (this.inventoryBinding = (0, s.DataBinding)(
                  "/lol-inventory",
                  (0, s.getProvider)().getSocket(),
                )),
                this.inventoryBinding.observe(
                  "/v2/inventory/SKIN_AUGMENT",
                  this,
                  this.handleSkinAugments,
                );
            },
            willDestroy() {
              this._super(...arguments),
                this.inventoryBinding.unobserve(
                  "/v2/inventory/SKIN_AUGMENT",
                  this,
                );
            },
            ownedSkinAugments: {},
            handleSkinAugments: function (e) {
              const t = e.reduce((e, t) => ((e[t.uuid] = t.owned), e), {});
              this.set("ownedSkinAugments", t);
            },
          });
        t.default = i;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = s.Ember.Service.extend({
            _chatBinding: null,
            _champSelectBinding: null,
            _loginBinding: null,
            _gameflowBinding: null,
            _callbacks: null,
            conversationId: null,
            summonerId: 0,
            currentPhase: null,
            init() {
              this._super(...arguments),
                (this._callbacks = new Map()),
                (this._chatBinding = (0, s.DataBinding)(
                  "/lol-chat",
                  (0, s.getProvider)().getSocket(),
                )),
                (this._champSelectBinding = (0, s.DataBinding)(
                  "/lol-champ-select",
                  (0, s.getProvider)().getSocket(),
                )),
                (this._loginBinding = (0, s.DataBinding)(
                  "/lol-login",
                  (0, s.getProvider)().getSocket(),
                )),
                (this._gameflowBinding = (0, s.DataBinding)(
                  "/lol-gameflow",
                  (0, s.getProvider)().getSocket(),
                )),
                this._loginBinding.observe("/v1/session", this, (e) => {
                  e && e.summonerId && this.set("summonerId", e.summonerId);
                }),
                this._gameflowBinding.observe("/v1/session", this, (e) => {
                  if (e && e.phase) {
                    const t = this.get("currentPhase");
                    "ChampSelect" === e.phase && "ChampSelect" !== t
                      ? this._chatBinding.observe(
                          "/v1/conversations",
                          this,
                          this._handleChatConversationUpdate.bind(this),
                        )
                      : "ChampSelect" !== e.phase &&
                        "ChampSelect" === t &&
                        this._unobserveSessionBindings(),
                      this.set("currentPhase", e.phase);
                  }
                });
            },
            _getParticipantsUrl: function () {
              return `/v1/conversations/${this.get("conversationId")}/participants`;
            },
            _handleChatConversationUpdate: function (e) {
              if (!e || !e.length) return;
              const t = e.find((e) => "championSelect" === e.type);
              if (t && t.id) {
                const e = encodeURIComponent(t.id);
                this.set("conversationId", e),
                  this._chatBinding.observe(
                    this._getParticipantsUrl(),
                    this,
                    this._handleChatParticipantsUpdate.bind(this),
                  );
              }
            },
            _handleChatParticipantsUpdate: function (e) {
              if (e) {
                e.find((e) => e.summonerId === this.get("summonerId")) &&
                  this._champSelectBinding.observe(
                    "/v1/session",
                    this,
                    this._handleChampSelectSessionUpdate.bind(this),
                  );
              }
            },
            _handleChampSelectSessionUpdate: function (e) {
              for (const t of this._callbacks.values()) t(e);
            },
            registerSessionChangeCallback: function (e, t) {
              this._callbacks.set(e, t);
            },
            _unobserveSessionBindings: function () {
              this._chatBinding &&
                (this._chatBinding.unobserve("/v1/conversations", this),
                this.get("conversationId") &&
                  (this._chatBinding.unobserve(
                    this._getParticipantsUrl(),
                    this,
                  ),
                  this.set("conversationId", void 0))),
                this._champSelectBinding &&
                  this._champSelectBinding.unobserve("/v1/session", this);
            },
            removeSessionChangeCallback: function (e) {
              this._callbacks.has(e) && this._callbacks.delete(e);
            },
            sendChatMessage: function (e, t = "celebration") {
              const n = this.get("conversationId");
              if (!n || !this.get("summonerId"))
                return Promise.reject(
                  "Unresolved conversationId or summonerId",
                );
              const s = { body: e, type: t };
              return this._chatBinding.post(
                `/v1/conversations/${n}/messages`,
                s,
              );
            },
          });
        t.default = i;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s,
          i = (s = n(158)) && s.__esModule ? s : { default: s };
        const o = n(1),
          { Ember: a } = o,
          { Telemetry: r } = o;
        var l = a.Service.extend({
          setWardSkinViaLoadouts: function (e, t, n) {
            const s = r.startTimer("champ-select-ward-skin-selected");
            t
              ? this.updateLoadout({
                  wardSkinId: e.get("id"),
                  accountLoadoutId: t,
                  timerId: s,
                  recordDidRequestSucceed: n,
                })
              : this.createNewAccountLoadout({
                  wardSkinId: e.get("id"),
                  timerId: s,
                  recordDidRequestSucceed: n,
                });
          },
          updateLoadout: function ({
            accountLoadoutId: e,
            wardSkinId: t,
            timerId: n,
            recordDidRequestSucceed: s,
          }) {
            const o = {
              id: e,
              loadout: {
                WARD_SKIN_SLOT: { inventoryType: "WARD_SKIN", itemId: t },
              },
            };
            i.default
              .ajax({
                url: `/lol-loadouts/v4/loadouts/${e}`,
                contentType: "application/json",
                data: JSON.stringify(o),
                method: "PATCH",
                errorMessage: "error_could_not_set_ward_skin",
              })
              .catch((e) => {
                s && s(!1, e),
                  this.isDestroying ||
                    this.isDestroyed ||
                    this.set("setSelectedError", !0);
              })
              .then(() => {
                s && s(!0), r.stopAndRecordTimer(n);
              });
          },
          createNewAccountLoadout: function ({
            wardSkinId: e,
            timerId: t,
            recordDidRequestSucceed: n,
          }) {
            const s = {
              scope: "ACCOUNT",
              loadout: {
                WARD_SKIN_SLOT: { inventoryType: "WARD_SKIN", itemId: e },
              },
            };
            i.default
              .ajax({
                url: "/lol-loadouts/v4/loadouts",
                contentType: "application/json",
                data: JSON.stringify(s),
                method: "POST",
                errorMessage: "error_could_not_set_ward_skin",
              })
              .catch((e) => {
                n && n(!1, e),
                  this.isDestroying ||
                    this.isDestroyed ||
                    this.set("setSelectedError", !0);
              })
              .then(() => {
                n && n(!0), r.stopAndRecordTimer(t);
              });
          },
        });
        t.default = l;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s,
          i = n(1),
          o = n(152),
          a = (s = n(158)) && s.__esModule ? s : { default: s },
          r = n(364);
        var l = i.Ember.Service.extend({
          init: function () {
            this._super(...arguments),
              (this.binding = i.DataBinding.bindTo(
                (0, i.getProvider)().getSocket(),
              )),
              this.binding.observe(
                "/lol-inventory/v2/inventory/CHAMPION_SKIN",
                this,
                this.handleSkinInventoryUpdate,
              ),
              this.binding.observe(
                "/lol-gameflow/v1/session",
                this,
                this.handleGameflowSessionUpdate,
              );
          },
          getSkinPurchaseCallback(e) {
            return () => {
              i.logger.trace(
                `Skin purchase successful. Setting last purchased skin to: ${e}`,
              ),
                (this._lastPurchasedSkinId = e);
            };
          },
          openPAWModal: function (e, t) {
            t && (this._recordDidRequestSucceed = t);
            const n = this.getSkinPurchaseCallback(e && e.itemId);
            if (e && e.tags && e.tags.includes(o.QUEST_SKIN_TAG)) {
              const t = {
                templateType: r.PAW.TEMPLATE_TYPES.LARGE_TWO_COLUMN_LANDSCAPE,
              };
              i.PurchaseAnywhereApi.createPawTemplateModalAsync(
                e.offerId,
                t,
                o.CHAMP_SELECT_PAW_SOURCE,
              ).then(() => {
                i.PurchaseAnywhereApi.getBaseSkinLineData(e.offerId).then(
                  (e) => {
                    (e.onPurchaseComplete = n),
                      i.PurchaseAnywhereApi.populatePawTemplateModal(e);
                  },
                );
              });
            } else
              i.PurchaseAnywhereApi.createPAWModal(
                {
                  itemId: e.itemId,
                  inventoryType: r.PAW.INVENTORY_TYPES.CHAMPION_SKIN,
                },
                o.CHAMP_SELECT_PAW_SOURCE,
                r.PAW.MODAL_TYPES.CHROMA_MODAL,
                null,
                n,
              );
          },
          handleSkinInventoryUpdate: function (e) {
            if (
              this.gameflowPhase === o.GAMEFLOW_PHASE_CHAMP_SELECT &&
              this._lastPurchasedSkinId
            ) {
              const t = (e || []).find(
                (e) => e.itemId === this._lastPurchasedSkinId,
              );
              return t
                ? this.updateInventoryAndSelectSkin(t.itemId)
                : (i.logger.trace(
                    `Inventory update did not contain skin that was purchased in champ select ${this._lastPurchasedSkinId}`,
                  ),
                  this.updateSimpleInventory());
            }
          },
          handleGameflowSessionUpdate: function (e) {
            const { phase: t } = e;
            t !== o.GAMEFLOW_PHASE_CHAMP_SELECT &&
              (this._lastPurchasedSkinId = void 0),
              (this.gameflowPhase = t);
          },
          updateInventoryAndSelectSkin(e) {
            return this.updateSimpleInventory().then(
              () => {
                this.setSkin(e);
              },
              () => {
                this.setSkin(e);
              },
            );
          },
          updateSimpleInventory: function () {
            return (
              i.logger.trace("Updating inventory."),
              this.binding.post("/lol-champ-select/v1/session/simple-inventory")
            );
          },
          setSkin: function (e) {
            const t = this._recordDidRequestSucceed;
            return a.default
              .ajax({
                url: "/lol-champ-select/v1/session/my-selection",
                contentType: "application/json",
                data: JSON.stringify({ selectedSkinId: e }),
                method: "PATCH",
                errorMessage: "error_could_not_set_skin",
              })
              .then(() => {
                t && t(!0);
              })
              .catch((e) => {
                t && t(!1, e);
              });
          },
        });
        t.default = l;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          Object.defineProperty(t, "PAW", {
            enumerable: !0,
            get: function () {
              return s.default;
            },
          }),
          Object.defineProperty(t, "PROFILE_PRIVACY", {
            enumerable: !0,
            get: function () {
              return l.default;
            },
          }),
          Object.defineProperty(t, "QUEUES", {
            enumerable: !0,
            get: function () {
              return i.default;
            },
          }),
          Object.defineProperty(t, "REWARD_TRACKER", {
            enumerable: !0,
            get: function () {
              return o.default;
            },
          }),
          Object.defineProperty(t, "SETTINGS", {
            enumerable: !0,
            get: function () {
              return r.default;
            },
          }),
          Object.defineProperty(t, "SOCIAL", {
            enumerable: !0,
            get: function () {
              return a.default;
            },
          }),
          Object.defineProperty(t, "TIME", {
            enumerable: !0,
            get: function () {
              return c.default;
            },
          });
        var s = u(n(365)),
          i = u(n(376)),
          o = u(n(377)),
          a = u(n(378)),
          r = u(n(379)),
          l = u(n(380)),
          c = u(n(381));
        function u(e) {
          return e && e.__esModule ? e : { default: e };
        }
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = p(n(366)),
          i = p(n(367)),
          o = p(n(368)),
          a = p(n(369)),
          r = p(n(370)),
          l = p(n(371)),
          c = p(n(372)),
          u = p(n(373)),
          m = p(n(374)),
          d = p(n(375));
        function p(e) {
          return e && e.__esModule ? e : { default: e };
        }
        var h = {
          COMPONENT_TYPES: s.default,
          CURRENCY_TYPES: i.default,
          INVENTORY_TYPES: o.default,
          MEDIA_TYPES: a.default,
          MEDIA_LOAD_TYPES: r.default,
          MODAL_TYPES: l.default,
          OFFER_PURCHASE_STATES: c.default,
          OFFER_VALIDATION_STATES: u.default,
          SCROLL_LIST_DISPLAY_TYPES: m.default,
          TEMPLATE_TYPES: d.default,
        };
        t.default = h;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          TEXT: "TEXT",
          TITLE_SUBTITLE: "TITLE_SUBTITLE",
          PURCHASE: "PURCHASE",
          MEDIA: "MEDIA",
          IMAGE_CAROUSEL: "IMAGE_CAROUSEL",
          SCROLL_LIST: "SCROLL_LIST",
          VERTICAL_LIST: "VERTICAL_LIST",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = { RP: "RP", IP: "IP", BE: "lol_blue_essence" };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          CHAMPION: "CHAMPION",
          CHAMPION_SKIN: "CHAMPION_SKIN",
          WARD_SKIN: "WARD_SKIN",
          BATTLE_BOOST: "BATTLE_BOOST",
          GIFT: "GIFT",
          MYSTERY: "MYSTERY",
          BUNDLES: "BUNDLES",
          SUMMONER_ICON: "SUMMONER_ICON",
          STATSTONE: "STATSTONE",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = { SVG: "SVG", IMAGE: "IMAGE", VIDEO: "VIDEO" };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          LOCAL_ASSET: "LOCAL_ASSET",
          EXTERNAL_URL: "EXTERNAL_URL",
          GAME_DATA: "GAME_DATA",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          CHAMPION_MODAL: "CHAMPION_MODAL",
          SKIN_VIEWER_MODAL: "SKIN_VIEWER_MODAL",
          MULTIPLE_PURCHASE_MODAL: "MULTIPLE_PURCHASE_MODAL",
          CHROMA_MODAL: "CHROMA_MODAL",
          CHROMA_BUNDLE_MODAL: "CHROMA_BUNDLE_MODAL",
          SUMMONER_ICON_MODAL: "SUMMONER_ICON_MODAL",
          WARD_SKIN_MODAL: "WARD_SKIN_MODAL",
          SKIN_WITH_DEPENDENCY_MODAL: "SKIN_WITH_DEPENDENCY_MODAL",
          PAW_GENERIC_MODAL: "PAW_GENERIC_MODAL",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          NOT_STARTED: "NOT_STARTED",
          IN_PROGRESS: "IN_PROGRESS",
          SUCCESS: "SUCCESS",
          FAIL: "FAIL",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          NOT_STARTED: "NOT_STARTED",
          IN_PROGRESS: "IN_PROGRESS",
          COMPLETED: "COMPLETED",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          EXPANDED: "EXPANDED",
          COMPACT: "COMPACT",
          DETAILED: "DETAILED",
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = { LARGE_TWO_COLUMN_LANDSCAPE: "LARGE_TWO_COLUMN_LANDSCAPE" };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        const n = "RANKED_SOLO_5x5",
          s = "RANKED_FLEX_SR",
          i = "RANKED_FLEX_TT",
          o = "CHERRY",
          a = "RANKED_TFT",
          r = "RANKED_TFT_DOUBLE_UP",
          l = "RANKED_TFT_TURBO",
          c = "RANKED_TFT_PAIRS",
          u = [n, s],
          m = [...u, i],
          d = [o],
          p = [a, r],
          h = [l, c],
          g = [...p, ...h],
          f = [...m, ...p],
          S = [...h, ...d];
        var b = {
          RANKED_SOLO_5x5_QUEUE_TYPE: n,
          RANKED_FLEX_SR_QUEUE_TYPE: s,
          RANKED_FLEX_TT_QUEUE_TYPE: i,
          RANKED_CHERRY_QUEUE_TYPE: o,
          RANKED_TFT_QUEUE_TYPE: a,
          RANKED_TFT_DOUBLE_UP_QUEUE_TYPE: r,
          RANKED_TFT_TURBO_QUEUE_TYPE: l,
          RANKED_TFT_PAIRS_QUEUE_TYPE: c,
          RANKED_LOL_QUEUE_TYPES: m,
          RANKED_SR_QUEUE_TYPES: u,
          RANKED_TFT_QUEUE_TYPES: p,
          RATED_TFT_QUEUE_TYPES: h,
          RANKED_AND_RATED_TFT_QUEUE_TYPES: g,
          ALL_RANKED_QUEUE_TYPES: f,
          ALL_RATED_QUEUE_TYPES: S,
          ALL_RANKED_AND_RATED_QUEUE_TYPES: [...f, ...S],
        };
        t.default = b;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = {
          REWARD_TAGS: {
            INSTANT: "Instant",
            RARE: "Rare",
            CHOICE: "Choice",
            MULTIPLE: "Multiple",
          },
          MILESTONE_STAGES: {
            COMPLETED: "completed",
            CURRENT: "current",
            FUTURE: "future",
            HOVERING_COMPLETED: "future-completed",
          },
          REWARD_STATE: {
            LOCKED: "Locked",
            UNLOCKED: "Unlocked",
            UNSELECTED: "Unselected",
            SELECTED: "Selected",
          },
          TRACKER_SIZE: {
            SMALL: "tracker-size-small",
            MEDIUM: "tracker-size-medium",
          },
          REWARD_OPTION_HEADER_TYPE: {
            FREE: "FREE",
            PREMIUM: "PREMIUM",
            NONE: "NONE",
          },
        };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = { DEFAULT_SUMMONER_ICON_ID: 29 };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var n = { AUTO: "auto", ALWAYS: "always", NEVER: "never" };
        t.default = n;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        const n = {
            UNKNOWN: "UNKNOWN",
            ENABLED: "ENABLED",
            DISABLED: "DISABLED",
          },
          s = { PRIVATE: "PRIVATE", PUBLIC: "PUBLIC" };
        var i = {
          ProfilePrivacyEnabledState: n,
          ProfilePrivacySetting: s,
          DEFAULT_PROFILE_PRIVACY: {
            enabledState: n.UNKNOWN,
            setting: s.PUBLIC,
          },
        };
        t.default = i;
      },
      (e, t) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = t.TIME_UNITS = t.TIME_CONVERSIONS = void 0);
        const n = {
          MILLISECONDS: "milliseconds",
          SECONDS: "seconds",
          MINUTES: "minutes",
          HOURS: "hours",
          DAYS: "days",
          WEEKS: "weeks",
          MONTHS: "months",
          YEARS: "years",
        };
        t.TIME_UNITS = n;
        const s = 36e5,
          i = 864e5,
          o = 6048e5,
          a = {
            MILLISECONDS_IN_A_SECOND: 1e3,
            MILLISECONDS_IN_A_MINUTE: 6e4,
            MILLISECONDS_IN_A_HOUR: s,
            MILLISECONDS_IN_A_DAY: i,
            MILLISECONDS_IN_A_WEEK: o,
            MILLISECONDS_IN_A_YEAR: 314496e5,
          };
        t.TIME_CONVERSIONS = a;
        var r = { TIME_UNITS: n, TIME_CONVERSIONS: a };
        t.default = r;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = s.Ember.Service.extend({
            init: function () {
              this._super(...arguments), (this.summonerInfoById = new Map());
            },
            getSummonerInfo: function (e) {
              return e
                ? this.summonerInfoById.has(e)
                  ? Promise.resolve(this.summonerInfoById.get(e))
                  : this._fetchSummonerInfo(e)
                : Promise.resolve({});
            },
            _fetchSummonerInfo: function (e) {
              return (0, s.DataBinding)("/lol-summoner")
                .get(`/v1/summoners/${e}`)
                .then((t) => {
                  if (!t)
                    return {
                      summonerName: void 0,
                      gameName: void 0,
                      tagLine: void 0,
                      puuid: void 0,
                    };
                  const {
                      displayName: n,
                      gameName: s,
                      tagLine: i,
                      puuid: o,
                    } = t,
                    a = { summonerName: n, gameName: s, tagLine: i, puuid: o };
                  return n && this.summonerInfoById.set(e, a), a;
                });
            },
          });
        t.default = i;
      },
      (e, t, n) => {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: !0 }),
          (t.default = void 0);
        var s = n(1),
          i = s.Ember.Service.extend({
            playerReportSenderBasePath: "/lol-player-report-sender",
            champSelectReportPath: "/v1/champ-select-reports",
            init() {
              this._super(...arguments), this.initDataBindings();
            },
            willDestroy() {
              this.removeDataBindings();
            },
            initDataBindings() {
              this.playerReportSenderBinding = (0, s.DataBinding)(
                this.get("playerReportSenderBasePath"),
                s.socket,
              );
            },
            removeDataBindings() {
              this.playerReportSenderBinding = null;
            },
            sendPlayerReport: function (e) {
              return this.playerReportSenderBinding.post(
                this.get("champSelectReportPath"),
                e,
              );
            },
          });
        t.default = i;
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "CHg0kJvv",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\templates\\\\application.hbs\\" style-path=\\"null\\" js-path=\\"null\\" "],["text","\\n"],["append",["helper",["champ-select-root"],null,[["model"],[["get",["model"]]]]],false],["text","\\n\\n"],["append",["unknown",["outlet"]],false],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
      (e, t, n) => {
        const s = n(1).Ember;
        e.exports = s.HTMLBars.template({
          id: "wUk8pYx2",
          block:
            '{"statements":[["comment","#ember-component template-path=\\"T:\\\\cid\\\\p4\\\\Releases_14_10\\\\LeagueClientContent_Release\\\\15682\\\\DevRoot\\\\Client\\\\fe\\\\rcp-fe-lol-champ-select\\\\src\\\\app\\\\templates\\\\index.hbs\\" style-path=\\"null\\" js-path=\\"null\\" "],["text","\\n"]],"locals":[],"named":[],"yields":[],"blocks":[],"hasPartials":false}',
          meta: {},
        });
      },
    ],
    t = {};
  function n(s) {
    var i = t[s];
    if (void 0 !== i) return i.exports;
    var o = (t[s] = { id: s, loaded: !1, exports: {} });
    return e[s](o, o.exports, n), (o.loaded = !0), o.exports;
  }
  (n.d = (e, t) => {
    for (var s in t)
      n.o(t, s) &&
        !n.o(e, s) &&
        Object.defineProperty(e, s, { enumerable: !0, get: t[s] });
  }),
    (n.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if ("object" == typeof window) return window;
      }
    })()),
    (n.hmd = (e) => (
      (e = Object.create(e)).children || (e.children = []),
      Object.defineProperty(e, "exports", {
        enumerable: !0,
        set: () => {
          throw new Error(
            "ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " +
              e.id,
          );
        },
      }),
      e
    )),
    (n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t)),
    (n.r = (e) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (() => {
      "use strict";
      var e,
        t = (e = n(1)) && e.__esModule ? e : { default: e };
      const s = "rcp-fe-lol-champ-select",
        i = document.currentScript.ownerDocument;
      const o = window.getPluginAnnounceEventName(s);
      i.addEventListener(
        o,
        function (e) {
          (0, e.registrationHandler)(function (e) {
            return t.default
              .init(e, {
                AudioPlugin: (e) => e.get("rcp-fe-audio"),
                ChampionStatistics: (e) =>
                  e.get("rcp-fe-lol-champion-statistics"),
                ComponentFactory: (e) =>
                  e.get("rcp-fe-common-libs").getComponentFactory(1),
                ContextualNotificationManager: (e) =>
                  e.get("rcp-fe-lol-uikit").getContextualNotificationManager(),
                DataBinding: (e) =>
                  e
                    .get("rcp-fe-common-libs")
                    .getDataBinding("rcp-fe-lol-champ-select"),
                Ember: (e) => e.get("rcp-fe-ember-libs").getEmber(),
                EmberAddons: (e) =>
                  e.get("rcp-fe-ember-libs").getSharedEmberAddons(),
                EmberApplicationFactory: (e) =>
                  e.get("rcp-fe-ember-libs").getEmberApplicationFactory(),
                EmberDataBinding: (e) =>
                  e
                    .get("rcp-fe-ember-libs")
                    .getEmberDataBinding("rcp-fe-lol-champ-select"),
                EmberL10n: (e) => e.get("rcp-fe-ember-libs").getEmberL10n(1),
                gsap: (e) => e.get("rcp-fe-common-libs").getGsap("1"),
                l10n: (e) => e.get("rcp-fe-lol-l10n"),
                Lodash: (e) => e.get("rcp-fe-common-libs").getLodash(4),
                logger: (e) => e.get("rcp-fe-common-libs").logging.create(s),
                ModalManager: (e) =>
                  e.get("rcp-fe-lol-uikit").getModalManager(),
                Navigation: (e) => e.get("rcp-fe-lol-navigation"),
                playerNames: (e) => e.get("rcp-fe-common-libs").playerNames,
                PremadeVoice: (e) => e.get("rcp-fe-lol-premade-voice"),
                PurchaseAnywhereApi: (e) => e.get("rcp-fe-lol-paw"),
                sharedPayments: (e) =>
                  e.get("rcp-fe-lol-shared-components").getApi_Payments(),
                SharedComponents: (e) => e.get("rcp-fe-lol-shared-components"),
                SharedEmberComponents: (e) =>
                  e
                    .get("rcp-fe-lol-shared-components")
                    .getSharedEmberComponents(),
                Telemetry: (e) => e.get("rcp-fe-common-libs").getTelemetry(1),
                TemplateHelper: (e) =>
                  e.get("rcp-fe-lol-uikit").getTemplateHelper(),
                TooltipManager: (e) =>
                  e.get("rcp-fe-lol-uikit").getTooltipManager(),
                UiKitPlugin: (e) => e.get("rcp-fe-lol-uikit"),
                UXSettings: (e) =>
                  e.get("rcp-fe-lol-shared-components").getApi_UXSettings(),
                ViewportPlugin: (e) =>
                  e.get("rcp-fe-lol-shared-components").getApi_Viewport(),
              })
              .then(function () {
                return t.default.add({
                  EmberHelpers: (e) =>
                    e.get("rcp-fe-ember-libs").getEmberHelpers(),
                });
              })
              .then(function () {
                return n(2).default;
              });
          });
        },
        { once: !0 },
      );
    })();
})();
